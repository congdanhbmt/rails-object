<!DOCTYPE html>
<html>
<head>
  <title></title>
</head>
<body>
  <div id="content">

<h1 class="title">Objects on Rails</h1>



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1"></a></li>
<li><a href="#sec-2">Acknowledgments </a></li>
<li><a href="#sec-3">Introduction </a>
<ul>
<li><a href="#sec-3_1">What this is not </a></li>
<li><a href="#sec-3_2">About the approach </a></li>
<li><a href="#sec-3_3">About the Code </a></li>
<li><a href="#sec-3_4">A note on scale </a></li>
<li><a href="#sec-3_5">Why OOP? </a></li>
</ul>
</li>
<li><a href="#sec-4">Yet another frickin' blog app </a></li>
<li><a href="#sec-5">Adding blog entries </a>
<ul>
<li><a href="#sec-5_1">Placeholder blog entries </a></li>
<li><a href="#sec-5_2">Making new entries </a></li>
<li><a href="#sec-5_3">Posts vs. Entries </a></li>
<li><a href="#sec-5_4">The <code>Post</code> class </a></li>
<li><a href="#sec-5_5">Why "publish"? </a></li>
<li><a href="#sec-5_6">Adding entries to the blog </a></li>
</ul>
</li>
<li><a href="#sec-6">Submitting posts </a>
<ul>
<li><a href="#sec-6_1">Using ActiveModel </a></li>
<li><a href="#sec-6_2">The Post creation action </a></li>
<li><a href="#sec-6_3">Making the Blog object into a Singleton </a></li>
<li><a href="#sec-6_4">Object Trees and Lone Wolves </a></li>
</ul>
</li>
<li><a href="#sec-7">Getting the tests running again </a>
<ul>
<li><a href="#sec-7_1">Stubbing out modules </a></li>
</ul>
</li>
<li><a href="#sec-8">Adding timestamps </a>
<ul>
<li><a href="#sec-8_1">Sensible defaults for injected dependencies </a></li>
</ul>
</li>
<li><a href="#sec-9">OMG Dependency Injection! </a>
<ul>
<li><a href="#sec-9_1">Injecting only the dependencies we need </a></li>
</ul>
</li>
<li><a href="#sec-10">Sorting and limiting posts </a></li>
<li><a href="#sec-11">Adding validation </a></li>
<li><a href="#sec-12">Introducing the Exhibit Pattern </a>
<ul>
<li><a href="#sec-12_1">Exhibit A </a></li>
<li><a href="#sec-12_2">What about Presenters? </a></li>
<li><a href="#sec-12_3">Exhibit Object Characteristics </a></li>
<li><a href="#sec-12_4">Refactoring the exhibits </a></li>
<li><a href="#sec-12_5">Refactoring <code>#exhibit</code> </a></li>
<li><a href="#sec-12_6">Many models to many exhibits </a></li>
<li><a href="#sec-12_7">Do we need helpers? </a></li>
</ul>
</li>
<li><a href="#sec-13">Making the data stick around </a>
<ul>
<li><a href="#sec-13_1">The trouble with ActiveRecord </a></li>
<li><a href="#sec-13_2">Adding ActiveRecord </a></li>
<li><a href="#sec-13_3">Why does <code>Blog</code> do the saving? </a></li>
<li><a href="#sec-13_4">Updating the <code>Blog</code> tests </a></li>
<li><a href="#sec-13_5">Separating out integration tests </a></li>
<li><a href="#sec-13_6">Updating the <code>Post</code> tests </a></li>
<li><a href="#sec-13_7">Mocking ActiveRecord </a></li>
<li><a href="#sec-13_8">Stubbing out the Database with NullDB </a></li>
<li><a href="#sec-13_9">Rake tasks for testing </a></li>
<li><a href="#sec-13_10">Using ActiveRecord objects as data access objects </a></li>
</ul>
</li>
<li><a href="#sec-14">Concealing ActiveRecord behind a <code>FigLeaf</code> </a>
<ul>
<li><a href="#sec-14_1">Exiting Eden </a></li>
</ul>
</li>
<li><a href="#sec-15">Default content </a>
<ul>
<li><a href="#sec-15_1">Navel-gazing objects </a></li>
</ul>
</li>
<li><a href="#sec-16">Exhibits for REST </a></li>
<li><a href="#sec-17">Adding tags </a>
<ul>
<li><a href="#sec-17_1">An Object Model for Tags </a></li>
<li><a href="#sec-17_2"><code>Conversions</code> </a></li>
<li><a href="#sec-17_3">Attaching the <code>TagList</code> to a <code>Post</code> </a></li>
<li><a href="#sec-17_4">Making <code>Post</code> more tag-aware </a></li>
<li><a href="#sec-17_5">Accepting and displaying tags </a></li>
<li><a href="#sec-17_6">Filtering posts by tag </a></li>
<li><a href="#sec-17_7">Extracting a Taggable role </a></li>
<li><a href="#sec-17_8">Refactoring to a separate ActiveRecord model </a></li>
<li><a href="#sec-17_9">Reconsidering <code>Taggable</code> </a></li>
</ul>
</li>
<li><a href="#sec-18">Respecting controller privacy </a></li>
<li><a href="#sec-19">Jealously guarding collections </a>
<ul>
<li><a href="#sec-19_1">Objects as lending libraries </a></li>
</ul>
</li>
<li><a href="#sec-20">Toward self-rendering objects </a>
<ul>
<li><a href="#sec-20_1">Exhibiting from inside the controller </a></li>
<li><a href="#sec-20_2">Exhibiting the blog object </a></li>
<li><a href="#sec-20_3">The <code>exhibit_query</code> macro </a></li>
<li><a href="#sec-20_4">Finishing the <code>BlogExhibit</code> </a></li>
<li><a href="#sec-20_5">Rendering the list of posts </a></li>
<li><a href="#sec-20_6">An exhibit for collections </a></li>
<li><a href="#sec-20_7">Transitive exhibited-ness </a></li>
<li><a href="#sec-20_8">Telling the post to render itself </a></li>
<li><a href="#sec-20_9">Entry collection, render thyself </a></li>
<li><a href="#sec-20_10">Rendering a <code>TagList</code> </a></li>
<li><a href="#sec-20_11">Bringing it all back home </a></li>
</ul>
</li>
<li><a href="#sec-21">Summary </a>
<ul>
<li><a href="#sec-21_1">Scenarios </a></li>
</ul>
</li>
<li><a href="#sec-22">Conclusion </a>
<ul>
<li><a href="#sec-22_1">Feelin' the burn </a></li>
<li><a href="#sec-22_2">TMTOWTDI </a></li>
<li><a href="#sec-22_3"><code>at_exit</code> </a></li>
</ul>
</li>
<li><a href="#sec-23">Appendix A: Further reading </a>
<ul>
<li><a href="#sec-23_1">General </a></li>
<li><a href="#sec-23_2">Fast Tests and Mock Objects </a></li>
<li><a href="#sec-23_3">Data-Context-Interaction </a></li>
<li><a href="#sec-23_4">Presenters, decorators, and view models </a></li>
<li><a href="#sec-23_5">Views </a></li>
<li><a href="#sec-23_6">Rails </a></li>
</ul>
</li>
<li><a href="#sec-24">Appendix B: Acceptance Tests </a></li>
<li><a href="#sec-25">Appendix C: Decoration vs. Dynamic Module Extension </a>
<ul>
<li><a href="#sec-25_1">Composing an adventure </a></li>
<li><a href="#sec-25_2">Seeing in the dark </a></li>
<li><a href="#sec-25_3">A solution that's all wet </a></li>
<li><a href="#sec-25_4">Modules to the rescue </a></li>
<li><a href="#sec-25_5">Other solutions </a></li>
<li><a href="#sec-25_6">Are decorators overrated? </a></li>
<li><a href="#sec-25_7">Conclusion </a></li>
</ul>
</li>
<li><a href="#sec-26">Appendix D: Test Helper Organization </a>
<ul>
<li><a href="#sec-26_1"><code>spec/spec_helper_lite.rb</code> </a></li>
<li><a href="#sec-26_2"><code>spec/spec_helper_nulldb.rb</code> </a></li>
<li><a href="#sec-26_3"><code>spec/spec_helper_full.rb</code> </a></li>
</ul>
</li>
<li><a href="#sec-27">Credits </a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"></h2>
<div class="outline-text-2" id="text-1">


<div class="cover-page" style="text-align: center">

<p>
 <img src="./images/cover-800x600.jpg" class="cover-image" style="text-align: center; border: 1px solid black;" alt="./images/cover-800x600.jpg"> 
</p>
<p>
Objects on Rails (Revision 10) 
</p>
<p>
Copyright © Jul by Avdi Grimm. All rights reserved.
</p>


</div>


</div>

<div id="outline-container-1_1" class="outline-4">
<h4 id="sec-1_1">What is this? </h4>
<div class="outline-text-4" id="text-1_1">


<p>
This is the complete text of Objects on Rails, a "developer's
notebook" documenting some guidelines, techniques, and ideas for
applying classic object-oriented thought to Ruby on Rails
applications. This book is aimed at the working Rails developer who is
looking to grow and evolve Rails projects while keeping them flexible,
maintainable, and robust. The focus is on pragmatic solutions which
tread a "middle way" between the expedience of the Rails "golden
path", and rigid OO purity.
</p>
</div>

</div>

<div id="outline-container-1_2" class="outline-4">
<h4 id="sec-1_2">About the author </h4>
<div class="outline-text-4" id="text-1_2">


<p>
I'm <a href="http://avdi.org">Avdi Grimm</a>. I've been doing large-scale object-oriented software
development my entire programming career, first in aerospace and
networking systems, and later on for web applications. I've been
hacking in Ruby for over a decade, and I still love how fun and
effortless it makes the job of building programs out of objects. I've
<a href="http://speakerrate.com/speakers/5655-avdi-grimm">spoken at a few conferences</a> about Ruby code construction, I'm a
co-host of the <a href="http://rubyrogues.com">Ruby Rogues</a> podcast, and I blog about software at
<a href="http://devblog.avdi.org">Virtuous Code</a>. If you like, you can <a href="http://twitter.com/avdi">follow me on Twitter</a>.
</p>
<p>
I'm also a freelance consultant working with the <a href="http://codebenders.com/">Code Benders collective</a>. If you have a software project and you want to move fast
without sacrificing quality, you should <a href="http://www.codebenders.com/contact/">get in touch with us</a>.
</p>
</div>

</div>

<div id="outline-container-1_3" class="outline-4">
<h4 id="sec-1_3">Feedback &amp; Discussion </h4>
<div class="outline-text-4" id="text-1_3">


<p>
Got questions, comments, errata—or just want to discuss
object-oriented programming with other Rubyists? Come on over to the
book's <a href="https://groups.google.com/d/forum/objects-on-rails">email discussion group</a>.
</p>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Acknowledgments </h2>
<div class="outline-text-2" id="text-2">


<p>
When I first envisioned this project I saw it as a "mini-book", maybe
fifty pages at most. As I worked through the examples it exploded in
size. If it weren't for all the help and support I received along the
way I probably would have given up on it halfway through.
</p>
<p>
Of course, this book wouldn't have existed in the first place without
Ruby and Rails. Thanks to Matz and the Ruby core team for creating a
language which made object-oriented programming fun again. And to David
Heinemeier Hansson and the whole Rails team, for a framework that makes
building web applications suck less.
</p>
<p>
A huge thank you to all the beta readers who gave me feedback on drafts
of the book: Adam Guyot, Alan Gardner, Alex Chaffee, Amos King, Andre
Bernardes, Andrew Premdas, Andrew Vit, Andrew Wagner, Ants, Arvind
Laxminarayan, Assembler Ben, Bradley Grzesiak, Brendon Murphy, Brian
Jolly, Bruno Lara Tavares, Chris McGrath, Chris Zwickilton, Conrad
Taylor, Craig Savolainen, Dan Bernier, Dan Croak, Dan Dorman, Daniel
Dosen, Daniel Schierbeck, David Jacques, David Laribee, Diabolo,
Emmanuel Gomez, François Beausoleil, Gabriel Malkas, Greg S, Hugh
Kelsey, James Ladd, James Mead, Jefferson Jean Martins Girao, Jim Gay,
Joe Van Dyk, Joel Meador, Jon Olsson, Jonas Pfenniger, Joshua Flanagan,
Katrina Owen, Kerry Buckley, Kevin Rutherford, Leo Cassarani, Loren
Norman, Manuel Enrique Vidaurre Arenas, Mark Kocera, Martin Samson, Max
Justus, Michael Greenly, Michel Barbosa, Mislav Marohnić, Nick Gauthier,
Nicolas Sanguinetti, Nikolay Sturm, Noel Rappin, Paul M., Peter Jaros,
Piotr Sarnacki, Raphael, Rob Sharp, Ryan Bates, Sammy Larbi, Scott
Smith, Srdjan Pejic, Steve Klabnik, Steve Tooke, Steven Harman, Tim
Craft, TJ Singleton, Tony Semana, and Wael M. Nasreddine.
</p>
<p>
Special thanks to George Anderson and Larry Marburger, my Athos and
Aramis, for constantly encouraging me and being willing sounding-boards.
To my fellow CodeBenders, especially Matt Kern, Dan Kubb, and Piotr
Solnica: thanks for putting up with me spending so much of my time
writing. And thanks to my assistant Mandy Moore, who made it possible to
spend more of my time writing and less of it dealing with administrative
headaches.
</p>
<p>
Finally and most importantly, thank you to Stacey for unwaveringly
supporting the projects that preoccupy me; for the fresh AeroPress
coffee in the morning after every up-til-5AM writing session; and for
reminding me to eat every now and then. And to Lily, Josh, Kashti, and
Ebba, for being the best kids ever.
</p>

</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Introduction </h2>
<div class="outline-text-2" id="text-3">


<p>
Hi there! Welcome to Objects on Rails. This text is a step-by-step
walkthrough following the construction of a simple web application
using Ruby on Rails. It differs from other such walkthroughs in that
it attempts to apply a strongly Object-Oriented philosophy to the
process.
</p>
<p>
"Wait a sec!" you say. "Isn't Rails already Object-Oriented?" Well,
yes and no. While Rails is written in a thoroughly OO language, and
built on some solid OO patterns, there are aspects of conventional
Rails application development which depart significantly from OO
practices.
</p>
<p>
Which is not necessarily a problem in and of itself. Lots of programs
get by just fine with (for instance) a mix of OO and Functional
programming styles. But experience has shown that these same Rails
not-so-OO practices—such as models which violate the Single
Responsibility Principle (SRP), or putting complex business logic in
helpers—are a common source of development delays in maturing Rails
applications.
</p>
<p>
In this text we'll build a basic blog application (yes, another
one). You'll be my virtual pair-programmer as I work through the
problems the application presents by applying what I've learned of
Object-Oriented design over the years. I'll do my best to explain my
reasoning, step you through the code piece by piece, and point you to
further information about the patterns and guidelines I'm following.
</p>
<p>
In some parts the "Objects" aspect of the text will just mean small
tweaks to standard Rails practices. In other areas we'll take extended
side-tracks from the so-called "golden path". Some techniques I apply
will be tried-and-and-true chestnuts I use in every project I work on;
others will be tools I only haul out occasionally. In a few cases I'll
use this exercise as an opportunity to work through ideas I haven't
had the opportunity to fully flesh out until now. In a few cases that
might mean we go down a dead-end siding; when that happens I'll let
you know, and do my best to explain the thinking which lead up to it.
</p>

</div>

<div id="outline-container-3_1" class="outline-3">
<h3 id="sec-3_1">What this is not </h3>
<div class="outline-text-3" id="text-3_1">


<dl>
<dt>This is not a Rails tutorial</dt><dd>Familiarity with Rails and Ruby is assumed.
</dd>
<dt>This is not a Rails critique</dt><dd>This is not all about how "Rails is
     wrong". Rails is a terrifically powerful framework for quickly
     assembling web applications. I'm interested in how to better use
     the tools Rails provides, not so much in how to subvert or
     replace them.
</dd>
<dt>This is not comprehensive</dt><dd>This text is effectively a snapshot of
     some of my Rails development preferences and ideas circa late
     2011/early 2012. It doesn't capture every possible application of
     OO patterns or SOLID principles to Rails development.
</dd>
<dt>This is not a rule book or a "best-practices" manual</dt><dd>The last
     thing I want anyone to do is follow the approach shown here as a
     book of rules for how to build a Rails application "right". I
     hope that you'll consider the patterns and idioms presented here,
     and select the ones that speak to you and make sense for your
     application. If nothing else, I hope to give you some food for
     thought.
</dd>
</dl>


</div>

</div>

<div id="outline-container-3_2" class="outline-3">
<h3 id="sec-3_2">About the approach </h3>
<div class="outline-text-3" id="text-3_2">


<p>
   This text takes the form of a walkthrough. We'll build an app
   step-by-step using Test-Driven Design (TDD), at most steps
   presenting test code followed by implementation code.
</p>
<p>
   However, while we will use TDD at the unit test level to drive
   development, there is a major piece missing from our TDD
   stack. Ordinarily, when building a "real" app, I would drive each
   feature from the outside in using acceptance tests, typically
   written using Cucumber. However, in the interests of brevity, I
   omit the acceptance testing component in this document. For the
   curious, I've included the Cucumber acceptance tests in <a href="#sec-24">Appendix B</a>.
</p>
</div>

</div>

<div id="outline-container-3_3" class="outline-3">
<h3 id="sec-3_3">About the Code </h3>
<div class="outline-text-3" id="text-3_3">

<p>   With a few exceptions, all the code samples are from the working
   demo codebase I built as I wrote the text. If you have the "deluxe
   edition" you have access to a full copy of the source code,
   including revision history. I've taken the liberty of eliding some
   of the code samples in the text to show only the bits that are 
   interesting or relevant to the discussion; this means, for
   instance, that some <code>require</code> statements have been omitted.
</p>
<p>
   This text uses Ruby 1.9. Among other things, I make extensive use
   of the new "stabby lambda" syntax:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">Ruby 1.8</span>
lambda{|x,y| x + y}
<span class="org-comment-delimiter"># </span><span class="org-comment">Ruby 1.9</span>
-&gt;(x,y){ x + y}

</pre>


<div class="caption">Stabby lambdas</div>
</div>


<p>
   If you're not familiar with the changes from 1.8 to 1.9, I highly
   recommend <a href="http://www.rubyinside.com/19walkthrough/">Peter Cooper's comprehensive walkthrough</a> on the subject.
</p>
<p>
   Also note that I use the "<a href="http://onestepback.org/index.cgi/Tech/Ruby/BraceVsDoEnd.rdoc">Weirich convention</a>" for choosing between
   <code>{}</code> and <code>do...end</code> delimiters around blocks. So blocks which are
   evaluated for their result value, I surround with braces (<code>{}</code>);
   whereas blocks which are evaluated for their side-effects get
   <code>do...end</code>.
</p>
</div>

</div>

<div id="outline-container-3_4" class="outline-3">
<h3 id="sec-3_4">A note on scale </h3>
<div class="outline-text-3" id="text-3_4">


<p>
   The challenge in writing about code patterns is to come up with
   examples that are simple and clear enough that the supporting code
   doesn't get in the way of understanding the specific technique
   being demonstrated–while still hopefully avoiding examples that
   feel completely contrived. Unfortunately, if you succeed in that,
   you are often confronted with a new problem: the example problems
   you carefully distilled down to their essence now seem so simple,
   so trivial that whatever refactoring or abstraction you're trying
   to illustrate seems superfluous and a waste of effort.
</p>
<p>
   The application I work through in these pages is a deliberately
   simple one, and many of the techniques I demonstrate may seem like
   massive overkill for the task at hand. Please understand, as you
   read through the examples, that these are patterns and idioms
   intended to make the development and evolution of large-scale
   applications more tractable. While they may seem less than
   compelling in the context of a "toy" app, hopefully you can
   visualize how they might be helpful for larger-scale development.
</p>
</div>

</div>

<div id="outline-container-3_5" class="outline-3">
<h3 id="sec-3_5">Why OOP? </h3>
<div class="outline-text-3" id="text-3_5">


<p>
Why bother with these techniques? What's wrong with the way we've
always written Rails applications?
</p>
<p>
The biggest reason—scratch that, the <i>only</i> reason—is to make our
apps easier to change. The only constant in life is change, and that
goes double for software projects. Markets change, requirements change,
external dependencies change, and platforms change. As <a href="http://avdi.org/devblog/2011/08/22/your-code-is-my-hell/">I've written about at length</a> elsewhere, Rails is reaching a point at the time of
writing where a lot of projects are starting to mature, and a lot of
developers are realizing their projects aren't nearly as easy to
modify as they used to be.
</p>
<p>
It's risky for me to give some specific example, e.g. "by
following these guidelines, you'll be able to easily change to MongoDB
in the future!". Inevitably someone will say "hah, my app will never
need to switch to MongoDB, therefore I don't need these techniques!"
</p>
<p>
Attempts to predict <i>which</i> parts of a codebase will need to change,
and to structure it accordingly, have ended badly more often than
not. Part of the nature of change is that you often don't know
beforehand <i>what</i> is going to need change. In this text I'm not going
to attempt to say "using such and so technique will make such and so
component easier to change". In fact, I would encourage you not to
spend too much time thinking about what is most likely to change. Much
like premature optimization, premature change management usually
misses the mark.
</p>
<p>
Amongst all this uncertainty, there are some basic principles that
have proven, over decades of Object-Oriented software development, to
make software generally more flexible and amenable to
change. Principles such as:
</p>
<ul>
<li>Small objects with a single, well-defined responsibility.
</li>
<li>Small methods that do only one thing.
</li>
<li>Limiting the number of types an object collaborates with.
</li>
<li>Strictly limiting the use of global state and singletons (that
  includes limiting the use of class-level methods).
</li>
<li>Small object interfaces with simple method signatures.
</li>
<li>Preferring composition over inheritance.
</li>
</ul>


<p>
These rules of thumb, practiced habitually, tend to lead to more flexible
codebases which can adapt to <i>any</i> type of change adroitly; whether
the change is a data model which better resembles the problem domain;
a new data storage backend; or a re-structuring of the app into a
half-dozen mini-apps.
</p>
<p>
So the answer to <i>why</i>, in the end, is "because things change". Some
good habits and sound architectural guidance early on in a project can
save a lot of headaches down the road.
</p>
<p>
With that intent in mind, let's jump in!
</p>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><a name="ID-4886e18d-0f66-4941-83a7-dd07955b194c" id="ID-4886e18d-0f66-4941-83a7-dd07955b194c"></a>Yet another frickin' blog app </h2>
<div class="outline-text-2" id="text-4">


<p>
Let's write a new blog app in Rails, since no one's ever done that
before!
</p>
<p>
We'll use Rails version 3.0, running on Ruby (MRI) 1.9.2. 
</p>



<pre class="example">$ rails new bloog --skip-test-unit --skip-prototype
      create  
      create  README
      create  Rakefile
      create  config.ru
      create  .gitignore
      create  Gemfile
      create  app
      # ...
</pre>




<p>
(Note: if you are following along at home, be sure not to name your
project "blog". We'll be defining a class named <code>Blog</code> later, which
will clash with the <code>Blog</code> application class Rails generates in that
case.)
</p>
<p>
I guess we should start with the home page. Let's add a route:
</p>



<pre class="src src-ruby">root to: <span class="org-string">"blog#index"</span>

</pre>




<p>
Now we'll need a controller for that route to work:
</p>



<pre class="example">$ rails g controller blog index
      create  app/controllers/blog_controller.rb
       route  get "blog/index"
      invoke  erb
      create    app/views/blog
      create    app/views/blog/index.html.erb
      invoke  helper
      create    app/helpers/blog_helper.rb
</pre>




<p>
Hm, what should the view look like?
</p>
<p>
Well, we <i>are</i> presenting a blog. So presumably we'll have an object
to represent the blog.
</p>


<div class="listing">

<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/blog/index.html.erb </span><span class="org-comment-delimiter">--&gt;</span>

&lt;<span class="org-function-name">h1</span>&gt;&lt;%= @blog.title %&gt;&lt;/<span class="org-function-name">h1</span>&gt;
&lt;<span class="org-function-name">h2</span>&gt;&lt;%= @blog.subtitle %&gt;&lt;/<span class="org-function-name">h2</span>&gt;

</pre>


<div class="caption">The first view</div>
</div>


<p>
OK, now we know we need a blog object in the view. Let's create it in
the controller:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/controllers/blog_controller.rb</span>
<span class="org-keyword">class</span> <span class="org-type">BlogController</span> &lt; <span class="org-type">ApplicationController</span>
  <span class="org-keyword">def</span> <span class="org-function-name">index</span>
    <span class="org-variable-name">@blog</span> = <span class="org-type">Blog</span>.new
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The blog controller</div>
</div>


<p>
Looks like we need a <code>Blog</code> class next.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/models/blog.rb</span>
<span class="org-keyword">class</span> <span class="org-type">Blog</span>
  <span class="org-keyword">def</span> <span class="org-function-name">title</span>
    <span class="org-string">"Watching Paint Dry"</span>
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">subtitle</span>
    <span class="org-string">"The trusted source for drying paint news &amp; opinion"</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The Blog model</div>
</div>


<p>
At this point we can load the page:
</p>


<div class="figure">
  <img src="./images/bloog-title-subtitle.png" alt="Loading the page for the first time">
  <div class="caption">Loading the page for the first time</div>
</div>


</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><a name="ID-d180a5f4-e2e9-4506-8ea0-77445e39a512" id="ID-d180a5f4-e2e9-4506-8ea0-77445e39a512"></a>Adding blog entries </h2>
<div class="outline-text-2" id="text-5">


<p>
A blog without entries isn't very useful. Let's add blog posts to the
app. Since we're adding something more complex than just static
strings, we'll TDD it. Just to prove there's nothing up our sleeves,
we'll use MiniTest/Spec.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/models/blog_spec.rb</span>
require <span class="org-string">'minitest/autorun'</span>
require_relative <span class="org-string">'../../app/models/blog'</span>
describe <span class="org-type">Blog</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span> = <span class="org-type">Blog</span>.new
  <span class="org-keyword">end</span>
  it <span class="org-string">"has no entries"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.entries.must_be_empty
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The first test</div>
</div>


<p>
Running this spec results in a failure:
</p>



<pre class="example">$ ruby spec/models/blog_spec.rb 
Loaded suite spec/models/blog_spec
Started
E
Finished in 0.001575 seconds.
  1) Error:
test_0001_should_have_no_entries(BlogSpec):
NoMethodError: undefined method `entries' for #&lt;Blog:0x894b044&gt;
    spec/models/blog_spec.rb:10:in `block (2 levels) in &lt;main&gt;'
1 tests, 0 assertions, 0 failures, 1 errors, 0 skips
</pre>




<p>
To make it pass, we add an <code>entries</code> attribute to <code>Blog</code>:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Blog</span>
  attr_reader <span class="org-constant">:entries</span>

  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>
    <span class="org-variable-name">@entries</span> = []
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Adding entries to the blog</div>
</div>


<p>
When we run the tests again, they pass:
</p>



<pre class="example">$ ruby spec/models/blog_spec.rb 
Loaded suite spec/models/blog_spec
Started
.
Finished in 0.002619 seconds.
1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
</pre>




<p>
You may have noticed that we're not using any kind of Rails
integration for setting up and running the tests. We're not even
relying on Rails constant autoloading. This is intentional. By writing
"plain old tests" which don't rely on any special Rails helpers, we
keep the tests isolated and force ourselves to be deliberate about
creating any dependencies between our objects. We anticipate that this
will have a salutary effect on the object design which emerges from
our TDD process.
</p>
<p>
As a welcome side effect, the tests run ridiculously fast.
</p>

</div>

<div id="outline-container-5_1" class="outline-3">
<h3 id="sec-5_1"><a name="ID-6c9ee215-55f5-477d-be6c-0e3de4f3b663" id="ID-6c9ee215-55f5-477d-be6c-0e3de4f3b663"></a>Placeholder blog entries </h3>
<div class="outline-text-3" id="text-5_1">


<p>
OK, now we have an <code>entries</code> attribute on <code>Blog</code>, but there's nothing
in it. Let's add some temporary example blog posts in the
<code>BlogController</code>.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">index</span>
  <span class="org-variable-name">@blog</span> = <span class="org-type">Blog</span>.new
  post1 = <span class="org-variable-name">@blog</span>.new_post
  post1.title = <span class="org-string">"Paint just applied"</span>
  post1.body = <span class="org-string">"Paint just applied. It's a lovely orangey-purple!"</span>
  post1.publish
  post2 = <span class="org-variable-name">@blog</span>.new_post(title: <span class="org-string">"Still wet"</span>)
  post2.body = <span class="org-string">"Paint is still quite wet. No bubbling yet!"</span>
  post2.publish
<span class="org-keyword">end</span>

</pre>


<div class="caption">Placeholder entries</div>
</div>


<p>
You may have noticed that we're calling a <code>#new_post</code> method which
doesn't exist yet, followed by some other methods on the return value
which also don't exist. Now that we know what code we need, let's make
it exist.
</p>
</div>

</div>

<div id="outline-container-5_2" class="outline-3">
<h3 id="sec-5_2"><a name="ID-a46ff338-26d8-41b9-b822-83388d08eef4" id="ID-a46ff338-26d8-41b9-b822-83388d08eef4"></a>Making new entries </h3>
<div class="outline-text-3" id="text-5_2">


<p>
First, let's specify that <code>#new_post</code> method. Clearly it needs to
return some kind of blog post object which is associated with the Blog
object. However, we want to keep our tests isolated, and we only want
to test one model at a time. So we'll make the process by which new
posts are created easy to swap out:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Blog</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  attr_writer <span class="org-constant">:post_source</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  private
  <span class="org-keyword">def</span> <span class="org-function-name">post_source</span>
    <span class="org-variable-name">@post_source</span> ||= <span class="org-type">Post</span>.public_method(<span class="org-constant">:new</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">A post source</div>
</div>


<p>
<code>#public_method</code>, if you're unfamiliar with it, instantiates a
<code>call</code>-able <code>Method</code> object. When the object's <code>#call</code> method is
invoked it will be as if we called the named method on the original
object. The "public" in the name refers to the fact that unlike
<code>#method</code>, <code>#public_method</code> respects public/private boundaries and
will not generate a <code>Method</code> object for a private method.
</p>
<p>
In this case, <code>Post.public_method</code> grabs a reference to a <code>Method</code>
object representing the (not yet written) <code>Post.new</code> method. During
normal operation, <code>Blog</code> will use this method reference (the
equivalent of calling <code>Post.new</code>) to generate post objects. But we can
substitute any <code>call</code>-able object when testing the class.
</p>
<p>
Now we'll make some assertions about how <code>Blog#new_post</code> should behave:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/models/blog_spec.rb</span>
require <span class="org-string">'ostruct'</span>
describe <span class="org-type">Blog</span> <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  describe <span class="org-string">"#new_post"</span> <span class="org-keyword">do</span>
    before <span class="org-keyword">do</span>
      <span class="org-variable-name">@new_post</span> = <span class="org-type">OpenStruct</span>.new
      <span class="org-variable-name">@it</span>.post_source = -&gt;{ <span class="org-variable-name">@new_post</span> }
    <span class="org-keyword">end</span>
    it <span class="org-string">"returns a new post"</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span>.new_post.must_equal <span class="org-variable-name">@new_post</span>
    <span class="org-keyword">end</span>
    it <span class="org-string">"sets the post's blog reference to itself"</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span>.new_post.blog.must_equal(<span class="org-variable-name">@it</span>)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Specifying Blog#new_post</div>
</div>


<p>
Here, we substitute a lambda which simply returns an <code>OpenStruct</code> for
the <code>#post_source</code>.
</p>
<p>
Making these pass is straightforward:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Blog</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">new_post</span>
    post_source.call.tap <span class="org-keyword">do</span> |p|
      p.blog = <span class="org-variable-name">self</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Implementing Blog#new_post</div>
</div>



</div>

<div id="outline-container-5_2_1" class="outline-4">
<h4 id="sec-5_2_1">Aside: <code>subject</code> and <code>let</code> </h4>
<div class="outline-text-4" id="text-5_2_1">

<p>    After I completed most of the examples in this text someone pointed
    out to me that recent versions of MiniTest have borrowed the <code>let</code>
    and <code>subject</code> methods from RSpec. I'm not going to go through and
    update every example, but I think it's worth demonstrating them
    briefly, since they make specs more concise and declarative.
</p>
<p>
    Here's an elided version of <code>blog_spec.rb</code> using <code>subject</code> and
    <code>let</code>:
</p>


<div class="listing">

<pre class="src src-ruby">describe <span class="org-type">Blog</span> <span class="org-keyword">do</span>
  subject       { <span class="org-type">Blog</span>.new(-&gt;{entries}) }
  let(<span class="org-constant">:entries</span>) { [] }

  it <span class="org-string">"has no entries"</span> <span class="org-keyword">do</span>
    subject.entries.must_be_empty
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Using MiniTest's "subject" and "let"</div>
</div>


<p>
    As you can see, <code>@it</code> has been replaced with <code>subject</code>, and
    <code>@entries</code> is now <code>entries</code>.
</p>
<p>
    Besides removing the need for a <code>before</code> block, <code>let</code> and
    <code>subject</code> have some other useful properties: they are lazily
    instantiated and memoized. Meaning that if a test doesn't use
    <code>entries</code> at all, the object will never be instantiated. And if
    the test references <code>entries</code> more than once, the definition block
    will only be run once, and the value it returns will be reused. If
    you have objects which are expensive to create, this can make your
    tests run a little faster.
</p>
<p>
    Note that to get access to <code>let</code> and <code>subject</code> you will need
    either the gem version of MiniTest, or Ruby 1.9.3.
</p>
</div>
</div>

</div>

<div id="outline-container-5_3" class="outline-3">
<h3 id="sec-5_3"><a name="ID-a58a2ad4-12d3-4cec-8c0d-8d590a49ec2f" id="ID-a58a2ad4-12d3-4cec-8c0d-8d590a49ec2f"></a>Posts vs. Entries </h3>
<div class="outline-text-3" id="text-5_3">

<p>   Hold on a sec. Aren't we getting our terms confused here? First we
   said a <code>Blog</code> has "entries". But then we started talking about
   "posts". Shouldn't we pick one or the other?
</p>
<p>
   In fact, this choice to use multiple terms is deliberate. The dark
   side of having sensible framework conventions is that after a
   while, those conventions turn into assumptions. In this case, if we
   called the <code>entries</code> collection <code>posts</code> instead, there's a good
   chance we'd start mentally conflating it with the <code>Post</code>
   class. Anything in <code>blog.posts</code> is a <code>Post</code> object, end of story.
</p>
<p>
   This is one of those subtle assumptions that can lead to big
   problems. For instance, if we assume <code>blog.new_post</code> is equivalent
   to <code>Post.new</code>, we might start to just skip the <code>Blog</code> part and
   write <code>Post.new(...)</code> or <code>Post.create(...)</code> whenever we want a new
   blog entry.
</p>
<p>
   Now imagine some time passes, and we add the ability for a <code>Blog</code>
   to have many different types of posts—photos, embedded videos,
   etc, each represented by different classes such as <code>PhotoPost</code> and
   <code>VideoPost</code>. A call to <code>Blog.new_post(...)</code> looks at the arguments
   arguments and chooses the right type of object to
   instantiate. Unfortunately, we hard-coded references to <code>Post</code>
   everywhere, and now we have to go back and change them all.
</p>
<p>
   These kinds of assumptions don't just lead to extra work; they can
   introduce security holes. Let's say we made the "blog entries are
   <code>Posts</code>" assumption, and as a result we coded various controller
   actions to look like this:
</p>



<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">update</span>
  <span class="org-variable-name">@post</span> = <span class="org-type">Post</span>.find(params[<span class="org-constant">:id</span>])
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>




<p>
   Then one day we decide to add the ability to host multiple
   blogs. Instead of a singleton <code>Blog</code> instance, there are multiple
   blogs, each owned by a different user. The controllers are all
   updated to make sure that actions modifying a <code>Blog</code> can only be
   made by the user who owns that blog.
</p>
<p>
   The upgrade goes easily, and everything is working great. Then one
   day a clever user realizes that if he can guess the ID of someone
   else'spost, he can modify its content! Why is this possible?
   Because all those calls to <code>Post.find()</code> bypassed any scope
   constraints imposed by accessing posts from a <code>Blog</code> instance
   instead of fetching them directly.
</p>
<p>
   These are not hypothetical issues; I've seen them in production
   codebases. Using different terms for "the blog's entries" and "a
   Post object" doesn't automatically fix the problem. But if they
   mentally trip us up a bit, that might just be the nudge we need to
   remember that the entries managed by a blog are not necessarily
   equivalent to the set of all <code>Post</code> records. The topic of this text
   is looking at Rails projects with a fresh perspective, and playing
   with naming is one way to do that.
</p>
</div>

</div>

<div id="outline-container-5_4" class="outline-3">
<h3 id="sec-5_4"><a name="ID-602d83bb-6946-4afd-9dfe-ce24faabe5cd" id="ID-602d83bb-6946-4afd-9dfe-ce24faabe5cd"></a>The <code>Post</code> class </h3>
<div class="outline-text-3" id="text-5_4">


<p>
It's pretty obvious that our next step needs to be creating a <code>Post</code>
class. Let's specify its behavior.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/models/post_spec.rb</span>

require <span class="org-string">'minitest/autorun'</span>
require_relative <span class="org-string">'../../app/models/post'</span>

describe <span class="org-type">Post</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span> = <span class="org-type">Post</span>.new
  <span class="org-keyword">end</span>

  it <span class="org-string">"starts with blank attributes"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.title.must_be_nil
    <span class="org-variable-name">@it</span>.body.must_be_nil
  <span class="org-keyword">end</span>

  it <span class="org-string">"supports reading and writing a title"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.title = <span class="org-string">"foo"</span>
    <span class="org-variable-name">@it</span>.title.must_equal <span class="org-string">"foo"</span>
  <span class="org-keyword">end</span>

  it <span class="org-string">"supports reading and writing a post body"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.body = <span class="org-string">"foo"</span>
    <span class="org-variable-name">@it</span>.body.must_equal <span class="org-string">"foo"</span>
  <span class="org-keyword">end</span>

  it <span class="org-string">"supports reading and writing a blog reference"</span> <span class="org-keyword">do</span>
    blog = <span class="org-type">Object</span>.new
    <span class="org-variable-name">@it</span>.blog = blog
    <span class="org-variable-name">@it</span>.blog.must_equal blog
  <span class="org-keyword">end</span>

  describe <span class="org-string">"#publish"</span> <span class="org-keyword">do</span>
    before <span class="org-keyword">do</span>
      <span class="org-variable-name">@blog</span> = <span class="org-type">MiniTest</span>::<span class="org-type">Mock</span>.new
      <span class="org-variable-name">@it</span>.blog = <span class="org-variable-name">@blog</span>
    <span class="org-keyword">end</span>

    after <span class="org-keyword">do</span>
      <span class="org-variable-name">@blog</span>.verify
    <span class="org-keyword">end</span>

    it <span class="org-string">"adds the post to the blog"</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">@blog</span>.expect <span class="org-constant">:add_entry</span>, <span class="org-variable-name">nil</span>, [<span class="org-variable-name">@it</span>]
      <span class="org-variable-name">@it</span>.publish
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Specifying the Post class</div>
</div>


<p>
Next we satisfy the specification:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/models/post.rb</span>
<span class="org-keyword">class</span> <span class="org-type">Post</span>
  attr_accessor <span class="org-constant">:blog</span>, <span class="org-constant">:title</span>, <span class="org-constant">:body</span>
  <span class="org-keyword">def</span> <span class="org-function-name">publish</span>
    blog.add_entry(<span class="org-variable-name">self</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Implementing the Post class</div>
</div>


</div>

</div>

<div id="outline-container-5_5" class="outline-3">
<h3 id="sec-5_5"><a name="ID-62f596c8-67de-42a9-8bce-1bb4cd26f680" id="ID-62f596c8-67de-42a9-8bce-1bb4cd26f680"></a>Why "publish"? </h3>
<div class="outline-text-3" id="text-5_5">


<p>
If you've written a few Rails apps you may be wondering why we're
calling the method which makes a new blog entry <code>#publish</code> instead of
<code>#save</code>.
</p>
<p>
One of the central elements of object-oriented design is capturing the
<i>language of the domain</i> in our models. Think for a minute about the
language of blogging. No one says "I <i>saved</i> a blog post the other
day". They say "I <i>published</i> a blog post" or maybe "I <i>posted</i> a blog
entry". By calling the method <code>#publish</code>, we are continuing to build a
system which echoes our mental model of the domain.
</p>
<p>
Consider how we might extend this program in the future. We might add
scheduled posts, which appear some period of days later than they are
first saved. We might also add a draft state for posts, where they are
saved but they are only visible to the blog owner.
</p>
<p>
Our choice of the verb <code>#publish</code> fits right into this extended
workflow:
</p>



<pre class="src src-ruby">post.save_draft
<span class="org-comment-delimiter"># </span><span class="org-comment">followed by ...</span>
post.schedule
<span class="org-comment-delimiter"># </span><span class="org-comment">or...</span>
post.publish

</pre>




<p>
This is not a coincidence. Choosing appropriate domain language for
program elements often means we don't need to rename as many things as
we add more features down the road.
</p>
</div>

</div>

<div id="outline-container-5_6" class="outline-3">
<h3 id="sec-5_6">Adding entries to the blog </h3>
<div class="outline-text-3" id="text-5_6">


<p>
Driving out <code>Post</code> has revealed that we need one more method on
<code>Blog</code>, one which will actually add the post to the blog. We'll
quickly spec it out and add it.
</p>


<div class="listing">

<pre class="src src-ruby">describe <span class="org-type">Blog</span> <span class="org-keyword">do</span>
  describe <span class="org-string">"#add_entry"</span> <span class="org-keyword">do</span>
    it <span class="org-string">"adds the entry to the blog"</span> <span class="org-keyword">do</span>
      entry = <span class="org-type">Object</span>.new
      <span class="org-variable-name">@it</span>.add_entry(entry)
      <span class="org-variable-name">@it</span>.entries.must_include(entry)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Specifying Blog#add_entry</div>
</div>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Blog</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">add_entry</span>(entry)
    entries &lt;&lt; entry
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Implementing Blog#add_entry</div>
</div>


<p>
Looking back at our demo code in the <code>BlogController</code>, we remember
that in making a second post, we changed things up a little and passed
in the title as an argument:
</p>



<pre class="src src-ruby">post2 = <span class="org-variable-name">@blog</span>.new_post(title: <span class="org-string">"Still wet"</span>)

</pre>




<p>
Let's modify <code>Blog#new_post</code> to support this syntax. First, the spec:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
it <span class="org-string">"accepts an attribute hash on behalf of the post maker"</span> <span class="org-keyword">do</span>
  post_source = <span class="org-type">MiniTest</span>::<span class="org-type">Mock</span>.new
  post_source.expect(<span class="org-constant">:call</span>, <span class="org-variable-name">@new_post</span>, [{x: 42, y: <span class="org-string">'z'</span>}])
  <span class="org-variable-name">@it</span>.post_source = post_source
  <span class="org-variable-name">@it</span>.new_post(x: 42, y: <span class="org-string">'z'</span>)
  post_source.verify
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Specifying Blog#new_post</div>
</div>


<p>
And then the implementation:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">new_post</span>(*args)
  post_source.call(*args).tap <span class="org-keyword">do</span> |p|
    p.blog = <span class="org-variable-name">self</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Implementing Blog#new_post</div>
</div>


<p>
Now we're passing the arguments along, but we still need to implement
keyword arguments on the <code>Post</code> initializer.
</p>


<div class="listing">

<pre class="src src-ruby">describe <span class="org-type">Post</span> <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  it <span class="org-string">"supports setting attributes in the initializer"</span> <span class="org-keyword">do</span>
    it = <span class="org-type">Post</span>.new(title: <span class="org-string">"mytitle"</span>, body: <span class="org-string">"mybody"</span>)
    it.title.must_equal <span class="org-string">"mytitle"</span>
    it.body.must_equal <span class="org-string">"mybody"</span>
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Specifying keyword arguments for new posts</div>
</div>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(attrs={})
    attrs.each <span class="org-keyword">do</span> |k,v| send(<span class="org-string">"</span><span class="org-variable-name">#{k}</span><span class="org-string">="</span>,v) <span class="org-keyword">end</span> 
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Implementing keyword arguments</div>
</div>


<p>
Now we just need to update the views to show our posts.
</p>


<div class="listing">

<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/blog/index.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">h1</span>&gt;&lt;%= @blog.title %&gt;&lt;/<span class="org-function-name">h1</span>&gt;
&lt;<span class="org-function-name">h2</span>&gt;&lt;%= @blog.subtitle %&gt;&lt;/<span class="org-function-name">h2</span>&gt;
&lt;%= render partial: <span class="org-string">"entry"</span>, collection: @blog.entries %&gt;

</pre>


<div class="caption">Showing blog entries on the index page</div>
</div>


<div class="listing">

<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/blog/_entry.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">article</span>&gt;
  &lt;<span class="org-function-name">header</span>&gt;
    &lt;<span class="org-function-name">h3</span>&gt;&lt;%= entry.title %&gt;&lt;/<span class="org-function-name">h3</span>&gt;
  &lt;/<span class="org-function-name">header</span>&gt;
  &lt;<span class="org-function-name">p</span>&gt;&lt;%= entry.body %&gt;&lt;/<span class="org-function-name">p</span>&gt;
&lt;/<span class="org-function-name">article</span>&gt;

</pre>


<div class="caption">The Blog entry partial</div>
</div>


<p>
Reloading the page, we can see our demo entries.
</p>


<div class="figure">
  <img src="./images/showing-entries.png" alt="Showing entries">
  <div class="caption">Showing entries</div>
</div>


</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">Submitting posts </h2>
<div class="outline-text-2" id="text-6">


<p>
This is progress, but a blog with static entries doesn't do us a lot
of good. We need to be able to submit new entries.
</p>
<p>
First we'll add a "New post" link.
</p>


<div class="listing">

<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/layouts/application.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
<span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">div</span> <span class="org-variable-name">class</span>=<span class="org-string">"sidebar two columns"</span>&gt;
  &lt;<span class="org-function-name">nav</span>&gt;
    &lt;<span class="org-function-name">ul</span>&gt;
      &lt;<span class="org-function-name">li</span>&gt;&lt;%= link_to <span class="org-string">"New post..."</span>, new_post_path %&gt;&lt;/<span class="org-function-name">li</span>&gt;
    &lt;/<span class="org-function-name">ul</span>&gt;
  &lt;/<span class="org-function-name">nav</span>&gt;
&lt;/<span class="org-function-name">div</span>&gt;
<span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>

</pre>


<div class="caption">Adding a "New post" link</div>
</div>


<p>
For that <code>new_post_path</code> call to work we need a route:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">config/routes.rb</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
resources <span class="org-constant">:posts</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Routes for posts</div>
</div>


<p>
And for the route to work we need a controller:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/controllers/posts_controller.rb</span>
<span class="org-keyword">class</span> <span class="org-type">PostsController</span> &lt; <span class="org-type">ApplicationController</span>
  <span class="org-keyword">def</span> <span class="org-function-name">new</span>
    <span class="org-variable-name">@post</span> = <span class="org-variable-name">@blog</span>.new_post
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The posts controller</div>
</div>


<p>
Looks like we need the <code>@blog</code> object in the <code>PostsController</code> as well
as the <code>BlogController</code>. Time to factor the code that sets it out into the
<code>ApplicationController</code>:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/controllers/application_controller.rb</span>
<span class="org-keyword">class</span> <span class="org-type">ApplicationController</span> &lt; <span class="org-type">ActionController</span>::<span class="org-type">Base</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  before_filter <span class="org-constant">:init_blog</span>
  private
  <span class="org-keyword">def</span> <span class="org-function-name">init_blog</span>
    <span class="org-variable-name">@blog</span> = <span class="org-type">Blog</span>.new
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Making the blog instance available from the PostsController</div>
</div>


<p>
That's enough to make the link render but we need somewhere for it to
go. We'll create a quick "new post" form:
</p>


<div class="listing">

<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/posts/new.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">h1</span>&gt;<span class="org-underline"><span class="org-bold">New Post</span></span>&lt;/<span class="org-function-name">h1</span>&gt;
&lt;%= form_for @post do |f| %&gt;
  &lt;%= f.text_field :title %&gt;
  &lt;%= f.text_area :body %&gt;
  &lt;%= f.submit %&gt;
&lt;% end %&gt;

</pre>


<div class="caption">A form for new posts</div>
</div>



</div>

<div id="outline-container-6_1" class="outline-3">
<h3 id="sec-6_1"><a name="ID-fd1ecf21-ab45-4b29-9d9d-e1fbe975dd86" id="ID-fd1ecf21-ab45-4b29-9d9d-e1fbe975dd86"></a>Using ActiveModel </h3>
<div class="outline-text-3" id="text-6_1">


<p>
We're almost there, but in order to construct paths and render forms,
Rails has certain expectations about the protocols that a model object
will respond to—protocols that our basic <code>Post</code> class doesn't know
about. The easiest way to make it compliant is to add a couple of
modules from <code>ActiveModel</code>. We also need to implement one method
ourselves: <code>#persisted?</code>. For now, it's sufficient to just return
<code>false</code>.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span>
  extend <span class="org-type">ActiveModel</span>::<span class="org-type">Naming</span>
  include <span class="org-type">ActiveModel</span>::<span class="org-type">Conversion</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  <span class="org-keyword">def</span> <span class="org-function-name">persisted?</span>
    <span class="org-variable-name">false</span>
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Augmenting Post with ActiveModel modules</div>
</div>


<p>
With that change, we can click on our "New post…" link and see a new
post form.
</p>


<div class="figure">
  <img src="./images/new-post.png" alt="New post form">
  <div class="caption">New post form</div>
</div>


</div>

</div>

<div id="outline-container-6_2" class="outline-3">
<h3 id="sec-6_2">The Post creation action </h3>
<div class="outline-text-3" id="text-6_2">


<p>
So far so good. Now let's make submitting the form work. We need to
add a <code>PostsController#create</code> action.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">PostsController</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">create</span>
    <span class="org-variable-name">@post</span> = <span class="org-variable-name">@blog</span>.new_post(params[<span class="org-constant">:post</span>])
    <span class="org-variable-name">@post</span>.publish
    redirect_to root_path, notice: <span class="org-string">"Post added!"</span>
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The PostsController #create action</div>
</div>


<p>
We can get rid of the demo posts in <code>BlogController</code> now.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">BlogController</span> &lt; <span class="org-type">ApplicationController</span>
  <span class="org-keyword">def</span> <span class="org-function-name">index</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">No more placeholder entries</div>
</div>


</div>

</div>

<div id="outline-container-6_3" class="outline-3">
<h3 id="sec-6_3"><a name="ID-17445728-2450-47ad-b6da-eb2194b503d3" id="ID-17445728-2450-47ad-b6da-eb2194b503d3"></a>Making the Blog object into a Singleton </h3>
<div class="outline-text-3" id="text-6_3">


<p>
There's just one little problem remaining: a new blog object—and
hence a new, blank list of posts!—is created with every request. We
need to make a single blog object last across requests.
</p>
<p>
Our app only supports a single blog at the moment, so we'll just
store an instance to an app-wide <code>Blog</code> object using an initializer.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">config/initializers/blog.rb</span>
<span class="org-type">THE_BLOG</span> = <span class="org-type">Blog</span>.new

</pre>


<div class="caption">Setting up the blog singleton in an initializer</div>
</div>


<p>
Now we change the before filter which sets the <code>@blog</code> variable to use
that constant:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">ApplicationController</span> &lt; <span class="org-type">ActionController</span>::<span class="org-type">Base</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">init_blog</span>
    <span class="org-variable-name">@blog</span> = <span class="org-type">THE_BLOG</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Using the blog singleton object</div>
</div>


<p>
And now we can submit new posts!
</p>


<div class="figure">
  <img src="./images/post-added.png" alt="New post added">
  <div class="caption">New post added</div>
</div>


</div>

</div>

<div id="outline-container-6_4" class="outline-3">
<h3 id="sec-6_4"><a name="ID-4f5368c3-33f8-4172-ac6b-572b6ca0bc22" id="ID-4f5368c3-33f8-4172-ac6b-572b6ca0bc22"></a>Object Trees and Lone Wolves </h3>
<div class="outline-text-3" id="text-6_4">


<p>
   Let's take one last look at our controller action for submitting
   new posts.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">create</span>
  <span class="org-variable-name">@post</span> = <span class="org-variable-name">@blog</span>.new_post(params[<span class="org-constant">:post</span>])
  <span class="org-variable-name">@post</span>.publish
  redirect_to root_path, notice: <span class="org-string">"Post added!"</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The PostsController #create action, again</div>
</div>


<p>
   Notably absent from this action is any direct reference to the
   <code>Post</code> class. We talked about this a little already in <a href="#sec-5-3">Posts vs. Entries</a>. But I want to look at this from one more angle before
   moving on.
</p>
<p>
   Object-oriented programs tend, more often than not, to evolve into
   a roughly tree-shaped structure. This is not surprising, since it
   mimics how we tend to think of the world around us as well as the
   world inside our programs. A website has a blog, a blog has
   categories, categories contain entries, an entry has tags and
   comments, and so on.
</p>
<p>
   It's easy to go nuts with this, of course. When I first learned
   about OOP there was a huge emphasis on using it to break the world
   down into hierarchical ontologies which made for pretty UML
   diagrams. The problem with this view of OOP is that most complex
   systems don't have a single natural hierarchy to them. To use the
   blog example, we could also say a blog has authors, authors have
   entries, and the entries might have categories associated with
   them. This is no more "correct" than the version where categories
   are the concept which "contain" entries.
</p>
<p>
   But the point is that we naturally break our systems into
   hierarchies, which practically speaking means <i>trees of objects</i>.
   In a tree of objects, each object mediates access to its "leaf" or
   "branch" objects. So you might access a blog object from a site
   object, a category from the blog object, and an article from the
   category object.
</p>
<p>
   (I should probably clarify something at this point: I'm talking
   here about "trees" in the sense of "has-many" and "belongs-to", not
   in the sense of "is-a" inheritance trees.)
</p>
<p>
   This pattern has some attractive properties. Having "parent" (I use
   the term loosely) objects mediate access to "child" objects gives
   us a natural "seam" in our design. At the seam, we can do a number
   of things:
</p>
<ol>
<li>Control access based on authorization information—as we saw in
      "<a href="#sec-5-3">*Posts vs. Entries</a>.
</li>
<li>Pre-load child objects with a reference back to their
      parent. The <code>#new_post</code> method above does this, enabling the
      post object to publish itself.
</li>
<li>Save a reference to the child object in the parent.
      ActiveRecord's <a href="http://api.rubyonrails.org/classes/ActiveRecord/AutosaveAssociation.html">autosave</a> facility does this. When we are careful
      to access child objects from the parent, ActiveRecord is able to
      persist all new, modified, or deleted child objects
      automatically when the parent object is saved.
</li>
<li>Decide the actual class of the object to be instantiated, based
      on the parameters or the state of the parent.
</li>
</ol>


<p>
   And the great thing about having the seam is that <i>we don't have to    think about any of those concerns at the beginning</i>. We can add
   them in at the seam point transparently, as the need arises.
</p>
<p>
   Every time we put in an explicit reference to a class, rather than
   creating or accessing the object via its "parent" in the tree, we
   are implicitly rejecting all of these advantages. Sometimes this
   may be what we want. More often, it's a mistake.
</p>
<p>
   Consider these common, seemingly innocuous lines:
</p>
   

<div class="listing">

<pre class="src src-ruby"><span class="org-variable-name">@post</span> = <span class="org-type">Post</span>.new(params[<span class="org-constant">:post</span>])
<span class="org-variable-name">@post</span> = <span class="org-type">Post</span>.create(params[<span class="org-constant">:post</span>])
<span class="org-variable-name">@post</span> = <span class="org-type">Post</span>.find(params[<span class="org-constant">:id</span>])

</pre>


<div class="caption">Lone wolf instantiations</div>
</div>


<p>
   Every one of these creates an object which is a "lone wolf". It's
   an object with no family, no ties to its community. If this object
   was arrested and had a bail hearing, it would be considered a
   flight risk. It is an object which believes it will never be part
   of something bigger than itself. 
</p>
<p>
   It's also an object which makes our tests more painful. How many
   times have you seen test setup that looks like this:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">RSpec</span>
post = stub(<span class="org-constant">:post</span>)
<span class="org-type">Post</span>.stub(<span class="org-constant">:new</span>).and_return(<span class="org-constant">:post</span>)

</pre>




<p>
   Or:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">Mocha</span>
<span class="org-type">Post</span>.any_instance_stubs(<span class="org-constant">:foo</span>)

</pre>




<p>
   These lines just add extra work and noise to tests. Having to stub
   <code>#new</code>, or override a method on every instance of an object, is a
   hamfisted, shotgun-blast approach to testing. And it is usually
   made necessary as a result of of "lone wolf" object creation.
</p>
<p>
   Seams are useful things to have in growing programs. Rejecting them
   has serious implications for extensibility, as well as for security
   and correctness. That's why I regard any bare references to a class
   as a red flag, especially in Rails controller actions. I feel a lot
   more comfortable when I can clearly see the tree structure—trunk
   to limb, limb to branches, branches to twigs, twigs to leaves.
</p>
</div>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7">Getting the tests running again </h2>
<div class="outline-text-2" id="text-7">


<p>
Unfortunately, our changes to the <code>Posts</code> model have broken our tests.
</p>



<pre class="src src-example">$ ruby spec/models/post_spec.rb 
app/models/post.rb:2:in `&lt;class:Post&gt;': 
  uninitialized constant Post::ActiveModel (NameError)
        from app/models/post.rb:1:in `&lt;top (required)&gt;'
        from spec/models/post_spec.rb:2:in `require_relative'
        from spec/models/post_spec.rb:2:in `&lt;main&gt;'

</pre>




<p>
Our nicely isolated tests don't know where to find ActiveModel.
</p>
<p>
We could fix this by requiring ActiveModel somewhere in the test
setup. But we don't actually <i>need</i> ActiveModel for the tests to
pass. And we really like how fast the tests run with so few
dependencies. Is there some way we can continue to keep our models as
lightweight as possible while testing their behavior, and only use
dependencies like ActiveModel when running as part of an application?
Let's find out.
</p>
<p>
Our first crack at this problem might be to simply define empty
versions of the needed modules in the test file, before requiring the
<code>post.rb</code> file.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/models/post_spec.rb</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">module</span> <span class="org-type">ActiveModel</span>
  <span class="org-keyword">module</span> <span class="org-type">Naming</span>; <span class="org-keyword">end</span>
  <span class="org-keyword">module</span> <span class="org-type">Conversion</span>; <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

require_relative <span class="org-string">'../../app/models/post'</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Ghost modules</div>
</div>


<p>
This gets the test passing again. But this approach is
problematic. Let's say we had these tests running as part of a Rake
task which also included full-stack tests. As a result, the task
loaded the full Rails environment. Depending on load order, this file
with its empty definitions of <code>ActiveModel::Naming</code> and
<code>ActiveModel::Conversion</code> might cause ActiveSupport to think that
those modules had already been loaded—and therefore never load the
<i>real</i> versions. This is definitely not what we want.
</p>

</div>

<div id="outline-container-7_1" class="outline-3">
<h3 id="sec-7_1"><a name="ID-479fbf8a-b3df-4bc1-aca4-12a88ef7bd5c" id="ID-479fbf8a-b3df-4bc1-aca4-12a88ef7bd5c"></a>Stubbing out modules </h3>
<div class="outline-text-3" id="text-7_1">


<p>
What we really need is a way to conditionally create empty or "stub"
modules only if a) they are not already defined; and b) they are not
auto-loadable. Here's a method which does just that.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/spec_helper_lite.rb</span>
<span class="org-keyword">def</span> <span class="org-function-name">stub_module</span>(full_name)
  full_name.to_s.split(<span class="org-string">/::/</span>).inject(<span class="org-type">Object</span>) <span class="org-keyword">do</span> |context, name|
    <span class="org-keyword">begin</span>
      context.const_get(name)
    <span class="org-keyword">rescue</span> <span class="org-type">NameError</span>
      context.const_set(name, <span class="org-type">Module</span>.new)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">stub_module</div>
</div>


<p>
This method uses <code>#const_get</code> to attempt to reference the given
module. If the module is defined, or if calling <code>#const_get</code> causes it
to be auto-loaded, the method does nothing more. But if <code>#const_get</code>
fails to turn up the module, it defines an anonymous empty module to
act as a placeholder.
</p>
<p>
Here it is being used to stub out modules in our <code>Post</code> spec:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
require_relative <span class="org-string">'../spec_helper_lite'</span>
stub_module <span class="org-string">'ActiveModel::Conversion'</span>
stub_module <span class="org-string">'ActiveModel::Naming'</span>
require_relative <span class="org-string">'../../app/models/post'</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Using stub_module</div>
</div>


<p>
The tests are once again passing:
</p>



<pre class="example">$ ruby spec/models/post_spec.rb                            
Loaded suite spec/models/post_spec
Started
......
Finished in 0.000530 seconds.
6 tests, 7 assertions, 0 failures, 0 errors, 0 skips
</pre>




</div>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8">Adding timestamps </h2>
<div class="outline-text-2" id="text-8">


<p>
Two features that are pretty much required for a blog are 1)
time-stamped posts; and 2) listing posts in reverse-chronological
order. So far our blog supports neither of these. Time to fix that.
</p>
<p>
Once again, we'll take an outside-in approach and first find a place
in the views to display the (as-yet nonexistent) timestamp.
</p>


<div class="listing">

<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/blog/_entry.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">article</span>&gt;
  &lt;<span class="org-function-name">header</span>&gt;
    &lt;<span class="org-function-name">p</span>&gt;&lt;<span class="org-function-name">time</span> <span class="org-variable-name">pubdate</span>=<span class="org-string">"pubdate"</span>&gt;&lt;%= entry.pubdate %&gt;&lt;/<span class="org-function-name">time</span>&gt;&lt;/<span class="org-function-name">p</span>&gt;
    &lt;<span class="org-function-name">h3</span>&gt;&lt;%= entry.title %&gt;&lt;/<span class="org-function-name">h3</span>&gt;
  &lt;/<span class="org-function-name">header</span>&gt;
  &lt;<span class="org-function-name">p</span>&gt;&lt;%= entry.body %&gt;&lt;/<span class="org-function-name">p</span>&gt;
&lt;/<span class="org-function-name">article</span>&gt;

</pre>


<div class="caption">Adding timestamps to the view</div>
</div>


<p>
An entry's publishing timestamp should start out blank and then be
filled in once it is published. Let's spec that out.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
describe <span class="org-string">"#pubdate"</span> <span class="org-keyword">do</span>
  describe <span class="org-string">"before publishing"</span> <span class="org-keyword">do</span>
    it <span class="org-string">"is blank"</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span>.pubdate.must_be_nil
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  describe <span class="org-string">"after publishing"</span> <span class="org-keyword">do</span>
    before <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span>.blog = stub!
      <span class="org-variable-name">@it</span>.publish
    <span class="org-keyword">end</span>
    it <span class="org-string">"is a datetime"</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span>.pubdate.class.must_equal(<span class="org-type">DateTime</span>)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Specifying publishing timestamps</div>
</div>


<p>
Note the use of <code>stub!</code>. MiniTest's built-in mocking
was becoming insufficient for our needs, so we've supplemented it with
<a href="https://github.com/btakita/rr">rr</a>, a succinct but powerful test double library. Here's the setup for that:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/spec_helper_lite.rb</span>
require <span class="org-string">'rr'</span>

<span class="org-keyword">class</span> <span class="org-type">MiniTest</span>::<span class="org-type">Unit</span>::<span class="org-type">TestCase</span>
  include <span class="org-type">RR</span>::<span class="org-type">Adapters</span>::<span class="org-type">MiniTest</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">rr setup</div>
</div>


<p>
We also need to add <code>rr</code> to our Gemfile:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">Gemfile</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
group <span class="org-constant">:development</span>, <span class="org-constant">:test</span> <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  gem <span class="org-string">'rr'</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">rr in the Gemfile</div>
</div>


<p>
Implementing <code>#pubdate</code> is just a matter of adding a new attribute
accessor:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span>
  attr_accessor <span class="org-constant">:blog</span>, <span class="org-constant">:title</span>, <span class="org-constant">:body</span>, <span class="org-constant">:pubdate</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Adding Post#pubdate</div>
</div>


<p>
The timestamp isn't much help if it doesn't use the current
time. Let's add a spec asserting that it does.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
describe <span class="org-string">"#pubdate"</span> <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  describe <span class="org-string">"after publishing"</span> <span class="org-keyword">do</span>
    before <span class="org-keyword">do</span>
      <span class="org-variable-name">@clock</span> = stub!
      <span class="org-variable-name">@now</span> = <span class="org-type">DateTime</span>.parse(<span class="org-string">"2011-09-11T02:56"</span>)
      stub(<span class="org-variable-name">@clock</span>).now(){<span class="org-variable-name">@now</span>}
      <span class="org-variable-name">@it</span>.blog = stub!
      <span class="org-variable-name">@it</span>.publish(<span class="org-variable-name">@clock</span>)
    <span class="org-keyword">end</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

    it <span class="org-string">"is the current time"</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span>.pubdate.must_equal(<span class="org-variable-name">@now</span>)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Specifying timestamp correctness</div>
</div>


<p>
That's a lot of test setup; any more and we'd want to find a way to
refactor the tests.
</p>
<p>
Now, besides creating a stubbed <code>blog</code> instance, we're also creating a
<code>@clock</code> stub. We create a fixed <code>@now</code> time for the clock to respond
with when <code>#now</code> is called on it. Then we pass the clock into the
<code>Post#publish</code> method and assert that it uses the <code>@now</code> time to set
its <code>#pubdate</code> attribute.
</p>

</div>

<div id="outline-container-8_1" class="outline-3">
<h3 id="sec-8_1"><a name="ID-cb3b155f-33cb-44da-9ee8-32d3a50cb24a" id="ID-cb3b155f-33cb-44da-9ee8-32d3a50cb24a"></a>Sensible defaults for injected dependencies </h3>
<div class="outline-text-3" id="text-8_1">


<p>
Wait a second… does this mean the app will always have to pass a
clock object in to <code>Post#publish</code> now? Won't this break our other
tests where we pass nothing to <code>#publish</code>?
</p>
<p>
Sensible defaults to the rescue! Let's update the
<code>Post#publish</code> method to make this test pass:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">publish</span>(clock=<span class="org-type">DateTime</span>)
  <span class="org-variable-name">self</span>.pubdate = clock.now
  blog.add_entry(<span class="org-variable-name">self</span>)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">A default clock</div>
</div>


<p>
We add a <code>clock</code> parameter, and make it default to <code>DateTime</code>. That
way in the absence of any parameter, the method will just take its
timestamp from the system clock via <code>DateTime</code>.
</p>
<p>
Why make it possible to pass the clock in? We might turn the question
around: our tests up until now have been very careful to isolate our
System Under Test (SUT) from any external dependencies, why make an
exception for the system clock? By making it possible to pass a clock
object in, we make it very easy to test the behavior of <code>#publish</code>
deterministically, without resorting to heavy-handed clock-overriding
libraries such as <a href="https://github.com/jtrupiano/timecop">Timecop</a>. To quote <i>Growing Object Oriented Software, Guided by Tests</i>:
</p>
<blockquote>

<p>we've seen so many systems that are impossible to test because the
developers did not isolate the concept of time.
</p>
</blockquote>


<p>
But there are other advantages to passing the clock in, which we'll
discuss in the next section.
</p>
</div>
</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9"><a name="ID-9aeb139e-ddb0-4216-a374-3222dcba460c" id="ID-9aeb139e-ddb0-4216-a374-3222dcba460c"></a>OMG Dependency Injection! </h2>
<div class="outline-text-2" id="text-9">


<p>
In constructing carefully isolated tests, we have now used dependency
injection twice. First, we used <i>setter injection</i> to strategize how
<code>Blog</code> objects create new entries:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Blog</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  attr_writer <span class="org-constant">:post_source</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  private
  <span class="org-keyword">def</span> <span class="org-function-name">post_source</span>
    <span class="org-variable-name">@post_source</span> ||= <span class="org-type">Post</span>.public_method(<span class="org-constant">:new</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Setter injection</div>
</div>


<p>
And then moments ago we used <i>parameter injection</i> to pass in a clock
object to <code>Post#publish</code>:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">publish</span>(clock=<span class="org-type">DateTime</span>)
  <span class="org-variable-name">self</span>.pubdate = clock.now
  blog.add_entry(<span class="org-variable-name">self</span>)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Parameter injection</div>
</div>


<p>
There is a lot of bad press around the <a href="http://martinfowler.com/articles/injection.html">Dependency Injection pattern</a>
these days. Most of it probably stems from the experiences people have
had with heavyweight DI frameworks in Java and C#. As you can see,
though, at its core Dependency Injection is just about making it
possible to pass an object's collaborators in from the outside. As
we've just seen, Ruby makes it very easy to make dependencies
inject-able while still having sensible built-in defaults for those
dependencies.
</p>
<p>
Is all this care taken to make dependencies inject-able solely in order
to satisfy our need for isolated tests? Well, certainly that's what
drives us to provide for DI in the first place. But what's interesting
about this discipline of strict isolation is the type of object design
it pushes us towards.
</p>
<p>
Let's say we wanted to add the ability to post-date or pre-date some
posts. Currently, <code>Post</code> sets its <code>pubdate</code> at publish time, so we
can't just set the date when we create the post. Of course, we could
add some new behavior to <code>Post</code> to implement custom <code>pubdate</code> setting;
but because we've made the clock inject-able, we can implement custom
publish dates without making any changes at all to <code>Post</code>:
</p>


<div class="listing">

<pre class="src src-ruby">fixed_clock = <span class="org-type">OpenStruct</span>.new(now: <span class="org-type">DateTime</span>.parse(params[<span class="org-constant">:pubdate</span>]))
<span class="org-variable-name">@post</span>.publish(fixed_clock)

</pre>


<div class="caption">A fixed clock</div>
</div>


<p>
Here, we've just used <code>OpenStruct</code> to create a quick ad-hoc object
which responds to the <code>#now</code> method with a fixed date.
</p>
<p>
We could get as fancy as we wanted with custom clocks. We could
implement a delay so that posts have a review period before going
live:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">DelayClock</span>
  <span class="org-keyword">def</span> <span class="org-function-name">now</span>
    <span class="org-type">DateTime</span>.now + 24.hours
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-variable-name">@post</span>.publish(<span class="org-type">DelayClock</span>.new)

</pre>


<div class="caption">A delayed clock</div>
</div>


<p>
All without making any changes to the <code>Post</code> class.
</p>
<p>
According to the <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a> (SRP), a class should
have one, and only one, reason to change. A corollary of this
principle is that when a new requirement requires changes to more than
one class or module, at least one of them probably has too many
responsibilities.
</p>
<p>
Consider that if we had not made the clock an inject-able dependency,
implementing post-dating and pre-dating would have meant changing the
code in (at least) two places: once in the controller, and once in the
<code>Post</code> model. By contrast, in our current design we are able to
implement the feature by changing the code in only one place.
</p>
<p>
Our tests influenced us to factor out the responsibility for
determining a post's timestamp into a discrete object. By letting our
discipline of test isolation drive our design, we arrived at a system
that respects SRP without even really thinking about it.
</p>
</div>

<div id="outline-container-9_1" class="outline-3">
<h3 id="sec-9_1"><a name="ID-f30ba520-fb59-4d77-b30e-4e862cdb37fe" id="ID-f30ba520-fb59-4d77-b30e-4e862cdb37fe"></a>Injecting only the dependencies we need </h3>
<div class="outline-text-3" id="text-9_1">

<p>   You might have wondered why we inject a callable <code>@post_source</code>
   instead of simply having a <code>@post_class</code> variable which defaults to
   <code>Post</code>.
</p>
<p>
   For one thing, it makes our test setup easier. If we injected a
   "post class" mock, we'd have to do one of two things:
</p>
<ol>
<li>Stub <code>.new</code> on the real <code>Post</code> class, which would override the
      method globally and potentially interfere with any test code
      which also calls <code>Post.new</code>.
</li>
<li>Create a <code>@post_class</code> stub <i>and</i> a <code>@post</code> stub, and stub the
      former to return the latter.
</li>
</ol>


<p>
   By contrast, all we need to do to stub the callable version is
   this:
</p>



<pre class="src src-ruby">blog.post_source = -&gt;{ new_post }

</pre>




<p>
   As usual with mocks and stubs however, the ease of passing in a
   callable over injecting a <code>.new</code> method is pointing out a deeper
   design decision. When we say that <code>Blog</code> calls <code>Post.new</code>, we are
   implying that <code>Blog</code> has <code>Post</code> as a collaborator, and may
   potentially call <i>any</i> method on <code>Post</code>. The destinies of these two
   classes are now entwined.
</p>
<p>
   By saying, instead, that <code>Blog#new_post</code> depends only on "some
   callable which will return a post when called", we are explicitly
   holding off from binding <code>Blog</code> to the <code>Post</code> class interface. We
   are choosing to make the minimum necessary connection between the
   two classes. If, down the road, we add a call to another
   <code>Post</code> class method, say, <code>Post.find</code>, our isolated tests will
   flag it and remind us to make a conscious choice about adding the
   new dependency.
</p>
<p>
   Oh by the way, that <code>post_source</code>? It's a factory, as in "the
   Factory pattern". I didn't want to scare you off with big pattern
   talk, so I snuck it in under an assumed name ;-)
</p></div>
</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10">Sorting and limiting posts </h2>
<div class="outline-text-2" id="text-10">


<p>
OK, now we have timestamps on the posts. On a proper blog, posts are
listed in reverse-chronological order, with the most recent post at the
top. Let's implement sorting by timestamp, and while we're at it,
let's limit the display to the ten most recent posts.
</p>
<p>
Spec:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/models/blog_spec.rb</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
describe <span class="org-string">"#entries"</span> <span class="org-keyword">do</span>
  <span class="org-keyword">def</span> <span class="org-function-name">stub_entry_with_date</span>(date)
    <span class="org-type">OpenStruct</span>.new(pubdate: <span class="org-type">DateTime</span>.parse(date))
  <span class="org-keyword">end</span>
  it <span class="org-string">"is sorted in reverse-chronological order"</span> <span class="org-keyword">do</span>
    oldest = stub_entry_with_date(<span class="org-string">"2011-09-09"</span>)
    newest = stub_entry_with_date(<span class="org-string">"2011-09-11"</span>)
    middle = stub_entry_with_date(<span class="org-string">"2011-09-10"</span>)
    <span class="org-variable-name">@it</span>.add_entry(oldest)
    <span class="org-variable-name">@it</span>.add_entry(newest)
    <span class="org-variable-name">@it</span>.add_entry(middle)
    <span class="org-variable-name">@it</span>.entries.must_equal([newest, middle, oldest])
  <span class="org-keyword">end</span>
  it <span class="org-string">"is limited to 10 items"</span> <span class="org-keyword">do</span>
    10.times <span class="org-keyword">do</span> |i|
      <span class="org-variable-name">@it</span>.add_entry(stub_entry_with_date(<span class="org-string">"2011-09-</span><span class="org-variable-name">#{i+1}</span><span class="org-string">"</span>))
    <span class="org-keyword">end</span>
    oldest = stub_entry_with_date(<span class="org-string">"2011-08-30"</span>)
    <span class="org-variable-name">@it</span>.add_entry(oldest)
    <span class="org-variable-name">@it</span>.entries.size.must_equal(10)
    <span class="org-variable-name">@it</span>.entries.wont_include(oldest)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Specifying entry limiting and ordering</div>
</div>


<p>
To implement this, we remove the <code>entries</code> attribute reader we created
earlier, and substitute a "real" method:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/models/blog.rb</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">entries</span>
  <span class="org-variable-name">@entries</span>.sort_by{|e| e.pubdate}.reverse.take(10)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Sorting and limiting entries</div>
</div>


<p>
We also have to change the <code>#add_entry</code> method to reference the
<code>@entries</code> collection directly, now that <code>#entries</code> returns a modified
copy:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">add_entry</span>(entry)
  <span class="org-variable-name">@entries</span> &lt;&lt; entry
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>




<p>
With that, our blog is starting to behave more like the real thing:
</p>


<div class="figure">
  <img src="./images/sorted-entries.png" alt="Sorted entries">
  <div class="caption">Sorted entries</div>
</div>


<p>
Running the tests again, we find that one of them has broken because
of a missing <code>#pubdate</code> method on the plain <code>Object.new</code> we used as a
stand-in for a blog entry. Changing it to an <code>rr</code> <code>stub</code> object is
sufficient to make the test pass again.
</p>


<div class="listing">

<pre class="src src-ruby">describe <span class="org-type">Blog</span> <span class="org-keyword">do</span>
  describe <span class="org-string">"#add_entry"</span> <span class="org-keyword">do</span>
    it <span class="org-string">"adds the entry to the blog"</span> <span class="org-keyword">do</span>
      entry = stub!
      <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Stubbing with rr</div>
</div>


</div>

</div>

<div id="outline-container-11" class="outline-2">
<h2 id="sec-11"><a name="ID-3ab4efe2-3f1a-47fc-b5c7-79e22e404d30" id="ID-3ab4efe2-3f1a-47fc-b5c7-79e22e404d30"></a>Adding validation </h2>
<div class="outline-text-2" id="text-11">


<p>
Blog posts, at the very least, should have a title. Let's add a
validation to enforce this constraint.
</p>
<p>
Here's the specification:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
it <span class="org-string">"is not valid with a blank title"</span> <span class="org-keyword">do</span>
  [<span class="org-variable-name">nil</span>, <span class="org-string">""</span>, <span class="org-string">" "</span>].each <span class="org-keyword">do</span> |bad_title|
    <span class="org-variable-name">@it</span>.title = bad_title
    refute <span class="org-variable-name">@it</span>.valid?
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

it <span class="org-string">"is valid with a non-blank title"</span> <span class="org-keyword">do</span>
  <span class="org-variable-name">@it</span>.title = <span class="org-string">"x"</span>
  assert <span class="org-variable-name">@it</span>.valid?
<span class="org-keyword">end</span> 
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Specifying entry title validation</div>
</div>


<p>
We could manually implement a <code>#valid?</code> method here. But we know that
Rails needs more than just a <code>#valid?</code> method in order to present
validation failures in a user-friendly way. And besides, why write
that method when it's a one-liner using ActiveModel?
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  include <span class="org-type">ActiveModel</span>::<span class="org-type">Validations</span>
  validates <span class="org-constant">:title</span>, presence: <span class="org-variable-name">true</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Implementing entry title validation with ActiveModel</div>
</div>


<p>
Now that we're using ActiveModel to satisfy our own expectations as
well as Rails' expectations, we can no longer stub out the ActiveModel
modules when running in isolation. We must use the real thing.
</p>
<p>
These lines will have to go:
</p>



<pre class="src src-ruby">stub_module <span class="org-string">'ActiveModel::Conversion'</span>
stub_module <span class="org-string">'ActiveModel::Naming'</span>

</pre>




<p>
And we have to add a requirement for ActiveModel to the model file:
</p>



<pre class="src src-ruby">require <span class="org-string">'active_model'</span>

</pre>




<p>
When running in the full app, this won't be necessary. But we need it
in order to continue running our tests outside of the Rails
environment. By explicitly requiring ActiveModel only in files which
need it, we don't saddle unrelated tests with the extra load time.
</p>
<p>
While we're adding validation to the <code>Post</code> class, let's also modify
the contract of <code>#publish</code> to only add posts to <code>Blog</code> when the post
is valid, and to return <code>false</code> when validation fails.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
describe <span class="org-string">"#publish"</span> <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  describe <span class="org-string">"given an invalid post"</span> <span class="org-keyword">do</span>
    before <span class="org-keyword">do</span> <span class="org-variable-name">@it</span>.title = <span class="org-variable-name">nil</span> <span class="org-keyword">end</span>

    it <span class="org-string">"wont add the post to the blog"</span> <span class="org-keyword">do</span>
      dont_allow(<span class="org-variable-name">@blog</span>).add_entry
      <span class="org-variable-name">@it</span>.publish
    <span class="org-keyword">end</span>

    it <span class="org-string">"returns false"</span> <span class="org-keyword">do</span>
      refute(<span class="org-variable-name">@it</span>.publish)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Specifying publishing guards</div>
</div>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">publish</span>(clock=<span class="org-type">DateTime</span>)
  <span class="org-keyword">return</span> <span class="org-variable-name">false</span> <span class="org-keyword">unless</span> valid?
  <span class="org-variable-name">self</span>.pubdate = clock.now
  <span class="org-variable-name">@blog</span>.add_entry(<span class="org-variable-name">self</span>)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Implementing publishing guards</div>
</div>


<p>
With these changes in place, we can update the <code>PostsController</code> to
handle validation failures:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">create</span>
  <span class="org-variable-name">@post</span> = <span class="org-variable-name">@blog</span>.new_post(params[<span class="org-constant">:post</span>])
  <span class="org-keyword">if</span> <span class="org-variable-name">@post</span>.publish
    redirect_to root_path, notice: <span class="org-string">"Post added!"</span>
  <span class="org-keyword">else</span>
    render <span class="org-string">"new"</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Making the PostsController validation-aware</div>
</div>


<p>
With that change and some tweaks to the view (not shown), we now get
an error message when we try to submit a blog post with no title.
</p>


<div class="figure">
  <img src="./images/validation-error.png" alt="Validation error message">
  <div class="caption">Validation error message</div>
</div>


</div>

</div>

<div id="outline-container-12" class="outline-2">
<h2 id="sec-12"><a name="ID-2656c30c-080a-4a4e-a53e-4fbaad39c262" id="ID-2656c30c-080a-4a4e-a53e-4fbaad39c262"></a>Introducing the Exhibit Pattern </h2>
<div class="outline-text-2" id="text-12">


<p>
No blog is complete without the ability to post funny cat
pictures. We'd like to add the ability to attach a picture URL to
posts. In addition, we want to present posts differently if they have
a picture URL. The "body" text will become the picture caption.
</p>
<p>
As before, we'll start at the view level and work inward. We'll add a
picture URL field to the new post form:
</p>


<div class="listing">

<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/posts/new.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;%= form_for @post do |f| %&gt;
  # ...
  &lt;%= label :image_url, <span class="org-string">"Picture URL:"</span> %&gt;
  &lt;%= f.text_field :image_url %&gt;
  # ...
&lt;% end %&gt;

</pre>


<div class="caption">Adding a picture URL</div>
</div>


<p>
And we'll create partials for both displaying text-only entries and
for displaying picture entries. Here's the one for picture entries:
</p>


<div class="listing">

<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/posts/_picture_body.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">figure</span>&gt;
  &lt;<span class="org-function-name">img</span> <span class="org-variable-name">src</span>=<span class="org-string">"&lt;%= post.image_url %&gt;"</span>/&gt;
  &lt;<span class="org-function-name">figcaption</span>&gt;&lt;%= post.body %&gt;&lt;/<span class="org-function-name">figcaption</span>&gt;
&lt;<span class="org-function-name">figure</span>/&gt;

</pre>


<div class="caption">A partial for picture entries</div>
</div>


<p>
We're using the HTML5 <code>&lt;figure&gt;</code> and <code>&lt;figcaption&gt;</code> tags to mark
up a picture semantically.
</p>
<p>
We also go ahead and add an <code>image_url</code> attribute to the <code>Post</code> model.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
attr_accessor <span class="org-constant">:blog</span>, <span class="org-constant">:title</span>, <span class="org-constant">:body</span>, <span class="org-constant">:image_url</span>, <span class="org-constant">:pubdate</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Adding an image URL to the Post model</div>
</div>


<p>
Now the question is how to ensure that the correct partial is rendered
based on the type of post. Initially, we might think to do something
like this:
</p>


<div class="listing">

<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/blog/_entry.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
<span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
&lt;% if entry.image_url.present? %&gt;
  &lt;%= render <span class="org-string">"/posts/picture_body"</span>, post: entry %&gt;
&lt;% else %&gt;
  &lt;%= render <span class="org-string">"posts/text_body"</span>, post: entry %&gt;
&lt;% end %&gt;
<span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>

</pre>


<div class="caption">Conditional logic in the view</div>
</div>


<p>
But this raises some warning flags. Logic in views is almost
always bad news, even logic as simple as this. Speaking from my own
experience, a lot of the technical debt I've seen in Rails projects
has been in convoluted view code. If possible, it would be nice to
avoid going down that road so early in the project.
</p>
<p>
And anyway, from an Object-Oriented Design perspective this just feels
<i>wrong</i>. Remember those beginning OO examples, where you send a "draw"
message to a "shape" object, and if it's a Circle it will draw a
circle, and if it's a square it will draw a square? What's the point
of using an OO language if we can't use polymorphism, and instead fall
back on conditionals everywhere?
</p>
<p>
What we'd like to be able to write in our view template code is
something like this:
</p>


<div class="listing">

<pre class="src src-html">&lt;% entry = exhibit(entry, self) %&gt;
&lt;<span class="org-function-name">article</span>&gt;
  <span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
  &lt;%= entry.render_body %&gt;
&lt;/<span class="org-function-name">article</span>&gt;

</pre>


<div class="caption">The view code we'd like to write</div>
</div>


<p>
Conceptually, what we have are two post types: a "picture post", and a
"text post". The core of OO philosophy is representing discrete
concepts as objects. So let's take these two concepts and represent
them as objects.
</p>
<p>
But what kind of objects? The models in an MVC application are
supposed to be presentation-agnostic—they shouldn't know anything
about how to display themselves. And we know we don't want to put
business logic into the views. It seems like we need a third kind
of object between a Model and a View.
</p>

</div>

<div id="outline-container-12_1" class="outline-3">
<h3 id="sec-12_1">Exhibit A </h3>
<div class="outline-text-3" id="text-12_1">


<p>
To satisfy our need for an object which mates a model and a view,
we'll use what I've taken to calling an <i>Exhibit</i> object. If the Model
is concerned with storing and manipulating business data, and the View
is concerned with displaying it, you can think of the Exhibit as
standing between them deciding <i>which</i> data to show, and in what
order. It may also provide some extra presentation-specific
information (such as the specific URLs for related resources) which
the business model has no knowledge of by itself.
</p>
<p>
The Exhibit object is so named because it is like a museum display
case for an artifact or a work of art. It does not obscure any of the
features of the object being presented. Rather, it tries showcase the
object in the best light to a human audience, while also presenting
meta-information about the object and cross-references to other
objects in the museum's collection.
</p>
<p>
Technically, exhibit objects are a type of <a href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</a> specialized for
presenting models to an end user. In fact, I briefly considered
calling them "Presenter Decorators", but that term is a bit unwieldy,
as well as being a little too easy to confuse with other "Presenter"
terms (on which more later).
</p>
<p>
We write a spec for the exhibit we need:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/exhibits/picture_post_exhibit_spec.rb</span>
require_relative <span class="org-string">'../spec_helper_lite'</span>
require_relative <span class="org-string">'../../app/exhibits/picture_post_exhibit'</span>

describe <span class="org-type">PicturePostExhibit</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span>
    <span class="org-variable-name">@post</span> = <span class="org-type">OpenStruct</span>.new(
      title:   <span class="org-string">"TITLE"</span>, 
      body:    <span class="org-string">"BODY"</span>, 
      pubdate: <span class="org-string">"PUBDATE"</span>)
    <span class="org-variable-name">@context</span> = stub!
    <span class="org-variable-name">@it</span> = <span class="org-type">PicturePostExhibit</span>.new(<span class="org-variable-name">@post</span>, <span class="org-variable-name">@context</span>)
  <span class="org-keyword">end</span>

  it <span class="org-string">"delegates method calls to the post"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.title.must_equal <span class="org-string">"TITLE"</span>
    <span class="org-variable-name">@it</span>.body.must_equal <span class="org-string">"BODY"</span>
    <span class="org-variable-name">@it</span>.pubdate.must_equal <span class="org-string">"PUBDATE"</span>
  <span class="org-keyword">end</span>

  it <span class="org-string">"renders itself with the appropriate partial"</span> <span class="org-keyword">do</span>
    mock(<span class="org-variable-name">@context</span>).render(
      partial: <span class="org-string">"/posts/picture_body"</span>, locals: {post: <span class="org-variable-name">@it</span>}){
      <span class="org-string">"THE_HTML"</span>
    }
    <span class="org-variable-name">@it</span>.render_body.must_equal <span class="org-string">"THE_HTML"</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Specifying an Exhibit for a picture post</div>
</div>


<p>
We define stubs for both a "post" object, and a "context" object. The
<code>@post</code> stub stands in for a <code>Post</code> instance. The <code>@context</code> object
stands in for the Rails template object which is the context that all
views are rendered in. When you call helpers like <code>#render</code> or
<code>#form_for</code> in a Rails view, you're calling them on the template
object.
</p>
<p>
Then we specify that the exhibit must 1) act as a "pass-through"
object, forwarding any methods it doesn't know about on to the model
object; and 2) that it must know how to use the context to render an
appropriate post body partial. The pass-through property satisfies the
"transparency" requirement of the Decorator pattern, of which Exhibit
is a subset.
</p>
<p>
Next we write an implementation which satisfies this spec.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/exhibits/picture_post_exhibit.rb</span>
require <span class="org-string">'delegate'</span>
<span class="org-keyword">class</span> <span class="org-type">PicturePostExhibit</span> &lt; <span class="org-type">SimpleDelegator</span>
  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(model, context)
    <span class="org-variable-name">@context</span> = context
    <span class="org-keyword">super</span>(model)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">render_body</span>
    <span class="org-variable-name">@context</span>.render(partial: <span class="org-string">"/posts/picture_body"</span>, locals: {post: <span class="org-variable-name">self</span>})
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Implementing the picture post Exhibit</div>
</div>


<p>
We've defined a new directory, <code>app/exhibits</code>, for Exhibit
objects. In it, we've created a <code>PicturePostExhibit</code> class.
</p>
<p>
This class inherits from <code>SimpleDelegator</code>. <code>SimpleDelegator</code> is Ruby
standard library class which has a very simple job: forward all calls
to an underlying object. Not very useful in and of itself; but as a
basis for defining <a href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</a> objects it is quite handy. 
</p>
<p>
In the exhibit initializer, we save the view context in an instance
variable. Then we call the <code>SimpleDelegator</code> initializer with <code>super</code>,
to set up delegation to the model object.
</p>
<p>
In the <code>#render_body</code> method, we use the saved <code>@context</code> to render a
partial for a picture-type post.
</p>
<p>
The exhibit for text-only posts is nearly identical. Because it's so
similar, I'll omit the spec for it and just show the implementation:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">exhibits/text_post_exhibit.rb</span>
require <span class="org-string">'delegate'</span>
<span class="org-keyword">class</span> <span class="org-type">TextPostExhibit</span> &lt; <span class="org-type">SimpleDelegator</span>
  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(model, context)
    <span class="org-variable-name">@context</span> = context
    <span class="org-keyword">super</span>(model)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">render_body</span>
    <span class="org-variable-name">@context</span>.render(partial: <span class="org-string">"/posts/text_body"</span>, locals: {post: <span class="org-variable-name">self</span>})
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">An Exhibit for text posts</div>
</div>


<p>
The only difference here is a different partial being rendered.
</p>
<p>
Now we need an easy way to wrap a model object in the appropriate
exhibits (if any). Let's spec out a helper to do that:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/helpers/exhibits_helper_spec.rb</span>
require_relative <span class="org-string">'../spec_helper_lite'</span>
require_relative <span class="org-string">'../../app/helpers/exhibits_helper'</span>

stub_class <span class="org-string">'PicturePostExhibit'</span>
stub_class <span class="org-string">'TextPostExhibit'</span>
stub_class <span class="org-string">'Post'</span>

describe <span class="org-type">ExhibitsHelper</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span> = <span class="org-type">Object</span>.new
    <span class="org-variable-name">@it</span>.extend <span class="org-type">ExhibitsHelper</span>
    <span class="org-variable-name">@context</span> = stub!
  <span class="org-keyword">end</span>

  it <span class="org-string">"decorates picture posts with a PicturePostExhibit"</span> <span class="org-keyword">do</span>
    post = <span class="org-type">Post</span>.new
    stub(post).picture?{<span class="org-variable-name">true</span>}
    <span class="org-variable-name">@it</span>.exhibit(post, <span class="org-variable-name">@context</span>).must_be_kind_of(<span class="org-type">PicturePostExhibit</span>)
  <span class="org-keyword">end</span>

  it <span class="org-string">"decorates text posts with a TextPostExhibit"</span> <span class="org-keyword">do</span>
    post = <span class="org-type">Post</span>.new
    stub(post).picture?{<span class="org-variable-name">false</span>}
    <span class="org-variable-name">@it</span>.exhibit(post, <span class="org-variable-name">@context</span>).must_be_kind_of(<span class="org-type">TextPostExhibit</span>)
  <span class="org-keyword">end</span>

  it <span class="org-string">"leaves objects it doesn't know about alone"</span> <span class="org-keyword">do</span>
    model = <span class="org-type">Object</span>.new
    <span class="org-variable-name">@it</span>.exhibit(model, <span class="org-variable-name">@context</span>).must_be_same_as(model)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Specifying the exhibit helper</div>
</div>


<p>
By its nature, <code>ExhibitsHelper</code> is a piece of code which will have to
reference a lot of different classes, both model classes and exhibit
classes. In order to avoid having test dependencies on all those class
definitions, we define and use a <code>#stub_class</code> test helper which is
almost identical in definition to the <code>#stub_module</code> method we wrote
before.
</p>
<p>
Here's helper code which satisfies the spec:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/helpers/exhibits_helper.rb</span>
<span class="org-keyword">module</span> <span class="org-type">ExhibitsHelper</span>
  <span class="org-keyword">def</span> <span class="org-function-name">exhibit</span>(model, context)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Doing a string comparison because of Rails class-reloading weirdness</span>
    <span class="org-keyword">case</span> model.class.name
    <span class="org-keyword">when</span> <span class="org-string">'Post'</span>
      <span class="org-keyword">if</span> model.picture?
        <span class="org-type">PicturePostExhibit</span>.new(model, context)
      <span class="org-keyword">else</span>
        <span class="org-type">TextPostExhibit</span>.new(model, context)
      <span class="org-keyword">end</span>
    <span class="org-keyword">else</span>
      model
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Implementing the exhibit helper</div>
</div>


<p>
<i>Hey, I thought we were getting *rid* of conditionals! That's just a giant mass of conditionals!</i> This is true. Unfortunately, it's not
always possible to completely eliminate type-based conditionals. What
we <i>can</i> do is isolate the conditionals to a single place, rather than
scattering them all over our view code. That's exactly what we're
trying to do here. Anywhere we might have done an <code>if...then...else</code>
in a view template based on an object's class or traits, we can
instead add an exhibit to handle the conditional behavior
polymorphically. All the conditionals are consolidated on this one
helper method, which decides <i>which</i> exhibit(s) to apply to a given
object.
</p>
<p>
The helper code above uses a <code>#picture?</code> predicate method on <code>Post</code>
objects. Let's quickly implement that.
</p>
<p>
Spec:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
describe <span class="org-string">"#picture?"</span> <span class="org-keyword">do</span>
  it <span class="org-string">"is true when the post has a picture URL"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.image_url = <span class="org-string">"http://example.org/foo.png"</span>
    assert(<span class="org-variable-name">@it</span>.picture?)
  <span class="org-keyword">end</span>
  it <span class="org-string">"is false when the post has no picture URL"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.image_url = <span class="org-string">""</span>
    refute(<span class="org-variable-name">@it</span>.picture?)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Spec for a #picture? predicate</div>
</div>


<p>
Implementation:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">picture?</span>
  image_url.present?
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">The #picture? predicate</div>
</div>



<p>
Because we'll probably be using the <code>#exhibit</code> helper method all over
the place in the future, we'll put it in our <code>ApplicationController</code>:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">ApplicationController</span> &lt; <span class="org-type">ActionController</span>::<span class="org-type">Base</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  helper <span class="org-constant">:exhibits</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Adding the exhibits helper to the ApplicationController</div>
</div>


<p>
Now, with our tiny homegrown exhibit framework in place, we rewrite
the blog entry partial.
</p>


<div class="listing">

<pre class="src src-html">&lt;% entry = exhibit(entry, self) %&gt;
&lt;<span class="org-function-name">article</span>&gt;
  &lt;<span class="org-function-name">header</span>&gt;
    &lt;<span class="org-function-name">p</span>&gt;&lt;<span class="org-function-name">time</span> <span class="org-variable-name">pubdate</span>=<span class="org-string">"pubdate"</span>&gt;&lt;%= entry.pubdate %&gt;&lt;/<span class="org-function-name">time</span>&gt;&lt;/<span class="org-function-name">p</span>&gt;
    &lt;<span class="org-function-name">h3</span>&gt;&lt;%= entry.title %&gt;&lt;/<span class="org-function-name">h3</span>&gt;
  &lt;/<span class="org-function-name">header</span>&gt;
  &lt;%= entry.render_body %&gt;
&lt;/<span class="org-function-name">article</span>&gt;

</pre>


<div class="caption">Using the entry exhibit in a view</div>
</div>


<p>
No more conditionals in the view! Just a simple method call to
<code>#render_body</code> which Does The Right Thing.
</p>
<p>
Here's how it looks when we post a picture: 
</p>


<div class="figure">
  <img src="./images/wet-paint.png" alt="Posting a picture">
  <div class="caption">Posting a picture</div>
</div>


</div>

</div>

<div id="outline-container-12_2" class="outline-3">
<h3 id="sec-12_2"><a name="ID-1deb38e0-7e25-4a04-a930-9b71e6a3307c" id="ID-1deb38e0-7e25-4a04-a930-9b71e6a3307c"></a>What about Presenters? </h3>
<div class="outline-text-3" id="text-12_2">

<p>   Now, if you follow trends in the Rails community at all, right
   about now you're probably exclaiming "hang on, aren't you talking
   about Presenters?".
</p>
<p>
   The truth is, in the first few drafts this whole section was about
   Presenters. Then I started researching the history of the Presenter
   concept in Ruby and Rails. And the more I read, the less certain I
   became about my terminology.
</p>
<p>
   The idea of a Presenter was first introduced to the Rails community
   by Jay Fields in a series of blog articles in 2006 and 2007. Fields
   <a href="http://blog.jayfields.com/2007/03/rails-presenter-pattern.html">summarizes</a> the Presenter pattern as follows:
</p>
<blockquote>

<p>The Presenter pattern addresses bloated controllers and views
containing logic in concert by creating a class representation of
the state of the view. An architecture that uses the Presenter
pattern provides view specific data as attributes of an instance of
the Presenter. The Presenter's state is an aggregation of model and
user entered data.
</p>
</blockquote>


<p>
   The Presenter as described by Fields is reminiscent of the
   intermediate representation in the "<a href="http://martinfowler.com/eaaCatalog/twoStepView.html">Two Step View</a>" pattern:
</p>
<blockquote>

<p>…a logical screen structure that is suggestive of the display
elements yet contains no HTML.
</p>
</blockquote>


<p>
   The canonical example for this Presenter is a report or summary,
   where a number of disparate elements from different models need to
   be brought together on a single page. Rather than have the
   controller fetch each element individually, it instead instantiates
   a Presenter object which aggregates the separate elements into a
   single unit customized for that particular view.
</p>
<p>
   Over time Fields and others elaborated and extended the Presenter
   concept, to include view-specific attributes (such as a list of
   possible values for a <code>&lt;select&gt;</code> tag); non-persisted fields (such
   as the "confirm password" field on an account creation page);
   validations and error messages (thereby keeping user-facing error
   strings out of the models); and, in some versions, the ability to
   accept updated data and save the new values back to their
   respective tables.
</p>
<p>
   More recently, various programmers, including your author, have
   evolved a more granular variation on the Presenter idea, where
   individual model instances are wrapped with an object whose
   responsibility is to adapt the model for presentation. Often (but
   not always) these wrappers are proper Decorators, passing through
   any un-overridden method to the underlying model instance.
</p>
<p>
   At first these differences seemed like minor variations on a theme;
   but the more I thought about it the more I realized they are two
   largely orthogonal concepts. 
</p>
<p>
   "Classic" presenters are oriented towards a particular view; they
   are, in Jay Fields' words, "class versions of your views". They
   have names like <code>ReportPresenter</code> or <code>OrderCompletionPresenter</code>.
   In contrast, this second generation of presenters are oriented
   primarily towards specific models. They have names like
   <code>UserPresenter</code> or <code>PicturePostPresenter</code>. They enable a particular
   model instance to render itself to a page.
</p>
<p>
   Taking all this into consideration, I realized that if I persisted
   in calling these things "Presenters", I'd be—at best—further
   muddying the semantic waters. As I mentioned earlier, I considered
   calling them "Presenter Decorators", but that still seemed like it
   could lead to confusion. At the same time I didn't want to simply
   call them "Decorators" because I think they are a sufficiently
   specialized kind of Decorator to deserve their own
   designation. Eventually I settled on "Exhibit", a term which as far
   as I know is unencumbered by previous pattern associations.
</p>
<p>
   When we tease these two concepts of "Presenter" and "Exhibit" into
   separate entities, we realize that they are complementary patterns
   that could easily work together in an application. This text deals
   mainly with Exhibits, but it's easy to imagine an app in which
   Exhibits are aggregated together under a combined Presenter for a
   particular page.
</p>
<p>
   Note: By introducing the "Exhibit" terminology, my intention is not
   to impose my own naming on anyone else's work. I simply want to
   keep my ideas from further polluting the already overburdened
   "Presenter" namespace. Others are welcome to use the "Exhibit" term
   if they find it helpful, but in the context of this text I am only
   applying the term  to the presentational decorators described
   here.
</p>
</div>

</div>

<div id="outline-container-12_3" class="outline-3">
<h3 id="sec-12_3">Exhibit Object Characteristics </h3>
<div class="outline-text-3" id="text-12_3">

<p>   For the purposes of clarity, here's a rundown of the essential
   characteristics of an Exhibit object.
</p>
<p>
   An Exhibit object:
</p>
<ul>
<li><b>Wraps a single model instance.</b>
</li>
<li><b>Is a true Decorator</b>. All unrecognized messages are passed
     through to the underlying object. This facilitates a gradual
     migration to the use of Exhibits to encapsulate presentation
     knowledge, since they can be layered onto models without any
     change to the existing views. It also enables multiple Exhibits
     to be layered onto an object, each handling different aspects of
     presentation.
</li>
<li><b>Brings together a model and a context</b>. Exhibits
     need a reference to a "context" object—either a controller or a
     view context—in order to be able to render templates as well
     as construct URLs for the object or related resources.
</li>
<li><b>Encapsulates decisions about how to render an object.</b> The
     tell-tale of an Exhibit is telling an object "render yourself",
     rather than explicitly rendering a template and passing the
     object in as an argument.
</li>
<li><b>May modify the behavior of an object.</b> For instance, an Exhibit
     might impose a scope on a <code>Blog#entries</code> association which only
     returns entries that are visible to the current user (as
     determined from the Exhibit's controller context). Or it might
     reformat the return value of a <code>#social_security_number</code> method
     to include dashes and have all but the last four digits obscured:
     <code>***-**-5678</code>.
</li>
</ul>

</div>

</div>

<div id="outline-container-12_4" class="outline-3">
<h3 id="sec-12_4">Refactoring the exhibits </h3>
<div class="outline-text-3" id="text-12_4">

<p>The two exhibits we defined earlier are nearly identical. Clearly,
they are ripe for refactoring. Let's take care of that. We'll move the
commonalities into a <code>Exhibit</code> base class:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/exhibits/exhibit.rb</span>
require <span class="org-string">'delegate'</span>
<span class="org-keyword">class</span> <span class="org-type">Exhibit</span> &lt; <span class="org-type">SimpleDelegator</span>  
  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(model, context)
    <span class="org-variable-name">@context</span> = context
    <span class="org-keyword">super</span>(model)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">An Exhibit base class</div>
</div>


<p>
Now our exhibits are are a lot slimmer:
</p>


<div class="listing">

<pre class="src src-ruby">require_relative <span class="org-string">'exhibit'</span>
<span class="org-keyword">class</span> <span class="org-type">PicturePostExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-keyword">def</span> <span class="org-function-name">render_body</span>
    <span class="org-variable-name">@context</span>.render(partial: <span class="org-string">"/posts/picture_body"</span>, locals: {post: <span class="org-variable-name">self</span>})
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The refactored PicturePostExhibit</div>
</div>


<p>
The specs we wrote earlier help ensure that we haven't broken anything
by performing this refactoring.
</p>
<p>
Before we move on, let's add a couple of extras to the <code>Exhibit</code>
base class.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Exhibit</span> &lt; <span class="org-type">SimpleDelegator</span>  
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">to_model</span>
    __getobj__
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">class</span>
    __getobj__.class
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Making an Exhibit look more like a model</div>
</div>


<p>
We don't have time to demonstrate it here, but these will help prevent
certain "gotchas" down the road. The first one defines <code>#to_model</code> to
return the wrapped model (the strange <code>#__getobj__</code> method is how
<code>SimpleDelegator</code> refers to its underlying object). The second one is
a flat-out fib: it redefines <code>#class</code> to return the class of the
original model, instead of the class of the exhibit. Together, these
methods will help ensure that Rails helpers such as <code>#form_for</code> don't
get confused when they encounter models wrapped in exhibits.
</p>
</div>

</div>

<div id="outline-container-12_5" class="outline-3">
<h3 id="sec-12_5"><a name="ID-e4207b06-e4e0-4e2f-8c6d-e09b20d2f0f8" id="ID-e4207b06-e4e0-4e2f-8c6d-e09b20d2f0f8"></a>Refactoring <code>#exhibit</code> </h3>
<div class="outline-text-3" id="text-12_5">

<p>   A little while ago we wrote this:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/helpers/exhibits_helper.rb</span>
<span class="org-keyword">module</span> <span class="org-type">ExhibitsHelper</span>
  <span class="org-keyword">def</span> <span class="org-function-name">exhibit</span>(model, context)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Doing a string comparison because of Rails class-reloading weirdness</span>
    <span class="org-keyword">case</span> model.class.name
    <span class="org-keyword">when</span> <span class="org-string">'Post'</span>
      <span class="org-keyword">if</span> model.picture?
        <span class="org-type">PicturePostExhibit</span>.new(model, context)
      <span class="org-keyword">else</span>
        <span class="org-type">TextPostExhibit</span>.new(model, context)
      <span class="org-keyword">end</span>
    <span class="org-keyword">else</span>
      model
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The ExhibitsHelper, again</div>
</div>


<p>
   On one hand, this code makes it very easy to see, in one place,
   what exhibits will be applied to a given object. On the other
   hand, even with just three exhibits it's already a nasty nested
   conditional. We wouldn't want to keep adding to it without
   refactoring it somehow.
</p>
<p>
   Let's look at one possible refactoring. First, we rewrite the
   <code>ExhibitsHelper#exhibit</code> method to delegate to a class method on
   the <code>Exhibit</code> base class.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">exhibit</span>(model, context)
  <span class="org-type">Exhibit</span>.exhibit(model, context)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Delegating #exhibit</div>
</div>


<p>
   Next we implement <code>Exhibit.exhibit</code> to iterate through a list of
   exhibits, giving each one an opportunity to wrap the provided
   object.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Exhibit</span> &lt; <span class="org-type">SimpleDelegator</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.exhibit</span>(object, context)
    exhibits.inject(object) <span class="org-keyword">do</span> |object, exhibit|
      exhibit.exhibit_if_applicable(object, context)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Searching a list of potential exhibits</div>
</div>


<p>
   This code bears a strong resemblance to the <a href="http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">Chain of Responsibility</a>
   pattern. It differs from the traditional version of that pattern in
   that it doesn't return as soon as the first exhibit capable of
   wrapping the object is found.
</p>
<p>
   We define <code>Exhibit.exhibit_if_applicable</code> to query a <code>.applicable_to?</code>
   predicate against the given object, and instantiate itself if the
   result is affirmative.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Exhibit</span> &lt; <span class="org-type">SimpleDelegator</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.exhibit_if_applicable</span>(object, context)
    <span class="org-keyword">if</span> applicable_to?(object)
      new(object, context)
    <span class="org-keyword">else</span>
      object
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Exhibit.exhibit_if_applicable</div>
</div>


<p>
   Note that <code>.exhibit_if_applicable</code> is an example of "<a href="http://c2.com/cgi/wiki?TellDontAsk">Tell, Don't Ask</a>". This keeps the <code>.exhibit</code> logic nicely focused on one and
   only one thing: giving each exhibit an opportunity to apply itself
   to the object at hand.
</p>
<p>
   In <code>Exhibit</code>, <code>.applicable_to?</code> will simply return false. Subclasses will
   have to implement it to match applicable objects.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">self.applicable_to?</span>(object)
  <span class="org-variable-name">false</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Exhibit.applicable_to?</div>
</div>


<p>
   We add a <code>.applicable_to?</code> predicate to each concrete <code>Exhibit</code> subclass,
   implementing the appropriate matching semantics for that
   exhibit. For instance, the <code>PicturePostExhibit.applicable_to?</code> method
   checks to see if the given object is a picture <code>Post</code>.
</p>



<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">PicturePostExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.applicable_to?</span>(object)
    object.is_a?(<span class="org-type">Post</span>) &amp;&amp; object.picture?
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">PicturePostExhibit.applicable_to?</div>
</div>


<p>
   Likewise for the other two exhibits:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">TextPostExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.applicable_to?</span>(object)
    object.is_a?(<span class="org-type">Post</span>) &amp;&amp; (!object.picture?)
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>
<span class="org-keyword">class</span> <span class="org-type">LinkExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.applicable_to?</span>(object)
    object.is_a?(<span class="org-type">Post</span>)
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">TextPostExhibit.applicable_to?</div>
</div>


<p>   
   Finally, we define <code>Exhibit.exhibits</code> to return a hard-coded
   list of exhibits to try.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Exhibit</span> &lt; <span class="org-type">SimpleDelegator</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.exhibits</span>
    [
     <span class="org-type">TextPostExhibit</span>,
     <span class="org-type">PicturePostExhibit</span>,
     <span class="org-type">LinkExhibit</span>
    ]
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">A hard-coded list of exhibits</div>
</div>


<p>
   Hard-coding this list is a little non-DRY. We could instead define
   an <code>.inherited</code> callback on <code>Exhibit</code> which would automatically
   add exhibits to an internal list as they are loaded.
</p>
<p>
   The advantage of hard-coding the list is that it ensures a
   consistent and obvious ordering of exhibits. We know which
   exhibits may be applied, and we know the order in which they will
   be tried. There are advantages to both approaches, but personally,
   based on experience debugging auto-generated lists of classes, I
   lean towards the explicit list. Even though it duplicates a little
   bit of knowledge.
</p>
</div>

</div>

<div id="outline-container-12_6" class="outline-3">
<h3 id="sec-12_6">Many models to many exhibits </h3>
<div class="outline-text-3" id="text-12_6">


<p>
   Our original <code>#exhibit</code> helper and our new refactored version share
   a common property which might not be immediately obvious: They both
   enable a <i>many-to-many relationship</i> between business models and
   exhibits. That is, some model objects may have no exhibits which apply to
   them. Other models may have multiple exhibits "stacked" on
   them. Some exhibits may be applicable only to a single model class,
   whereas others might be common across many types of model.
</p>
<p>
   This is an important point. A big part of the power of the Exhibit
   pattern is being able to freely vary both sides of the
   Exhibit/Model relationship. It gives us two independent "axes" of
   change—one for business decisions, one for presentation
   decisions.
</p>
<p>
   This is why we haven't implemented any kind of convention-based
   exhibit discovery—e.g. we don't automatically look up a
   <code>PostExhibit</code> for a <code>Post</code> object. The strength of the pattern
   lies in the ability to independently vary the business model and
   the view model, so we don't want to arbitrarily constrain ourselves
   by binding business models and exhibits in a one-to-one, lockstep
   relationship.                                                         
</p>
</div>

</div>

<div id="outline-container-12_7" class="outline-3">
<h3 id="sec-12_7"><a name="ID-3732f841-7c09-4e2c-b844-3e79c6aed607" id="ID-3732f841-7c09-4e2c-b844-3e79c6aed607"></a>Do we need helpers? </h3>
<div class="outline-text-3" id="text-12_7">


<p>
Our use of exhibits raises the question: what do we need view
helpers for? Anything?
</p>
<p>
In my experience helpers in Rails apps tend to devolve into large,
disorganized bags of unrelated methods. Often these methods repeat the
same conditional business logic over and over again. For instance, how
many times have you seen helper code like this:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">if</span> current_user.logged_in?
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">else</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Checking that the user is logged in</div>
</div>


<p>
Thinning out helpers by taking some of their presentation
responsibilities away is not a bad thing, in my view.
</p>
<p>
That said, I don't think helpers are completely useless. They are a
good place to put general rendering methods which aren't tied to any
particular model. For instance, we could write a helper for displaying
HTML5-style images with captions:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">FigureHelper</span>
  <span class="org-keyword">def</span> <span class="org-function-name">figure</span>(image_path, caption)
    content_tag(<span class="org-constant">:figure</span>) <span class="org-keyword">do</span> 
      image_tag(image_path) +
        content_tag(<span class="org-constant">:figcaption</span>, caption)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">A helper for rendering HTML5 figures</div>
</div>


<p>
This helper generates markup that looks like this:
</p>


<div class="listing">

<pre class="src src-html">&lt;<span class="org-function-name">figure</span>&gt;
  &lt;<span class="org-function-name">img</span> <span class="org-variable-name">alt</span>=<span class="org-string">"freshpaint.jpg"</span> <span class="org-variable-name">src</span>=<span class="org-string">"http://example.org/f.jpg"</span> /&gt;
  &lt;<span class="org-function-name">figcaption</span>&gt;Fresh paint&lt;/<span class="org-function-name">figcaption</span>&gt;
&lt;/<span class="org-function-name">figure</span>&gt;

</pre>


<div class="caption">Generated figure markup</div>
</div>


<p>
This is pretty generic code, and I think it works well in a helper.
</p>
</div>
</div>

</div>

<div id="outline-container-13" class="outline-2">
<h2 id="sec-13">Making the data stick around </h2>
<div class="outline-text-2" id="text-13">


<p>
Posts, time stamps, reverse-chronological sorting, image
posting… we're well on our way to a working blog engine. But I feel
like there's something missing. Some little detail, if I could just
put my finger on it…
</p>
<p>
…oh yeah, <i>persistence</i>! It would probably be good if our blog posts
lasted longer than run-time of the application server.
</p>
<p>
If you've been following along wondering "where's the ActiveRecord?",
this is where we get to it. Now that we have figured out what our
domain model looks like, it's time to start serializing the models to
a database.
</p>
<p>
But first, a little philosophizing.
</p>

</div>

<div id="outline-container-13_1" class="outline-3">
<h3 id="sec-13_1"><a name="ID-317548a9-552e-47ce-9aac-5e8d656511fc" id="ID-317548a9-552e-47ce-9aac-5e8d656511fc"></a>The trouble with ActiveRecord </h3>
<div class="outline-text-3" id="text-13_1">


<p>
ActiveRecord is an <a href="http://en.wikipedia.org/wiki/Object-relational_mapping">Object-Relational Mapper</a> (ORM) based on the <a href="http://martinfowler.com/eaaCatalog/activeRecord.html">Active Record</a>
pattern from <a href="http://www.martinfowler.com/books.html#eaa">Patterns of Enterprise Application Architecture</a>. As an
ORM, it is semi-orthogonal to the business logic of your
application. ORMs handle the loading and saving of objects to records
in a database. The behavior of those objects, apart from persistence,
is (theoretically) outside of the ORM's responsibilities.
</p>
<p>
In practice, real world Rails-based projects tend to be almost
inextricably coupled to the ActiveRecord library. And not just to
ActiveRecord; ActiveRecord-based apps also tend to have very tight
inter-coupling between the various models in the system. In
pathological cases, controllers and even views are also closely
married to the details of ActiveRecord and database schema.
</p>
<p>
Part of this is doubtless due to the way ActiveRecord integrates with
models. By declaring an <a href="http://en.wikipedia.org/wiki/Is-a">is-a</a> relationship between ActiveRecord and
model classes, your models are no longer just domain models; they
effectively <i>are</i> ActiveRecord. One result of this tight coupling is
that novice and intermediate Rails developers are often surprised to
find out that it's even <i>permissible</i> to have model objects which do
not inherit from <code>ActiveRecord::Base</code>. And even after they learn this
they sometimes still exile their non-ActiveRecord models to the <code>lib/</code>
ghetto, denying them their true place in <code>app/models</code>.
</p>

</div>

<div id="outline-container-13_1_1" class="outline-4">
<h4 id="sec-13_1_1">Melon Collie and the Infinite Protocol </h4>
<div class="outline-text-4" id="text-13_1_1">


<p>
Consider the case of the <code>#find</code> method. By inheriting from
<code>ActiveRecord::Base</code>, you declare that your model supports
<code>#find</code>. Find supports (at last count) four modes (<code>:id</code>, <code>:first</code>,
<code>:last</code>, and <code>:all</code>), each of which can take any of twelve different
options. Some of the options, such as <code>:conditions</code>, can accept an
effectively limitless range of values.
</p>
<p>
<code>#find</code> is, in effect, an <i>infinite protocol</i>. This presents some
serious difficulties. Many Rails developers have discovered, for
instance, that it is very difficult to write meaningful ActiveRecord
mock objects in their tests. If they strictly specify all of the
<code>#find</code> arguments that their method-under-test must pass, they are
essentially dictating the implementation of the method in the
test. If, on the other hand, they stick with pure stubs which will
accept any possible call to <code>#find</code>, their tests are less brittle, but
also less useful because they don't actually specify much.
</p>
<p>
As a result, a lot of developers resort to running all of their unit
tests as what are, in effect, integration tests, with "real"
collaborator objects and full database interactions. The result, on
the testing side, is slow tests. The result on the application code
side is classes that freely call <code>#find</code> and friends on a half-a-dozen
different collaborator classes—thus ensuring that future
refactorings will be a slow and tedious process akin to un-teasing
thickly matted dreadlocks.
</p>
<p>
One day, after years of witnessing and addressing the technical debt
incurred in various maturing Rails codebases as a result of
ActiveRecord-inspired tight coupling, I had an epiphany. What if we
stopped treating ActiveRecord as the backbone of our model classes,
and instead, programmed <i>as if</i> ActiveRecord were merely a private
implementation detail?
</p>
<p>
And this is why we have, so far, programmed this application without
once touching ActiveRecord. We've worked through the object
representation of domain concepts—blog, posts, publishing,
etc—using traditional object-oriented analysis and development.
</p>
<p>
Now we'll add persistence to the mix. We'll use ActiveRecord, because
it is both convenient and powerful. But we'll attempt to do it in
a way that treats it as an internal concern to our models, not as the
backbone of our design.
</p>
</div>
</div>

</div>

<div id="outline-container-13_2" class="outline-3">
<h3 id="sec-13_2">Adding ActiveRecord </h3>
<div class="outline-text-3" id="text-13_2">


<p>
Looking at our models, it's pretty clear that we need a "posts" table
to hold blog posts. So we'll start by creating a migration to create
that table.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">CreatePosts</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Migration</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.up</span>
    create_table <span class="org-constant">:posts</span> <span class="org-keyword">do</span> |t|
      t.datetime <span class="org-constant">:pubdate</span>
      t.string <span class="org-constant">:title</span>
      t.text <span class="org-constant">:body</span>
      t.string <span class="org-constant">:image_url</span>
      t.timestamps
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.down</span>
    drop_table <span class="org-constant">:posts</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Migration to add a "posts" table</div>
</div>


<p>
Once we run this migration, we have a place to keep our blog
posts. Now we need to make the <code>Post</code> model store itself there.
</p>
<p>
We need to make several changes to the <code>Post</code> and <code>Blog</code> code.
</p>


<div class="listing">

<pre class="src src-ruby">require <span class="org-string">'date'</span>
require <span class="org-string">'active_record'</span>
<span class="org-keyword">class</span> <span class="org-type">Post</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>
  validates <span class="org-constant">:title</span>, presence: <span class="org-variable-name">true</span>
  attr_accessor <span class="org-constant">:blog</span>
  <span class="org-keyword">def</span> <span class="org-function-name">picture?</span>
    image_url.present?
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">publish</span>(clock=<span class="org-type">DateTime</span>)
    <span class="org-keyword">return</span> <span class="org-variable-name">false</span> <span class="org-keyword">unless</span> valid?
    <span class="org-variable-name">self</span>.pubdate = clock.now
    <span class="org-variable-name">@blog</span>.add_entry(<span class="org-variable-name">self</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Adding ActiveRecord to Post</div>
</div>


<ul>
<li><code>Post</code> now inherits from <code>ActiveRecord::Base</code>. We require
  <code>active_record</code> for when we are running tests in isolation.
</li>
<li>The various individual ActiveModel mixins are gone, subsumed into
  <code>ActiveRecord::Base</code>.
</li>
<li>No more attribute accessors for <code>title</code>, <code>body</code>, and
  <code>image_url</code>. Those are handled by ActiveRecord now.
</li>
<li>No more initializer. Its former functionality is rendered redundant
  by the AR initializer.
</li>
<li><code>#persisted?</code> is gone too, for the same reason.
</li>
</ul>


<p>
Moving on to <code>Blog</code>:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Blog</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(entry_fetcher=<span class="org-type">Post</span>.public_method(<span class="org-constant">:all</span>))
    <span class="org-variable-name">@entry_fetcher</span> = entry_fetcher
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  <span class="org-keyword">def</span> <span class="org-function-name">entries</span>
    fetch_entries.sort_by{|e| e.pubdate}.reverse.take(10)
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  <span class="org-keyword">def</span> <span class="org-function-name">add_entry</span>(entry)
    entry.save
  <span class="org-keyword">end</span>

  private

  <span class="org-keyword">def</span> <span class="org-function-name">fetch_entries</span>
    <span class="org-variable-name">@entry_fetcher</span>.()
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Upadating Blog to use ActiveRecord</div>
</div>


<ul>
<li>The <code>@entries</code> instance variable, which used to point to an array of
  entries, is gone. In it's place is an <code>@entry_fetcher</code>
  variable. We're using this variable to make the strategy for finding
  blog entries an inject-able dependency. This will make testing the
  class easier.
</li>
<li>Since posts live in the database now, the default method for
  fetching a list of entries is to call <code>Post.all</code>.
</li>
<li>Apart from using the entry fetcher instead of referencing the
  <code>@entries</code> list directly, the <code>entries</code> method has changed
  surprisingly little. Because the result of ActiveRecord's <code>#all</code> is
  <code>Enumerable</code>, we can still use the same sorting and filtering
  methods we used before. It's not efficient, but it works for now.
</li>
<li><code>#add_entry</code>, instead of adding the post to an internal list, now
  calls <code>#save</code> on the passed entry.
</li>
</ul>


</div>

</div>

<div id="outline-container-13_3" class="outline-3">
<h3 id="sec-13_3">Why does <code>Blog</code> do the saving? </h3>
<div class="outline-text-3" id="text-13_3">


<p>
That last item warrants some more discussion. Originally,
<code>Blog#add_entry</code> was needed because <code>Blog</code> maintained an internal list
of entries. But now that posts are stored in the DB, can't we just
call <code>#save</code> on them directly from <code>Post#publish</code>, and do away with
<code>Blog#add_entry</code>?
</p>
<p>
Here's the thing: while the data storage strategy has changed, the
conceptual model of the application ought to stay the same. And that
model is that a <code>Blog</code> is currently the top-level object in the app,
and it is responsible for creating and maintaining a list of blog
entries.
</p>
<p>
Does it really matter who does the saving? Consider this: supposing
one day we decide to add a feature where our blog will send
notifications to our social networking accounts (Twitter, Facebook,
etc.) whenever a new post is published. This is publishing of
notifications should probably be accessible from the top-level
blog object, since it will presumably have references to the needed
account information objects. Let's say there's a
<code>Blog#spam_social_networks(entry)</code> method.
</p>
<p>
If Posts are responsible for saving themselves, the <code>Blog</code> object will
have no way of knowing when a new post goes up, and therefore needs to
be broadcast. Which means we'd probably wind up adding an <code>after_save</code>
hook in <code>Post</code>, something like this:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  after_save <span class="org-constant">:broadcast_entry</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  private

  <span class="org-keyword">def</span> <span class="org-function-name">broadcast_entry</span>
    blog.spam_social_networks(<span class="org-variable-name">self</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">After-save hook to notify social networks</div>
</div>


<p>
The trouble is, spamming social networks is almost entirely orthogonal
to a <code>Post</code>'s primary responsibility of representing a blog post. The
origins of many a bloated model can be traced back to this kind of
gradual responsibility creep.
</p>
<p>
When we keep the conceptual responsibility of adding a new post on the
<code>Blog</code>, there's no need for callbacks:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">add_entry</span>(entry)
  entry.save
  spam_social_networks(entry)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Notifying social networks from the Blog model</div>
</div>


<p>
That's shorter and (I'd argue) a better place for the code. The larger
point here is that by first building up our domain models divorced
from persistence concerns, we came up with a design that closely
matches our mental picture of the problem. As a result, new features
that are still consistent with our original conception of the problem
space tend to slot in neatly.
</p>
<p>
(You might be objecting "but wait! Now <code>Blog</code> has two
responsibilities!" This is true, and a fair point. We can
optimistically imagine that <code>#spam_social_networks</code> is only an entry
point to a third object whose sole responsibility is sending out
notifications.)
</p>
</div>

</div>

<div id="outline-container-13_4" class="outline-3">
<h3 id="sec-13_4"><a name="ID-f775ca6e-9240-45cb-9faa-16cd093f23b0" id="ID-f775ca6e-9240-45cb-9faa-16cd093f23b0"></a>Updating the <code>Blog</code> tests </h3>
<div class="outline-text-3" id="text-13_4">


<p>
As you might imagine, we need to make a number of changes to the
<code>Post</code> and <code>Blog</code> specs to adapt them to these changes. We'll start
with <code>Blog</code>.
</p>
<p>
First of all, in creating a <code>Blog</code> instance to test, we now supply our
own entries list instead of letting it reach out to <code>Post</code> for the
list.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
before <span class="org-keyword">do</span>
  <span class="org-variable-name">@entries</span> = []
  <span class="org-variable-name">@it</span> = <span class="org-type">Blog</span>.new(-&gt;{<span class="org-variable-name">@entries</span>})
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Injecting blog entries in tests</div>
</div>


<p>
And instead of asserting that <code>#add_entry</code> adds an item to an internal
list, we now assert that it calls <code>#save</code> to add the entry:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
describe <span class="org-string">"#add_entry"</span> <span class="org-keyword">do</span>
  it <span class="org-string">"adds the entry to the blog"</span> <span class="org-keyword">do</span>
    entry = stub!
    mock(entry).save
    <span class="org-variable-name">@it</span>.add_entry(entry)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Asserting entries are saved</div>
</div>


<p>
If you recall, the tests for <code>Blog</code> also specify that it must return
only 10 entries from <code>#entries</code>, and they must be sorted in
reverse-chronological order. We could inject a fake entries collection
into the object and continue to test it as we did before. But this
would make for a fragile test. We probably want to change the
<code>Enumerable</code> code to native <code>ActiveRecord</code> filtering/limiting calls at
some point in the future. At that point our specs would break.
</p>
<p>
One option is that we simply remove the specs when that happens, since
we trust that ActiveRecord will implement sorting and filtering
correctly. But do we trust ourselves to call ActiveRecord correctly?
</p>
<p>
Instead, what we'll do is move these specs from the current isolated
unit test into a separate <code>Blog</code> integration test suite. This suite
will hit the actual database.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/models/blog_integration_spec.rb</span>
require_relative <span class="org-string">'../spec_helper_full'</span>

describe <span class="org-type">Blog</span> <span class="org-keyword">do</span>
  include <span class="org-type">SpecHelpers</span>
  before <span class="org-keyword">do</span>
    setup_database
    <span class="org-variable-name">@it</span> = <span class="org-type">Blog</span>.new
  <span class="org-keyword">end</span>

  after <span class="org-keyword">do</span>
    teardown_database
  <span class="org-keyword">end</span>

  describe <span class="org-string">"#entries"</span> <span class="org-keyword">do</span>
    <span class="org-keyword">def</span> <span class="org-function-name">make_entry_with_date</span>(date)
      <span class="org-variable-name">@it</span>.new_post(pubdate: <span class="org-type">DateTime</span>.parse(date), title: date)
    <span class="org-keyword">end</span>

    it <span class="org-string">"is sorted in reverse-chronological order"</span> <span class="org-keyword">do</span>
      oldest = make_entry_with_date(<span class="org-string">"2011-09-09"</span>)
      newest = make_entry_with_date(<span class="org-string">"2011-09-11"</span>)
      middle = make_entry_with_date(<span class="org-string">"2011-09-10"</span>)

      <span class="org-variable-name">@it</span>.add_entry(oldest)
      <span class="org-variable-name">@it</span>.add_entry(newest)
      <span class="org-variable-name">@it</span>.add_entry(middle)
      <span class="org-variable-name">@it</span>.entries.must_equal([newest, middle, oldest])
    <span class="org-keyword">end</span>

    it <span class="org-string">"is limited to 10 items"</span> <span class="org-keyword">do</span>
      10.times <span class="org-keyword">do</span> |i|
        <span class="org-variable-name">@it</span>.add_entry(make_entry_with_date(<span class="org-string">"2011-09-</span><span class="org-variable-name">#{i+1}</span><span class="org-string">"</span>))
      <span class="org-keyword">end</span>
      oldest = make_entry_with_date(<span class="org-string">"2011-08-30"</span>)
      <span class="org-variable-name">@it</span>.add_entry(oldest)
      <span class="org-variable-name">@it</span>.entries.size.must_equal(10)
      <span class="org-variable-name">@it</span>.entries.wont_include(oldest)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Separating out an integration test for the Blog</div>
</div>


<p>
This spec will continue to specify the expected order and collection
size regardless of how the selection is accomplished inside <code>Blog</code>.
</p>
</div>

</div>

<div id="outline-container-13_5" class="outline-3">
<h3 id="sec-13_5">Separating out integration tests </h3>
<div class="outline-text-3" id="text-13_5">


<p>
This is a technique I often use in the apps I work on. Separating unit
tests from integration tests puts a clear divider between the tests
that verify that our database interactions are doing what we think
they are doing, from the tests that specify what logic our models
should implement.
</p>
<p>
It also makes it very easy to run <i>only</i> the fast, isolated tests; or
<i>only</i> the slow, DB-bound tests. Keeping as many of our tests as
possible in super-fast isolation means we can complete the
red-green-refactor cycle in seconds rather than minutes.
</p>
<p>
You may have noticed some new methods being called in the <code>before</code> and
<code>after</code> blocks. These ensure that the database contents is blown away
before and after test runs. Here are the definitions:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/spec_helper_full.rb</span>
require_relative <span class="org-string">'spec_helper_lite'</span>
require_relative <span class="org-string">'../config/environment.rb'</span>
<span class="org-keyword">module</span> <span class="org-type">SpecHelpers</span>
  <span class="org-keyword">def</span> <span class="org-function-name">setup_database</span>
    <span class="org-type">DatabaseCleaner</span>.strategy = <span class="org-constant">:transaction</span>
    <span class="org-type">DatabaseCleaner</span>.clean_with(<span class="org-constant">:truncation</span>)
    <span class="org-type">DatabaseCleaner</span>.start
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">teardown_database</span>
    <span class="org-type">DatabaseCleaner</span>.clean
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Database setup/teardown for tests</div>
</div>

</div>

</div>

<div id="outline-container-13_6" class="outline-3">
<h3 id="sec-13_6"><a name="ID-a077d152-d149-4e25-ba83-93ec71fd5e2f" id="ID-a077d152-d149-4e25-ba83-93ec71fd5e2f"></a>Updating the <code>Post</code> tests </h3>
<div class="outline-text-3" id="text-13_6">


<p>
The majority of changes we make to the <code>Post</code> tests are removals. For
instance, this test asserts that we can pass attributes into
<code>Post#new</code>:
</p>


<div class="listing">

<pre class="src src-ruby">it <span class="org-string">"supports setting attributes in the initializer"</span> <span class="org-keyword">do</span>
  it = <span class="org-type">Post</span>.new(title: <span class="org-string">"mytitle"</span>, body: <span class="org-string">"mybody"</span>)
  it.title.must_equal <span class="org-string">"mytitle"</span>
  it.body.must_equal <span class="org-string">"mybody"</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">An obsolete Post test</div>
</div>


<p>
We are reasonably confident that this functionality Just Works in
ActiveRecord, so we trash the test.
</p>
<p>
Throwing away tests… does this mean that the test was a waste of
time? No, it served its purpose. We're using tests primarily for the
sake of driving design, so even if we threw them all out right now
they would still have played their part. Of course, it's also nice to
have them around to catch regressions; but deleting the odd test
should not be cause for consternation.
</p>
</div>

</div>

<div id="outline-container-13_7" class="outline-3">
<h3 id="sec-13_7"><a name="ID-d49f2890-fd04-495d-b4b0-5011718325f2" id="ID-d49f2890-fd04-495d-b4b0-5011718325f2"></a>Mocking ActiveRecord </h3>
<div class="outline-text-3" id="text-13_7">


<p>
<code>Post</code> is now an <code>ActiveRecord::Base</code> derivative, which means it's
going to be trying to talk to the database all the time. How can we
continue to test it in isolation? We'll use a couple of strategies to
make that work.
</p>
<p>
First, remember how we said we were going to treat ActiveRecord as an
implementation detail rather than as an essential part of the model?
Now we put those words into action. Here's the top-level setup block
for <code>Post</code> tests:
</p>


<div class="listing">

<pre class="src src-ruby">before <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-variable-name">@it</span> = <span class="org-type">Post</span>.new(title: <span class="org-string">"TITLE"</span>)
  <span class="org-variable-name">@ar</span> = <span class="org-variable-name">@it</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">An alias for mocking ActiveRecord</div>
</div>


<p>
In this setup block, we take a second reference to the object being
tested and call it <code>@ar</code>. It's actually the same object, but we'll use
it for creating mocks and stubs of ActiveRecord-provided methods. We
want to treat ActiveRecord as just another collaborator, and the <code>@ar</code>
alias helps us make that delineation more "real".
</p>
<p>
Here's an example where we use the alias:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
before <span class="org-keyword">do</span>
  stub(<span class="org-variable-name">@ar</span>).valid?{<span class="org-variable-name">false</span>}
<span class="org-keyword">end</span>

it <span class="org-string">"wont add the post to the blog"</span> <span class="org-keyword">do</span>
  dont_allow(<span class="org-variable-name">@blog</span>).add_entry
  <span class="org-variable-name">@it</span>.publish
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Using the ActiveRecord alias</div>
</div>


<p>
We want to simulate the case where the object is invalid. Since
validity checking is provided by ActiveRecord, we treat it as an
external dependency and stub it out with
<code>stub(@ar).valid?{false}</code>. Then we attempt to publish the post, and
verify that in an invalid state the post will not be added to the
blog.
</p>
</div>

</div>

<div id="outline-container-13_8" class="outline-3">
<h3 id="sec-13_8"><a name="ID-f5f45d37-f701-4f99-b998-b35d2294d939" id="ID-f5f45d37-f701-4f99-b998-b35d2294d939"></a>Stubbing out the Database with NullDB </h3>
<div class="outline-text-3" id="text-13_8">


<p>
Secondly, in order to avoid the overhead of connecting to a real
database, we use <a href="https://github.com/nulldb/nulldb">NullDB</a> to set up a do-nothing database connection before
running the specs.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
before <span class="org-keyword">do</span>
  setup_nulldb
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

after <span class="org-keyword">do</span>
  teardown_nulldb
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Setting up NullDB</div>
</div>


<p>
These helpers are defined in <code>spec_helper_lite.rb</code>:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">SpecHelpers</span>
  <span class="org-keyword">def</span> <span class="org-function-name">setup_nulldb</span>
    schema_path = <span class="org-type">File</span>.expand_path(<span class="org-string">'../db/schema.rb'</span>, 
                                   <span class="org-type">File</span>.dirname(__FILE__))
    <span class="org-type">NullDB</span>.nullify(schema: schema_path)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">teardown_nulldb</span>
    <span class="org-type">NullDB</span>.restore
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">NullDB helpers</div>
</div>


</div>

</div>

<div id="outline-container-13_9" class="outline-3">
<h3 id="sec-13_9">Rake tasks for testing </h3>
<div class="outline-text-3" id="text-13_9">

<p>   Now that we have both isolated unit tests and integration tests, it
   seems like a good time to set up some Rake tasks for running
   them. We want shortcuts for running just the unit tests, just
   the integration tests, or all of the above.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">lib/tasks/test.rake</span>
require <span class="org-string">'rake/testtask'</span>
namespace <span class="org-string">'test'</span> <span class="org-keyword">do</span> |ns|
  test_files             = <span class="org-type">FileList</span>[<span class="org-string">'spec/**/*_spec.rb'</span>]
  integration_test_files = <span class="org-type">FileList</span>[<span class="org-string">'spec/**/*_integration_spec.rb'</span>]
  unit_test_files        = test_files - integration_test_files
  desc <span class="org-string">"Run unit tests"</span>
  <span class="org-type">Rake</span>::<span class="org-type">TestTask</span>.new(<span class="org-string">'unit'</span>) <span class="org-keyword">do</span> |t|
    t.libs.push <span class="org-string">"lib"</span>
    t.test_files = unit_test_files
    t.verbose = <span class="org-variable-name">true</span>
  <span class="org-keyword">end</span>
  desc <span class="org-string">"Run integration tests"</span>
  <span class="org-type">Rake</span>::<span class="org-type">TestTask</span>.new(<span class="org-string">'integration'</span>) <span class="org-keyword">do</span> |t|
    t.libs.push <span class="org-string">"lib"</span>
    t.test_files = integration_test_files
    t.verbose = <span class="org-variable-name">true</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Clear out the default Rails dependencies</span>
<span class="org-type">Rake</span>::<span class="org-type">Task</span>[<span class="org-string">'test'</span>].clear
desc <span class="org-string">"Run all tests"</span>
task <span class="org-string">'test'</span> =&gt; %w[test<span class="org-constant">:unit</span> test<span class="org-constant">:integration</span>]

</pre>


<div class="caption">Rake tasks for testing</div>
</div>


<p>
We define a <code>FileList</code>, <code>test_files</code>, which expands to all of the
project's tests. Then we define a subset which expands to only the
integration tests. Remember, we kept them in separate files ending in
<code>_integration_spec.rb</code>, making them easy to match. Finally, we
subtract the integration tests from the full set of tests to get a
list of <code>unit_test_files</code>.
</p>
<p>
Once we have our file lists, it's a straightforward matter of
declaring some <code>Rake::TestTask</code> tasks for each set, and a top-level
<code>test</code> task which depends on both of them.
</p>
</div>

</div>

<div id="outline-container-13_10" class="outline-3">
<h3 id="sec-13_10"><a name="ID-2ff3341f-8d0d-4bfd-8fe8-4bfe2fb56026" id="ID-2ff3341f-8d0d-4bfd-8fe8-4bfe2fb56026"></a>Using ActiveRecord objects as data access objects </h3>
<div class="outline-text-3" id="text-13_10">


<p>   
   In the code above we constructed a <a href="http://en.wikipedia.org/wiki/Chinese_wall">chinese wall</a> between the bits of
   the model that ActiveRecord provides, and the bits that we
   provide. Some Rails practitioners prefer to set up a stricter
   division between business logic and storage logic.
</p>
<p>
   In order to accomplish this, they create separate business model
   objects which keep an internal reference to an ActiveRecord
   object. The ActiveRecord object is kept intentionally "skinny",
   containing only associations, scopes, and validations. The business
   model object delegates its storage to the AR object, but handles
   everything else internally. The ActiveRecord object becomes a way
   to get at the stored data, and nothing more.
</p>
<p>
   Piotr Solnica has <a href="http://solnic.eu/2011/08/01/making-activerecord-models-thin.html">a great post</a> about this pattern. Personally, I
   think this is a promising technique for separating concerns. But I
   also think it may be a bit heavyweight for some apps. In the code
   above I've tried to strike a middle ground, using convention more
   than hard object divisions to separate the concerns, and not
   straying too far from Rails norms. A little later on, once we get
   into tagging, we'll revisit this idea of using ActiveRecord as just
   a thin layer over database rows.
</p>
</div>
</div>

</div>

<div id="outline-container-14" class="outline-2">
<h2 id="sec-14"><a name="ID-5e701b05-6b1a-4cdf-9e4b-254b8f6c110d" id="ID-5e701b05-6b1a-4cdf-9e4b-254b8f6c110d"></a>Concealing ActiveRecord behind a <code>FigLeaf</code> </h2>
<div class="outline-text-2" id="text-14">

<p>  So far, our attempts to treat ActiveRecord as a private
  implementation detail have been by convention, rather than enforced
  by the framework. It would be nice if we could get some validation
  that we are in fact obeying the rules we've set for ourselves.
</p>
<p> 
  I've written a tool to make this possible, called <code>FigLeaf</code>. The
  code is fairly short, although it may be a bit daunting if you
  haven't done a lot of Ruby metaprogramming.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">Tools for making inherited interfaces private to a class.</span>
<span class="org-keyword">module</span> <span class="org-type">FigLeaf</span>
  <span class="org-keyword">module</span> <span class="org-type">Macros</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Given a list of classes, modules, strings, and symbols, compile</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">a combined list of methods. Classes and modules will be queried</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">for their instance methods; strings and symbols will be treated</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">as method names. </span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Once the list is compiled, make all of the methods private.</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Takes an optional options hash, which can include the following options:</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">- :ancestors is a boolean determining whether to consider</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">ancestors classes and modules.</span>
    <span class="org-comment-delimiter">#</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">- :except is a list of classes, modules, and method names which</span>
    <span class="org-comment-delimiter">#   </span><span class="org-comment">will be excluded from treatment.</span>
    <span class="org-keyword">def</span> <span class="org-function-name">hide</span>(*stuff)
      hide_methods(<span class="org-variable-name">self</span>, [<span class="org-type">Object</span>], *stuff)
    <span class="org-keyword">end</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Like #hide, only hides methods at the class/module level.</span>
    <span class="org-keyword">def</span> <span class="org-function-name">hide_singletons</span>(*stuff)
      hide_methods(singleton_class, [<span class="org-type">Class</span>], *stuff)
    <span class="org-keyword">end</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">The shared bits of #hide and #hide_singletons</span>
    <span class="org-keyword">def</span> <span class="org-function-name">hide_methods</span>(mod, except_defaults, *stuff)
      options = stuff.last.is_a?(<span class="org-type">Hash</span>) ? stuff.pop : {}
      include_ancestors  = options.fetch(<span class="org-constant">:ancestors</span>){<span class="org-variable-name">false</span>}
      except             = <span class="org-type">Array</span>(options.fetch(<span class="org-constant">:except</span>){except_defaults})
      protect            = <span class="org-type">Array</span>(options[<span class="org-constant">:protect</span>])
      except_methods     = collect_methods(<span class="org-variable-name">true</span>, *except)
      protect_methods    = collect_methods(<span class="org-variable-name">true</span>, *protect)
      methods_to_hide    = collect_methods(include_ancestors, *stuff)
      (methods_to_hide - except_methods).each <span class="org-keyword">do</span> |method_name|
        mod.module_eval <span class="org-keyword">do</span> 
          <span class="org-keyword">next</span> <span class="org-keyword">unless</span> method_defined?(method_name)
          <span class="org-keyword">if</span> protect_methods.include?(method_name)
            protected method_name
          <span class="org-keyword">else</span>
            private method_name
          <span class="org-keyword">end</span>
        <span class="org-keyword">end</span>
      <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Given a list of classes, modules, strings, and symbols, compile</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">a combined list of methods. Classes and modules will be queried</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">for their instance methods; strings and symbols will be treated</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">as methods names. +include_ancestors+ determines whether to</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">include methods defined by class/module ancestors.</span>
    <span class="org-keyword">def</span> <span class="org-function-name">collect_methods</span>(include_ancestors, *methods_or_modules)
      methods_or_modules.inject([]) {|methods, method_or_module|
        <span class="org-keyword">case</span> method_or_module
        <span class="org-keyword">when</span> <span class="org-type">Symbol</span>, <span class="org-type">String</span>
          methods &lt;&lt; method_or_module.to_sym
        <span class="org-keyword">when</span> <span class="org-type">Module</span> <span class="org-comment-delimiter"># </span><span class="org-comment">also includes classes</span>
          methods.concat(method_or_module.instance_methods(include_ancestors))
        <span class="org-keyword">when</span> <span class="org-type">Array</span>
          methods.concat(method_or_module)
        <span class="org-keyword">else</span>
          <span class="org-keyword">raise</span> <span class="org-type">ArgumentError</span>, <span class="org-string">"Bad argument: </span><span class="org-variable-name">#{method_or_module.inspect}</span><span class="org-string">"</span>
        <span class="org-keyword">end</span>
      }
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">self.clothe</span>(other)
    other.extend(<span class="org-type">Macros</span>)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">self.included</span>(other)
    clothe(other)
    other.singleton_class.extend(<span class="org-type">Macros</span>)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">self.extended</span>(object)
    clothe(object.singleton_class)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">FigLeaf</div>
</div>


<p>
In a nutshell, <code>FigLeaf</code> enables us to selectively make public methods
inherited from other classes and modules private. The objects can
still call these methods internally, but external classes are
prevented from doing so. To get an idea of how it works, we'll go
ahead and apply it to the <code>Post</code> class.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>
  include <span class="org-type">FigLeaf</span>
  hide <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>, ancestors: <span class="org-variable-name">true</span>,
       except: [<span class="org-type">Object</span>, <span class="org-constant">:init_with</span>, <span class="org-constant">:new_record?</span>, 
                <span class="org-constant">:errors</span>, <span class="org-constant">:valid?</span>, <span class="org-constant">:save</span>]
  hide_singletons <span class="org-type">ActiveRecord</span>::<span class="org-type">Calculations</span>, 
                  <span class="org-type">ActiveRecord</span>::<span class="org-type">FinderMethods</span>,
                  <span class="org-type">ActiveRecord</span>::<span class="org-type">Relation</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Using FigLeaf</div>
</div>


<p>
In this code, we hide the entire <code>ActiveRecord::Base</code> interface, with
just a few carefully chosen exceptions like <code>#valid?</code> and <code>#save</code>. We
also hide a bunch of the more common class-level methods that
ActiveRecord adds, like <code>.find</code>, <code>.all</code>, and <code>#count</code> by calling
<code>#hide_singleton</code> with the modules which define those methods.
</p>
<p>
Now, if we jump into the console and try to call common ActiveRecord
methods on it, we are denied access:
</p>



<pre class="example">ruby-1.9.2-p0 &gt; Post.find(1)
NoMethodError: private method `find' called for #&lt;Class:0xa1a4a50&gt;
</pre>





<pre class="example">ruby-1.9.2-p0 &gt; Post.new.destroy
NoMethodError: Attempt to call private method
</pre>




<p>
We've explicitly exposed the <code>valid?</code> and <code>#errors</code> methods. Those are
methods which we exercise in our specs, so they are part of the public
contract of <code>Post</code>. We've also decided to expose <code>#save</code> as-is.
</p>
<p>
We still have a some test failures as a result of introducing
<code>FigLeaf</code>. Our <code>blog_integration_spec.rb</code> is now failing because <code>Blog</code>
tries to use <code>Post.all</code> to fetch blog entries.
</p>



<pre class="example">app/models/blog.rb:5:in `public_method': 
  method `all' for class `Class' is private (NameError)
</pre>




<p>
We hesitate to expose <code>Post.all</code>. <code>#all</code> is another "infinite
protocol" method; exposing it as part of our class interface is making
quite a large promise to our collaborators. Instead, we decide to
expose a named scope which gives <code>Blog</code> exactly what it needs, and no
more.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.most_recent</span>(limit=10)
    all(order: <span class="org-string">"pubdate DESC"</span>, limit: limit)
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">A named scope for the most recent posts</div>
</div>


<p>
We then change <code>Blog</code> to use this scope when fetching entries.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(entry_fetcher=<span class="org-type">Post</span>.public_method(<span class="org-constant">:most_recent</span>))
  <span class="org-variable-name">@entry_fetcher</span> = entry_fetcher
<span class="org-keyword">end</span>

</pre>


<div class="caption">Using the Post.most_recent scope</div>
</div>


<p>
The sorting and limiting code in <code>Blog</code> is now redundant:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">entries</span>
  fetch_entries.sort_by{|e| e.pubdate}.reverse.take(10)
<span class="org-keyword">end</span>

</pre>


<div class="caption">The old code for sorting and limiting entries</div>
</div>


<p>
We remove it, confident that our integration tests will let us know if
the change breaks the intended semantics of the method.
</p>



<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">entries</span>
  fetch_entries
<span class="org-keyword">end</span>

</pre>




<p>
All our tests are once again passing. And we now have an extra bulwark
against tight coupling to ActiveRecord APIs.
</p>
<p>
Let me be very clear: I'm not trying to introduce Java-like bondage &amp;
discipline back into a dynamic language. <code>FigLeaf</code> is not intended as
a hammer to keep your coworkers or your library clients in line. It's
not as if that would work, anyway; the strictures that it adds are
easy enough to circumvent.
</p>
<p>
<code>FigLeaf</code>'s intended role is more along the lines of the "rumble
strips" along highways which give you a jolt when you veer off into
the shoulder. It provides a sharp reminder when you've unthinkingly
introduced a new bit of coupling to an interface you are trying to keep
isolated from the rest of the codebase. Then, you can consciously make
the decision whether to make that method public, or find a different
way of going about what you were doing.
</p>

</div>

<div id="outline-container-14_1" class="outline-3">
<h3 id="sec-14_1"><a name="ID-c1ee297f-ea5e-41b2-b507-f698d7808de2" id="ID-c1ee297f-ea5e-41b2-b507-f698d7808de2"></a>Exiting Eden </h3>
<div class="outline-text-3" id="text-14_1">

<p>   The <code>FigLeaf</code> technique demonstrated above is an incremental
   approach to partitioning business logic from the persistence
   mechanism. It's an aid to help you <i>think</i> about the two concerns
   separately, without departing too far from Rails conventions.
</p>
<p>
   If you and your app are ready for a bigger step towards true
   separation of concerns, you may want to look into the Data Mapper
   pattern, as described in "<a href="http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/">Patterns of Enterprise Application Architecture</a>". Note that this is not the same as the <a href="http://datamapper.org">DataMapper</a>
   project. Just as ActiveRecord is an implementation of the Active
   Record pattern in Ruby, so the DataMapper gem is a (partial) implementation
   of the Data Mapper pattern.
</p>
<p>
   The Data Mapper pattern completely separates business models from
   persistence concerns. In it business models have no knowledge of
   how to save themselves; instead, mapper objects map model
   properties to database columns. This separation gives you the
   ability to make substantial changes to your persistence strategy
   without affecting your business logic, and vice-versa.
</p>
<p>
   To my knowledge, there is no complete library implementation of the
   Data Mapper pattern in Ruby. The Ruby DataMapper project does not
   yet enable full separation of business objects and mapper
   objects. That said, it is still a fantastic library which in many
   ways exceeds ActiveRecord. Given the choice, I'll always pick
   DataMapper over ActiveRecord for a new project. The only reason I
   didn't pick it for this text is that I didn't want to introduce too
   many new concepts at one time. And the future of DataMapper is
   bright: the developers are making steady progress towards a 2.0
   release which promises to finally give the Ruby world a
   full-fledged Data Mapper pattern implementation.
</p>
</div>
</div>

</div>

<div id="outline-container-15" class="outline-2">
<h2 id="sec-15"><a name="ID-31ff03d6-2838-4b44-b8fb-d4d4cbbc680e" id="ID-31ff03d6-2838-4b44-b8fb-d4d4cbbc680e"></a>Default content </h2>
<div class="outline-text-2" id="text-15">

<p>  We've decided (for no good reason other than exposition) to give
  <code>Post</code> bodies a default value. Specifically, when we write a new
  entry and fail to provide a body, it should be filled in with the
  text "Nothing to see here".
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">spec/models/post_integration_spec.rb</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  it <span class="org-string">"defaults body to 'Nothing to see here'"</span> <span class="org-keyword">do</span>
    post = make_post(body: <span class="org-string">''</span>)
    post.body.must_equal(<span class="org-string">"Nothing to see here"</span>)
  <span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Specifiying default body content</div>
</div>


<p>
  To make this pass, we define a private method to do the defaulting.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/models/post.rb</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  private

  <span class="org-keyword">def</span> <span class="org-function-name">set_default_body</span>
    <span class="org-keyword">if</span> body.blank?
      <span class="org-variable-name">self</span>.body = <span class="org-string">'Nothing to see here'</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Implementing default content for the post body</div>
</div>


<p>
  Now we just need to hook it into the persistence process. We could
  do this by adding a <code>before_validation</code> hook.
</p>



<pre class="src src-ruby">before_validation <span class="org-constant">:set_default_body</span>

</pre>




<p>
  We <i>could</i> do that. Or… we could treat this class like any other
  class, and override the method we need to modify.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/models/post.rb</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">save</span>(*)
    set_default_body
    <span class="org-keyword">super</span>
  <span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Overriding ActiveRecord#save</div>
</div>


<p>
  This satisfies our needs just as well, and is less "magical". When
  exactly does <code>#set_default_body</code> get called? Why, from the top of
  <code>#save</code>, of course. It's right there in the code.
</p>

</div>

<div id="outline-container-15_1" class="outline-3">
<h3 id="sec-15_1">Navel-gazing objects </h3>
<div class="outline-text-3" id="text-15_1">

<p>   I include this example because of a tendency I've noticed for Rails
   models to overuse hooks. ActiveRecord hooks are a variation on
   the Observer pattern, and the point of Observer is to enable
   <b>other</b> objects to be notified on an object's lifecycle events. Not
   so that the object can stare at itself in the mirror all day.
</p>
<p>
   If we need to intercept an ActiveRecord-provided method, we can
   just intercept it. There are some exceptions, like <code>after_find</code>,
   which let us hook into Rails machinery that might otherwise be
   difficult to override. But for simple cases, we can do the simple
   thing and override the method we want to change. Following a few
   rules will keep us from inadvertently breaking things in the
   process:
</p>
<ol>
<li>Unless you care about the value of arguments, use a single <code>*</code>
      as the method parameters so that the override doesn't interfere
      with the original method's protocol.
</li>
<li>Always call <code>super</code>, unless you are intentionally canceling the
      default behavior.
</li>
<li>Always call <code>super</code> <i>without</i> parentheses, unless you want to
      explicitly change the arguments going to the parent
      method. Leaving out the parentheses tells Ruby to re-use the
      arguments which were passed into the current method.
</li>
<li>Remember to <i>return the result of =super=</i>, by either making
      <code>super</code> the last call in the method, writing <code>return super</code>, or
      saving the return value in a local variable and then returning
      the local at the end. If you need to do some processing after
      the call to <code>super</code>, but you don't want to save the return value
      in a local, you can use <code>#tap</code>:



<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">foo</span>(*)
  <span class="org-keyword">super</span>.tap <span class="org-keyword">do</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">... after-super processing</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


</li>
</ol>


</div>
</div>

</div>

<div id="outline-container-16" class="outline-2">
<h2 id="sec-16"><a name="ID-2d96b566-da6d-473f-8bfb-b4022caa4416" id="ID-2d96b566-da6d-473f-8bfb-b4022caa4416"></a>Exhibits for REST </h2>
<div class="outline-text-2" id="text-16">

<p>  Now that we've got persistence working, let's add a rudimentary
  RESTful API to our blog.
</p>
<p>
  Really RESTful APIs make heavy use of hyperlinking in the resource
  representations they serve. For instance, a JSON representation of a
  blog post might look something like this:
</p>


<div class="listing">

<pre class="src src-js">{
    <span class="org-string">"title"</span>: <span class="org-string">"Flakes"</span>,
    <span class="org-string">"body"</span>: <span class="org-string">"Uh oh, the paint is starting to flake!"</span>,
    <span class="org-string">"links"</span>: [
        {
            <span class="org-string">"rel"</span>: <span class="org-string">"next"</span>,
            <span class="org-string">"href"</span>: <span class="org-string">"http://example.org/blog/posts/3"</span>,
        },
        {
            <span class="org-string">"rel"</span>: <span class="org-string">"prev"</span>,
            <span class="org-string">"href"</span>: <span class="org-string">"http://example.org/blog/posts/1"</span>
        },
        {
            <span class="org-string">"rel"</span>: <span class="org-string">"up"</span>,
            <span class="org-string">"href"</span>: <span class="org-string">"http://example.org/blog/"</span>
        }
    ]
}

</pre>


<div class="caption">Example JSON representation of a blog post</div>
</div>


<p>
  Constructing hyperlinked responses like this one presents us with a
  problem. Normally, when rendering HTML representations, we render
  links to other resources using the various routing helpers (such as
  <code>url_for</code> or <code>#post_url</code>) that Rails provides for us inside of view
  templates. But when we render JSON data, there typically <i>is</i> no
  view context.
</p>
<p>
  For instance, here's an implementation of <code>Post#show</code> that uses
  Rails' <code>#respond_with</code> method:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">show</span>
  <span class="org-variable-name">@post</span> = <span class="org-type">Post</span>.find(params[<span class="org-constant">:id</span>])
  respond_with(<span class="org-variable-name">@post</span>)
<span class="org-keyword">end</span>

</pre>


<div class="caption">Using respond_with to render a post</div>
</div>


<p>
  (If you're looking at <code>Post.find</code> and calling out "<a href="#sec-6-4">Lone Wolf object</a>!", good for you! We'll address that code smell in an upcoming
  section.)
</p>
<p>
  In the absence of a template at <code>[posts/show.json]</code>, a request for a
  post in JSON format will result in call to <code>Post#to_json</code>. 
</p>
<p>
  We'd like <code>Post#to_json</code> to provide a fully hyperlinked JSON
  representation as in the example above. But <code>Post</code> doesn't know
  anything about routing… and that's the way it should be! Once
  again, we need an object to mesh together information from a model
  and information from the framework. Once again, we need an Exhibit.
</p>
<p>
  We could write an exhibit specifically for converting <code>Post</code>
  objects to JSON. But it would be tedious writing exhibits for each
  kind of model that we come up with, and in most cases the logic will
  probably be the same. So instead, we'll write a generic
  <code>LinksExhibit</code> which will work for most objects we throw at it. 
</p>
<p>
  We'll pick three simple link types to start with:
</p>
<ul>
<li>prev
</li>
<li>next
</li>
<li>up
</li>
</ul>


<p>
  These are three of the standard link types <a href="http://www.w3.org/TR/html4/struct/links.html">defined in the HTML4 spec</a>. When we serve a JSON representation of a blog post, we want to
  include a link to the next chronological post, the preceding post,
  and the "parent" resource (<code>up</code>), which is the blog itself.
</p>
<p>
  The <code>LinkExhibit</code> class will take a model object and a template
  object, and adorn the model with <code>next_url</code>, <code>prev_url</code>, and
  <code>up_url</code> methods. It will also augment the <code>#to_json</code> method to
  include a list of links in the <a href="http://tools.ietf.org/html/draft-zyp-json-schema-03#section-6">JSON Hyper-Schema</a> style.
</p>
<p>
  The spec for <code>LinkExhibit</code> isn't that exciting, so I'll omit
  it. Here's the code:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">LinkExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-type">RELATIONS</span> = %w[<span class="org-keyword">next</span> prev up]
  <span class="org-keyword">def</span> <span class="org-function-name">prev_url</span>
    <span class="org-variable-name">@context</span>.url_for(prev)
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">next_url</span>
    <span class="org-variable-name">@context</span>.url_for(<span class="org-variable-name">self</span>.next)
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">up_url</span>
    <span class="org-variable-name">@context</span>.url_for(up)
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">links_hash</span>
    {
      <span class="org-string">"links"</span> =&gt; <span class="org-type">RELATIONS</span>.map { |rel|
        {<span class="org-string">"rel"</span> =&gt; rel, <span class="org-string">"href"</span> =&gt; send(<span class="org-string">"</span><span class="org-variable-name">#{rel}</span><span class="org-string">_url"</span>)}
      }
    }
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">serializable_hash</span>(*args)
    <span class="org-keyword">super</span>.merge(links_hash)
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">to_json</span>(options={})
    serializable_hash(options).to_json
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">LinkExhibit</div>
</div>


<p>
  In order to generate URLs, the <code>LinkExhibit</code> relies on the model
  to respond to three methods, unsurprisingly called <code>#prev</code>, <code>#next</code>,
  and <code>#up</code>. These methods are expected to return the model object
  with the specified relationship to the receiver.
</p>
<p>
  Implementing these methods for <code>Post</code> is straightforward:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">self.first_before</span>(date)
  first(conditions: [<span class="org-string">"pubdate &lt; ?"</span>, date],
        order:      <span class="org-string">"pubdate DESC"</span>)
<span class="org-keyword">end</span>
<span class="org-keyword">def</span> <span class="org-function-name">self.first_after</span>(date)
  first(conditions: [<span class="org-string">"pubdate &gt; ?"</span>, date],
        order:      <span class="org-string">"pubdate ASC"</span>)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

<span class="org-keyword">def</span> <span class="org-function-name">prev</span>
  <span class="org-variable-name">self</span>.class.first_before(pubdate)
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">next</span>
  <span class="org-variable-name">self</span>.class.first_after(pubdate)
<span class="org-keyword">end</span>

<span class="org-keyword">def</span> <span class="org-function-name">up</span>
  blog
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Post navigation methods</div>
</div>


<p>
  Remember, we're avoiding exposing ActiveRecord built-in methods in
  the <code>Post</code> public API, so we have to define explicit class-level
  finder methods to retrieve the posts preceding and following a given
  date. By defining explicit finders (<code>.first_before</code> and
  <code>.first_after</code>) with constrained parameters, we keep the <code>Post</code>
  interface manageable.
</p>
<p>
  For now, since so far we're only exposing <code>Post</code> objects as JSON,
  we make this <code>Exhibit</code> applicable only to <code>Post</code> objects. 
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">LinkExhibit</span> &lt; <span class="org-type">Exhibit</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.applicable_to?</span>(object)
    object.is_a?(<span class="org-type">Post</span>)
  <span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">LinkExhibit applicability</div>
</div>


<p>
  There's no reason it couldn't wrap any other type of object which
  implements <code>#up</code>, <code>#next</code>, and <code>#prev</code>, however.
</p>
<p>
  Now we modify <code>PostsController</code> to expose a <code>#show</code> method.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">PostsController</span> &lt; <span class="org-type">ApplicationController</span>
  respond_to <span class="org-constant">:html</span>, <span class="org-constant">:json</span>
  include <span class="org-type">ExhibitsHelper</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">show</span>
    <span class="org-variable-name">@post</span> = exhibit(<span class="org-type">Post</span>.find_by_id(params[<span class="org-constant">:id</span>]), <span class="org-variable-name">self</span>)
    respond_with(<span class="org-variable-name">@post</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Adding a #show action to the PostsController</div>
</div>


<p>
  We've made a few modifications here. First, we've used <code>respond_to</code>
  to indicate that this controller can serve resources using JSON
  representations. Then we've included the <code>ExhibitsHelper</code> so as to
  give the controller access to <code>#exhibit</code>. Finally, we've implemented
  a <code>#show</code> method which finds the indicated <code>Post</code>, runs it through
  <code>exhibit()</code> to wrap it in all appropriate exhibits, and then uses
  <code>respond_with</code> to hook into Rails' automatic content negotiation
  system.
</p>
<p>
  If you're following along carefully, you might be wondering about
  using <code>ExhibitsHelper#exhibit</code> in a Controller, where before we only
  used it in views. In particular, does it work to pass a controller
  as the <code>context</code> argument to <code>ExhibitsHelper#exhibit</code>?
</p>
<p>
  The <code>context</code> parameter can really be anything which responds to the
  various helper methods used by exhibits. In this case, the only
  exhibit being called upon is <code>LinkExhibit</code>, and the only helper
  method it needs from the <code>context</code> is <code>#url_for</code>. Since <code>#url_for</code>
  is available in controllers as well as in views, everything works
  out.
</p>
<p>
  Well, almost. One of the things <code>LinksExhibit</code> will be calling
  <code>#url_for</code> on is a post's <code>#up</code> relation, which is the global <code>Blog</code>
  instance. As you'll recall, <code>Blog</code> is just an ordinary object, not
  an ActiveRecord. As such, Rails has no idea how to convert it to a
  route in <code>#url_for</code>. Let's fix that.
</p>
<p>
  First, we need to give <code>Blog</code> a model name.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/models/blog.rb    </span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">self.model_name</span>
  <span class="org-type">ActiveModel</span>::<span class="org-type">Name</span>.new(<span class="org-variable-name">self</span>)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Giving Blog an ActiveModel::Name</div>
</div>


<p>
  This is how we tell Rails that <code>Blog</code>'s name is… "Blog". Now that
  Rails officially knows its name, when we pass a <code>Blog</code> object to
  <code>url_for</code>, Rails will look for a <code>blog_url</code> helper. So all we have
  to do now is define that helper.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/controllers/application_controller.rb</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">blog_url</span>(*)
  root_url
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">A routing helper for the Blog model</div>
</div>


<p>
  We're all set up now to serve out JSON versions of blog posts. When
  we create a few posts and then point <code>curl</code> at
  <code>http://localhost:3000/posts/2.json</code>, here's what we get:
</p>


<div class="listing">

<pre class="src src-js">{
  <span class="org-string">"body"</span>: <span class="org-string">"This is the second post. Establishing a pattern here!"</span>, 
  <span class="org-string">"created_at"</span>: <span class="org-string">"2011-11-14T23:53:16Z"</span>, 
  <span class="org-string">"id"</span>: 2, 
  <span class="org-string">"image_url"</span>: <span class="org-string">""</span>, 
  <span class="org-string">"links"</span>: [
      {
          <span class="org-string">"href"</span>: <span class="org-string">"http://localhost:3000/posts/3"</span>, 
          <span class="org-string">"rel"</span>: <span class="org-string">"next"</span>
      }, 
      {
          <span class="org-string">"href"</span>: <span class="org-string">"http://localhost:3000/posts/1"</span>, 
          <span class="org-string">"rel"</span>: <span class="org-string">"prev"</span>
      }, 
      {
          <span class="org-string">"href"</span>: <span class="org-string">"http://localhost:3000/"</span>, 
          <span class="org-string">"rel"</span>: <span class="org-string">"up"</span>
      }
  ], 
  <span class="org-string">"pubdate"</span>: <span class="org-string">"2011-11-14T23:53:16Z"</span>, 
  <span class="org-string">"title"</span>: <span class="org-string">"Second post"</span>, 
  <span class="org-string">"updated_at"</span>: <span class="org-string">"2011-11-14T23:53:16Z"</span>
}

</pre>


<div class="caption">Generated JSON representation of a post</div>
</div>


<p>
  That's just a beginning. I'm sure you can imagine how we might
  expand this out to include a JSON version of the home page, which
  contains links to individual posts, and so on.
</p></div>

</div>

<div id="outline-container-17" class="outline-2">
<h2 id="sec-17">Adding tags </h2>
<div class="outline-text-2" id="text-17">

<p>  OK, now let's add the ability to annotate posts with tags.
</p>
<p>
  What sort of functionality does tagging entail? Let's describe some
  basic use cases:
</p>
<dl>
<dt>Tagging a post</dt><dd>
<p>
     Before saving a new post, the user types some keywords into a
     "tags" field. They might separate the keywords with either spaces,
     commas, or other non-word characters. They might accidentally enter
     a tag twice. When the post is saved, it is displayed with its list
     of tags. The displayed tags are separated by commas, and have had
     any duplicates removed.
</p></dd>
<dt>Seeing a list of all tags</dt><dd>
<p>
     A visitor to the blog sees a list of all unique tags that have been
     applied to any post in the blog sidebar.
</p></dd>
<dt>Filtering by tag</dt><dd>
<p>
     When a visitor clicks on one of the tags, he or she sees a
     "filtered" view of the blog showing only posts which have been
     tagged with that keyword.
</p></dd>
</dl>


<p>
  There are plenty of other ways to use tags, but this is enough to
  get us started.
</p>

</div>

<div id="outline-container-17_1" class="outline-3">
<h3 id="sec-17_1">An Object Model for Tags </h3>
<div class="outline-text-3" id="text-17_1">

<p>   Looking at the list of use cases, it seems clear that we'll need
   some kind of object that represents a list of tags. Let's start
   with that.
</p>



<pre class="src src-ruby">describe <span class="org-type">TagList</span> <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>




<p>
   The most basic behavior we can specify is how the <code>TagList</code> will
   behave with no tags in it.
</p>


<div class="listing">

<pre class="src src-ruby">describe <span class="org-string">"given a blank string"</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span> = <span class="org-type">TagList</span>.new(<span class="org-string">""</span>)
  <span class="org-keyword">end</span>

  it <span class="org-string">"is empty"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.must_be_empty
  <span class="org-keyword">end</span>

  it <span class="org-string">"stringifies to the empty string"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.to_s.must_equal <span class="org-string">""</span>
  <span class="org-keyword">end</span>

  it <span class="org-string">"arrayifies to the empty array"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.to_a.must_equal []
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Specifying TagList behavior with no tags</div>
</div>


<p>
   <code>TagList</code> should assist us in converting from the space- or
   comma-separated strings that users type in.
</p>


<div class="listing">

<pre class="src src-ruby">describe <span class="org-string">"given tags separated by commas or whitespace"</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span> 
    <span class="org-variable-name">@it</span> = <span class="org-type">TagList</span>.new(<span class="org-string">"barley, hops water, yeast"</span>)
  <span class="org-keyword">end</span>

  it <span class="org-string">"is not empty"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.wont_be_empty
  <span class="org-keyword">end</span>

  it <span class="org-string">"stringifies to a comma separated list"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.to_s.must_equal <span class="org-string">"barley, hops, water, yeast"</span>
  <span class="org-keyword">end</span>

  it <span class="org-string">"arrayifies to a list of strings"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.to_a.must_equal %w[barley hops water yeast]
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Specifying tag normalization</div>
</div>


<p>
   It should also eliminate any duplicates.
</p>


<div class="listing">

<pre class="src src-ruby">describe <span class="org-string">"given duplicate tags"</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span> = <span class="org-type">TagList</span>.new(<span class="org-string">"barley, hops, barley"</span>)
  <span class="org-keyword">end</span>

  it <span class="org-string">"eliminates duplicates"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.to_a.must_equal %w(barley hops)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

describe <span class="org-string">"given duplicate mixed case tags"</span> <span class="org-keyword">do</span>
 before <span class="org-keyword">do</span>
   <span class="org-variable-name">@it</span> = <span class="org-type">TagList</span>.new(<span class="org-string">"barley, hops, BarlEy"</span>)
 <span class="org-keyword">end</span>

 it <span class="org-string">"eliminates duplicates ignoring case"</span> <span class="org-keyword">do</span>
   <span class="org-variable-name">@it</span>.to_a.must_equal %w(barley hops)
 <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Specifying TagList duplicate handling</div>
</div>


<p>
   It should normalize the tags to lowercase.
</p>


<div class="listing">

<pre class="src src-ruby">describe <span class="org-string">"given mixed-case tags"</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span> 
    <span class="org-variable-name">@it</span> = <span class="org-type">TagList</span>.new(<span class="org-string">"Barley, hOps, YEAST"</span>)
  <span class="org-keyword">end</span>

  it <span class="org-string">"lowercases the tags"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.to_a.must_equal %w(barley hops yeast)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Specifying tag case normalization</div>
</div>


<p>
   It shouldn't be tripped up by being instantiated with <code>nil</code>.
</p>


<div class="listing">

<pre class="src src-ruby">describe <span class="org-string">"given nil"</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span> 
    <span class="org-variable-name">@it</span> = <span class="org-type">TagList</span>.new(<span class="org-variable-name">nil</span>)
  <span class="org-keyword">end</span>
  it <span class="org-string">"is empty"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span>.must_be_empty
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Specifying TagList behavior when initialized with nil</div>
</div>


<p>
   We'll need to be able to combine tag lists together if we're going
   to show an overview of all tags in use on the blog.
</p>


<div class="listing">

<pre class="src src-ruby">describe <span class="org-string">"#+"</span> <span class="org-keyword">do</span>
  it <span class="org-string">"combines tag lists into one"</span> <span class="org-keyword">do</span>
    result = <span class="org-type">TagList</span>.new(<span class="org-string">"foo, bar"</span>) + <span class="org-type">TagList</span>.new(<span class="org-string">"baz, buz"</span>)
    result.must_equal(<span class="org-type">TagList</span>.new(<span class="org-string">"foo, bar, baz, buz"</span>))
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Spec for combining tag lists</div>
</div>


<p>
   That tag overview should probably be in alphabetical order, so
   we'll want the tag list to be able to return a sorted version of
   itself.
</p>


<div class="listing">

<pre class="src src-ruby">describe <span class="org-string">"#alphabetical"</span> <span class="org-keyword">do</span>
  before <span class="org-keyword">do</span>
    <span class="org-variable-name">@it</span> = <span class="org-type">TagList</span>.new(<span class="org-string">"foo, bar, baz, fuz"</span>)
    <span class="org-variable-name">@result</span> = <span class="org-variable-name">@it</span>.alphabetical
  <span class="org-keyword">end</span>
  it <span class="org-string">"returns the tags in alpha order"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@result</span>.to_a.must_equal %w(bar baz foo fuz)
  <span class="org-keyword">end</span>
  it <span class="org-string">"returns another tag list"</span> <span class="org-keyword">do</span>
    <span class="org-variable-name">@result</span>.must_be_kind_of <span class="org-type">TagList</span>
    <span class="org-variable-name">@result</span>.wont_be_same_as <span class="org-variable-name">@it</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Specifying TagList sorting</div>
</div>


<p>
   Finally, we'll specify a handy conversion method to quickly turn
   things that aren't tag lists into tag lists.
</p>


<div class="listing">

<pre class="src src-ruby">describe <span class="org-string">"TagList()"</span> <span class="org-keyword">do</span>
  describe <span class="org-string">"given a TagList"</span> <span class="org-keyword">do</span>
    it <span class="org-string">"returns the same tag list"</span> <span class="org-keyword">do</span>
      list = <span class="org-type">TagList</span>.new(<span class="org-string">""</span>)
      <span class="org-type">TagList</span>(list).must_be_same_as(list)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
  describe <span class="org-string">"given an array"</span> <span class="org-keyword">do</span>
    before <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span> = <span class="org-type">TagList</span>(%w[foo bar])
    <span class="org-keyword">end</span>
    it <span class="org-string">"returns a tag list"</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span>.must_be_kind_of(<span class="org-type">TagList</span>)
    <span class="org-keyword">end</span>
    it <span class="org-string">"contains the given tags"</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span>.to_a.must_equal(%w[foo bar])
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Specifying tagList conversions</div>
</div>


<p>
   The converter has a similar look and feel to Ruby's built-in
   conversion methods such as <code>String</code>, <code>Array</code>, and <code>Integer</code>.
</p>
<p>
   Implementing these requirements takes considerably less space than
   we needed to spec them out:
</p>


<div class="listing">

<pre class="src src-ruby">require <span class="org-string">'forwardable'</span>
<span class="org-keyword">module</span> <span class="org-type">Conversions</span>
  private
  <span class="org-keyword">def</span> <span class="org-function-name">TagList</span>(value)
    <span class="org-keyword">return</span> value <span class="org-keyword">if</span> value.is_a?(<span class="org-type">TagList</span>)
    <span class="org-type">TagList</span>.new(value)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-keyword">class</span> <span class="org-type">TagList</span>
  extend <span class="org-type">Forwardable</span>
  include <span class="org-type">Enumerable</span>
  attr_reader <span class="org-constant">:tags</span>
  <span class="org-keyword">def</span>_delegators <span class="org-constant">:tags</span>, <span class="org-constant">:empty?</span>, <span class="org-constant">:to_a</span>, <span class="org-constant">:each</span>
  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(tags)
    <span class="org-keyword">case</span> tags
    <span class="org-keyword">when</span> <span class="org-type">Array</span>
      <span class="org-variable-name">@tags</span> = tags
    <span class="org-keyword">else</span>
      <span class="org-variable-name">@tags</span> = tags.to_s.split(<span class="org-string">/\W+/</span>)
    <span class="org-keyword">end</span>
    <span class="org-variable-name">@tags</span>.each(&amp;<span class="org-constant">:downcase!</span>)
    <span class="org-variable-name">@tags</span>.uniq!
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">to_s</span>
    tags.join(<span class="org-string">", "</span>)
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">to_ary</span>
    <span class="org-variable-name">@tags</span>
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">+</span>(other)
    <span class="org-variable-name">self</span>.class.new(to_a + other.to_a)
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">==</span>(other)
    to_a == <span class="org-type">Array</span>(other)
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">alphabetical</span>
    <span class="org-variable-name">self</span>.class.new(tags.sort)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The TagList implementation</div>
</div>


<p>
   Our <code>TagList</code> implementation behaves much like an Array, and in
   fact it is built on top of an internal Array called <code>@tags</code> which
   holds the actual tag strings. Some of its Array-style methods, like
   <code>empty?</code> and <code>:each</code>, don't need any special treatment, so
   <code>TagList</code> passes them straight on to the underlying <code>Array</code> using
   the <code>Forwardable</code> library. Other methods have more tag-specific
   behavior, and are explicitly implemented.
</p>
</div>

</div>

<div id="outline-container-17_2" class="outline-3">
<h3 id="sec-17_2"><code>Conversions</code> </h3>
<div class="outline-text-3" id="text-17_2">

<p>   You may have noticed a funny little module named <code>Conversion</code> in
   the code above. We anticipate that we will want access to the
   <code>TagList()</code> converter method from more than one class or
   module. But adding it to the global namespace would be bad form. So
   instead we define a module to act as a namespace for conversion
   methods. We'll reopen this module and add other converter methods
   to it as our codebase expands. Any class needing access to
   conversions will then be able to include the <code>Conversion</code> module
   and have access to all defined converter methods.
</p>
</div>

</div>

<div id="outline-container-17_3" class="outline-3">
<h3 id="sec-17_3"><a name="ID-8ffd0608-e87e-4272-a937-0750ba9ee307" id="ID-8ffd0608-e87e-4272-a937-0750ba9ee307"></a>Attaching the <code>TagList</code> to a <code>Post</code> </h3>
<div class="outline-text-3" id="text-17_3">


<p>
   Now how do we attach our tag list class to a <code>Post</code> object? We'll
   start out with a naive solution which just serializes the tags to a
   column in the <code>posts</code> table. In order to do that, we create a
   migration for a new <code>tags</code> column.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">AddTagsToPosts</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Migration</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.up</span>
    add_column <span class="org-constant">:posts</span>, <span class="org-constant">:tags</span>, <span class="org-constant">:string</span>
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.down</span>
    remove_column <span class="org-constant">:posts</span>, <span class="org-constant">:tags</span>, <span class="org-constant">:string</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">A migration to add tags to posts</div>
</div>


<p>
   Now we need to tell <code>Post</code> to represent its new <code>tags</code> attribute as
   a <code>TagList</code> instead of as a raw string. We do that using
   ActiveRecord's <a href="http://api.rubyonrails.org/classes/ActiveRecord/Aggregations/ClassMethods.html">composed_of</a> facility:
</p>


<div class="listing">

<pre class="src src-ruby">composed_of <span class="org-constant">:tags</span>, <span class="org-keyword">class</span>_name: <span class="org-string">'TagList'</span>, mapping: %w(tags tags),
                   converter: -&gt;(value) { <span class="org-type">TagList</span>(value) }

</pre>


<div class="caption">Using composed_of to add tags to posts</div>
</div>


<p>
   This incantation tells ActiveRecord to mediate access to the
   <code>tags</code> attribute using a <code>TagList</code>. When a new <code>Post</code> is created,
   ActiveRecord will initialize a <code>TagList</code> object, passing it the raw <code>tags</code>
   data. When it comes time to write the record back to the database,
   ActiveRecord will use the <code>TagList</code>'s own <code>tags</code> attribute as the new value
   of the <code>tags</code> field. Recall that in <code>TagList</code>, <code>#tags</code> is an
   accessor to the underlying Array instance.
</p>
<p>
   The <code>:converter</code> option tells ActiveRecord what to do when some code calls
   <code>post.tags=</code> with a new value. In this case, it will convert the
   given value into a <code>TagList</code>.
</p>
<p>
   <code>TagList</code> represents itself internally using an array, but the
   <code>tags</code> column we just created is a simple string field. In order to
   safely write an array into a string field and get it out again as
   an array, we need to tell ActiveRecord to serialize the field:
</p>



<pre class="src src-ruby">serialize <span class="org-constant">:tags</span>

</pre>




<p>
   Now whenever the <code>tags</code> field is written to the database, the value
   (an array provided by <code>TagList</code>) will first be serialized into YAML
   format. When it is read out again, it will be parsed from the YAML
   back into an array, and the array will be fed back into a new
   <code>TagList</code>.
</p>
<p>
   We could have serialized the <code>TagList</code> object itself to the <code>tags</code>
   column. But serializing application objects to YAML can lead to
   headaches down the road. We have to ensure that the <code>TagList</code> code
   is loaded before accessing that field, something that can be
   surprisingly tricky when running in development mode with Rails'
   class autoloading enabled. And if we ever changed the
   representation of <code>TagList</code>, we could find ourselves in
   versioning hell as we try to load <code>TagList</code> objects which were
   serialized before the change. It's all-around easier to only
   serialize Ruby built-ins like Arrays and Hashes.
</p>
</div>

</div>

<div id="outline-container-17_4" class="outline-3">
<h3 id="sec-17_4">Making <code>Post</code> more tag-aware </h3>
<div class="outline-text-3" id="text-17_4">


<p>
   Now we can attach tags to an individual post, but we also need to
   be able to get a list of all the tags in use, and to find all posts
   with a given tag. In order to drive out this functionality, we
   create a new integration spec suite for the <code>Post</code> class, to
   complement its existing unit-level spec suite.
</p>


<div class="listing">

<pre class="src src-ruby">describe <span class="org-type">Post</span> <span class="org-keyword">do</span>
  include <span class="org-type">SpecHelpers</span>
  before <span class="org-keyword">do</span>
    setup_database
    <span class="org-variable-name">@blog</span> = <span class="org-type">Blog</span>.new
  <span class="org-keyword">end</span>
  after <span class="org-keyword">do</span>
    teardown_database
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">make_post</span>(attrs)
    attrs[<span class="org-constant">:title</span>] ||= <span class="org-string">"Post </span><span class="org-variable-name">#{attrs.hash}</span><span class="org-string">"</span>
    post = <span class="org-variable-name">@blog</span>.new_post(attrs)
    post.publish.must_equal(<span class="org-variable-name">true</span>)
    post
  <span class="org-keyword">end</span>
  describe <span class="org-string">".all_tags_alphabetical"</span> <span class="org-keyword">do</span>
    before <span class="org-keyword">do</span>
      <span class="org-variable-name">@post_tags</span> = [
                    <span class="org-variable-name">nil</span>,        <span class="org-comment-delimiter"># </span><span class="org-comment">make sure nils are handled</span>
                    %w(barley yeast),
                    %w(yeast hops),
                    %w(water)
                   ]
      <span class="org-variable-name">@post_tags</span>.each <span class="org-keyword">do</span> |tags|
        make_post(title: tags.inspect, tags: tags)
      <span class="org-keyword">end</span>
      <span class="org-variable-name">@it</span> = <span class="org-type">Post</span>.all_tags_alphabetical
    <span class="org-keyword">end</span>
    it <span class="org-string">"returns a unique, alphabetized list of all tags"</span> <span class="org-keyword">do</span>
      <span class="org-variable-name">@it</span>.must_equal <span class="org-type">TagList</span>(%w(barley hops water yeast))
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
  describe <span class="org-string">".tagged"</span> <span class="org-keyword">do</span>
    it <span class="org-string">"filters the collection by tag"</span> <span class="org-keyword">do</span>
      duck  = make_post tags: %w[billed feathered]
      robin = make_post tags: %w[reddish feathered]
      fox   = make_post tags: %w[reddish furred]
      platypus = make_post tags: %w[billed furred]

      reddish = <span class="org-type">Post</span>.tagged(<span class="org-string">"reddish"</span>)
      reddish.size.must_equal 2
      reddish.must_include(robin)
      reddish.must_include(fox)
      furred = <span class="org-type">Post</span>.tagged(<span class="org-string">"furred"</span>)
      furred.size.must_equal 2
      furred.must_include(fox)
      furred.must_include(platypus)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">An integration test for tags</div>
</div>


<p>
These new specs are satisfied with a trio of new class-level methods
on <code>Post</code>:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span>
  <span class="org-type">LIMIT_DEFAULT</span>=10
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.most_recent</span>(limit=<span class="org-type">LIMIT_DEFAULT</span>)
    order(<span class="org-string">"pubdate DESC"</span>).limit(limit)
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">self.all_tags_alphabetical</span>
    all_tags.alphabetical
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">self.all_tags</span>
    except(<span class="org-constant">:limit</span>).map(&amp;<span class="org-constant">:tags</span>).reduce(<span class="org-type">TagList</span>.new([]), &amp;<span class="org-constant">:+</span>)
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Adding tag query methods to Post</div>
</div>


<p>
That last method is worth a second look. Remember that we defined the
<code>+</code> operator on <code>TagList</code> to combine two tag lists into one. That
comes in handy now, as we are able to use <code>#reduce</code> to very succinctly
combine an arbitrary number of tag lists into one master list.
</p>
<p>
Oh, and if you're wondering about <code>except(:limit)</code>, that's a bit of a
kludge. In our master layout, in the blog sidebar, we want to show
<i>all</i> tags in the database even when only a subset of posts (say, the
ten most recent) are currently being shown. <code>except(:limit)</code> simply
throws away any <code>LIMIT</code> clause in the current scope, so as to retrieve
the tags of all posts in the database.
</p>
</div>

</div>

<div id="outline-container-17_5" class="outline-3">
<h3 id="sec-17_5">Accepting and displaying tags </h3>
<div class="outline-text-3" id="text-17_5">


<p>
In order to add tags to posts we need a place to enter them. We add a
new field to the "new post" form:
</p>


<div class="listing">

<pre class="src src-html">&lt;%= label :tags, <span class="org-string">"Tags:"</span> %&gt;
&lt;%= f.text_field :tags %&gt;

</pre>


<div class="caption">Adding tags to the new post form</div>
</div>


<p>
We also update the blog entry partial to display any tags that are
associated with a blog post.
</p>


<div class="listing">

<pre class="src src-html">&lt;<span class="org-function-name">p</span> <span class="org-variable-name">class</span>=<span class="org-string">"entry_tags"</span>&gt;Tags: 
  &lt;<span class="org-function-name">span</span> <span class="org-variable-name">class</span>=<span class="org-string">"tags"</span>&gt;&lt;%= entry.tags %&gt;&lt;/<span class="org-function-name">span</span>&gt;
&lt;/<span class="org-function-name">p</span>&gt;

</pre>


<div class="caption">Adding tags to the entry partial</div>
</div>


<p>
Remember that <code>entry.tags</code> will return a <code>TagList</code>, and <code>TagList.to_s</code>
is defined to format the tags separated by commas. So this should look
fine when rendered.
</p>
<p>
We also want to show a top-level list of tags that shows all tags in
use on the blog. We add a new section to the sidebar in the main
application layout:
</p>


<div class="listing">

<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">h4</span>&gt;<span class="org-underline">Tags</span>&lt;/<span class="org-function-name">h4</span>&gt;
&lt;<span class="org-function-name">nav</span>&gt;
  &lt;<span class="org-function-name">ul</span>&gt;
    &lt;%= render partial: <span class="org-string">"/tags/tag_item"</span>,
               collection: @blog.tags %&gt;
  &lt;/<span class="org-function-name">ul</span>&gt;
&lt;/<span class="org-function-name">nav</span>&gt;
<span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>

</pre>


<div class="caption">Adding tags to the main layout</div>
</div>


<p>
The <code>tags/tag_item</code> partial is just a thin wrapper around the <code>tags/tag</code>
partial:
</p>



<pre class="src src-html">&lt;<span class="org-function-name">li</span>&gt;&lt;%= render partial: <span class="org-string">"/tags/tag"</span>, object: tag_item %&gt;&lt;/<span class="org-function-name">li</span>&gt;

</pre>




</div>

</div>

<div id="outline-container-17_6" class="outline-3">
<h3 id="sec-17_6"><a name="ID-4c63bc97-f117-4a2b-ade5-8cda9d707e08" id="ID-4c63bc97-f117-4a2b-ade5-8cda9d707e08"></a>Filtering posts by tag </h3>
<div class="outline-text-3" id="text-17_6">


<p>
The <code>tags/tag</code> partial renders a link to a tag-filtered view of the
blog:
</p>



<pre class="src src-html">&lt;%= link_to tag.to_s, root_path(tag: tag.to_s) %&gt;

</pre>




<p>
To make this work, we make a small addition to the <code>BlogController</code>.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">BlogController</span> &lt; <span class="org-type">ApplicationController</span>
  <span class="org-keyword">def</span> <span class="org-function-name">index</span>
    <span class="org-keyword">if</span> params[<span class="org-constant">:tag</span>].present?
      <span class="org-variable-name">@blog</span> = <span class="org-variable-name">@blog</span>.filter_by_tag(params[<span class="org-constant">:tag</span>])
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Enabling the front page to be filtered by tag</div>
</div>


<p>
If a <code>:tag</code> parameter is supplied to the index action, it puts a
filtered version of the blog into <code>@blog</code>. We define
<code>Blog#filter_by_tag</code> as follows:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">filter_by_tag</span>(tag)
  <span class="org-type">FilteredBlog</span>.new(<span class="org-variable-name">self</span>, tag)
<span class="org-keyword">end</span>

</pre>


<div class="caption">Blog#filter_by_tag</div>
</div>


<p>
Then we define <code>FilteredBlog</code> as a decorator which wraps the
main <code>Blog</code> instance and filters its <code>#entries</code> by a given tag.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Blog</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">class</span> <span class="org-type">FilteredBlog</span> &lt; <span class="org-type">DelegateClass</span>(<span class="org-type">Blog</span>)
    include ::<span class="org-type">Conversions</span>
    <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(blog, tag)
      <span class="org-keyword">super</span>(blog)
      <span class="org-variable-name">@tag</span> = tag
    <span class="org-keyword">end</span>
    <span class="org-keyword">def</span> <span class="org-function-name">entries</span>
      <span class="org-type">Taggable</span>(<span class="org-keyword">super</span>).tagged(<span class="org-variable-name">@tag</span>)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The FilteredBlog decorator</div>
</div>


<p>
This class is an implementation detail of <code>Blog</code>, and will not be used
by any other code, so we just nest it inside the <code>Blog</code> class rather
than giving it its own file.
</p>
<p>
Wondering about the <code>DelegateClass(Blog)</code> bit? That's a very close
relative to <code>SimpleDelegator</code>, which we've already
used. <code>SimpleDelegator</code> is a generic delegator base class which can
work when wrapped around any underlying
object. <code>DelegateClass(klass)</code>, on the other hand, generates a
delegator base class customized specifically for wrapping objects of
the passed <code>klass</code>. In practice, it doesn't make a huge difference;
but delegates based on <code>DelegateClass</code> may be a little more efficient
since they don't have to use <code>#method_missing</code> to intercept method
calls. There are some other minor differences; for instance, the class
<code>DelegateClass()</code> generates responds to <code>.public_instance_methods</code>
with a more accurate list than the <code>SimpleDelegator</code> version. Since we
know that <code>FilteredBlog</code> will always be wrapping a <code>Blog</code> object, we can
use <code>DelegateClass()</code> instead of <code>SimpleDelegator</code>.
</p>
<p>
At this point, we have a bare-bones but still useful post-tagging
functionality. We can add tags to a post, see the keywords a post has
been tagged with, and see a list of all tags on the front page. And
when we click on one of the tags, we are presented with a subset of
posts which are tagged with that keyword.
</p>


<div class="figure">
  <img src="./images/tags.png" alt="Filtering by tag">
  <div class="caption">Filtering by tag</div>
</div>


</div>

</div>

<div id="outline-container-17_7" class="outline-3">
<h3 id="sec-17_7"><a name="ID-c3297af8-6225-4e57-b5f2-0521dcba436c" id="ID-c3297af8-6225-4e57-b5f2-0521dcba436c"></a>Extracting a Taggable role </h3>
<div class="outline-text-3" id="text-17_7">


<p>
<code>:composed_of</code> enabled us to keep most of the tagging code inside of
<code>TagList</code> and out of <code>Post</code>. But there is still a fair amount of
tagging-specific code in the <code>Post</code> class. This is troubling for two
reasons:
</p>
<ol>
<li>Right now it's just tagging. But what about when we add other
   functionality, like post revision control, or authorization? Will
   every new feature that we add result in adding another dozen lines
   of code to <code>Post</code>? What ever happened to the Single Responsibility
   Principle?
</li>
<li>What if we decide we want to tag entities other than posts? Will we
   be duplicating this code for every class that can be tagged?
</li>
</ol>


<p>
We might try to pull the tagging "facet" into a module. For each new
feature, we could include a new module in <code>Post</code>:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Post</span>
  include <span class="org-type">Taggable</span>
  include <span class="org-type">RevisionControlled</span>
  include <span class="org-type">Permissible</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">etc...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">A Taggable module</div>
</div>


<p>
And in fact, this is how many Rails projects address the issue of
ever-expanding class files. But does this really address the root
problem? We're still adding more and more responsibilities to <code>Post</code>
objects. The only difference is, now it's harder to find the
definition of any given <code>Post</code> method (or validation, or
before-filter…) because it might be in any of a half-dozen different
files.
</p>

</div>

<div id="outline-container-17_7_1" class="outline-4">
<h4 id="sec-17_7_1">Using a mixin module </h4>
<div class="outline-text-4" id="text-17_7_1">


<p>
Instead of using modules included in the class, let's see if we can
extract out the "taggable" responsibility in a way that keeps it as
orthogonal as possible to the item being tagged.
</p>
<p>
We'll start by defining a <code>TaggableRecord</code> mixin module. This module
will represent the taggable "role" that a model object may
assume. When injected into an object using <code>Object#extend</code>, this
module will intercept the <code>#tags</code> and <code>#tags=</code> methods.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">TaggableRecord</span>
  <span class="org-keyword">def</span> <span class="org-function-name">tags</span>
    _tag_list
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">tags=</span>(new_tags)
    <span class="org-variable-name">@_tag_list</span> = <span class="org-type">TagList</span>.new(new_tags)
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The TaggableRecord module</div>
</div>


<p>
This module will also intercept calls to <code>#save</code>. Before calling the
object's original <code>#save</code> method, <code>TaggableRecord</code> updates the
object's <code>tags</code> field. It uses the ActiveRecord-provided <code>#[]=</code> method
to write the new <code>tags</code> value so as to avoid calling the
<code>TaggableRecord#tags=</code> method.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">TaggableRecord</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">save</span>(*, &amp;block)
    <span class="org-variable-name">self</span>[<span class="org-constant">:tags</span>] = _tag_list.to_a
    <span class="org-keyword">super</span>
  <span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Overriding ActiveRecord#save in TaggableRecord</div>
</div>


<p>
<code>TaggableRecord</code> also uses the ActiveRecord-provided <code>#[]</code> to
initially load up its <code>TagList</code> with values from the original record.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">TaggableRecord</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  private

  <span class="org-keyword">def</span> <span class="org-function-name">_tag_list</span>
    <span class="org-variable-name">@_tag_list</span> ||= <span class="org-type">TagList</span>.new(<span class="org-variable-name">self</span>[<span class="org-constant">:tags</span>])
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">TagList initialization in TaggableRecord</div>
</div>


<p>
This module will be included into objects which already have their own
state and methods. So we prefix our private instance variable and
method names with an underscore to make naming collisions less likely.
</p>
<p>
Since up until now we've used external decorators
(e.g. <code>SimpleDelegator</code>) to adorn objects with new functionality, you
may be wondering why we're using a module now. In this case, we need
the tight integration that only a module can give us. For instance, by
intercepting <code>#save</code> within the object, rather than in an outside
wrapper, we also implicitly intercept any other methods which use
<code>#save</code>—such as <code>#create</code>. In this case, that's exactly the behavior
we want.
</p>
<p>
(If you're still not clear on the trade-offs between decoration and
dynamic module extension, I've included a longer discussion in
<a href="#sec-25">Appendix C</a>.)
</p>
</div>

</div>

<div id="outline-container-17_7_2" class="outline-4">
<h4 id="sec-17_7_2">Class-level <code>Taggable</code> methods </h4>
<div class="outline-text-4" id="text-17_7_2">


<p>
That takes care of the instance-level functionality; but a lot of the
tagging-related code on <code>Post</code> is at the class level. We define a
module for that next:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">TaggableRelation</span>
  <span class="org-keyword">def</span> <span class="org-function-name">all_tags_alphabetical</span>
    all_tags.alphabetical
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">all_tags</span>
    except(<span class="org-constant">:limit</span>).map{|e| <span class="org-type">Taggable</span>(e).tags}.reduce(<span class="org-type">TagList</span>.new([]), &amp;<span class="org-constant">:+</span>)
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">tagged</span>(tag)
    select{|e| <span class="org-type">Taggable</span>(e).tags.include?(tag)}
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The TaggableRelation module</div>
</div>


<p>
These are pretty much exactly as they were in <code>Post</code>.
</p>
<p>
As we decided earlier, we don't want to have <code>Post</code> always carrying
this tagging baggage even when it isn't needed. We need a way to
quickly apply the taggable "hat" to objects on a just-in-time
basis. For that we define another global conversion method:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">Taggable</span>(item)
  <span class="org-keyword">case</span> item
  <span class="org-keyword">when</span> ::<span class="org-type">Class</span>, ::<span class="org-type">ActiveRecord</span>::<span class="org-type">Relation</span>
    item.extend(::<span class="org-type">TaggableRelation</span>)
  <span class="org-keyword">else</span> 
    item.extend(::<span class="org-type">TaggableRecord</span>)  
  <span class="org-keyword">end</span>
  item.extend(::<span class="org-type">Taggable</span>)
<span class="org-keyword">end</span>

</pre>


<div class="caption">A Taggable() conversion method</div>
</div>


<p>
This conversion method lets us apply tagging functionality to record
instances, relations, and classes by simply calling
<code>Taggable(object_to_be_made_taggable)</code>.
</p>
</div>

</div>

<div id="outline-container-17_7_3" class="outline-4">
<h4 id="sec-17_7_3">Divesting <code>Post</code> of tagging </h4>
<div class="outline-text-4" id="text-17_7_3">


<p>
We are now able to remove a bunch of code from <code>Post</code>:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
composed_of <span class="org-constant">:tags</span>, <span class="org-keyword">class</span>_name: <span class="org-string">'TagList'</span>, mapping: %w(tags tags),
                   converter: -&gt;(value) { <span class="org-type">TagList</span>(value) }
serialize <span class="org-constant">:tags</span>
<span class="org-keyword">def</span> <span class="org-function-name">self.all_tags_alphabetical</span>
  all_tags.alphabetical
<span class="org-keyword">end</span>
<span class="org-keyword">def</span> <span class="org-function-name">self.all_tags</span>
  except(<span class="org-constant">:limit</span>).map(&amp;<span class="org-constant">:tags</span>).reduce(<span class="org-type">TagList</span>.new([]), &amp;<span class="org-constant">:+</span>)
<span class="org-keyword">end</span>
<span class="org-keyword">def</span> <span class="org-function-name">self.tagged</span>(tag)
  select{|e| e.tags.include?(tag)}
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Cleaning tag-related code from the Post class</div>
</div>


<p>
In fact, the only tagging-related code we can't get rid of is the line
that tells ActiveRecord to serialize the <code>tags</code> field:
</p>



<pre class="src src-ruby">serialize <span class="org-constant">:tags</span>

</pre>




</div>

</div>

<div id="outline-container-17_7_4" class="outline-4">
<h4 id="sec-17_7_4">Applying the <code>Taggable</code> role </h4>
<div class="outline-text-4" id="text-17_7_4">


<p>
Now we walk through the codebase, applying the <code>Taggable()</code> role
anywhere we need to treat a <code>Post</code> or a collection of posts as
taggable objects. For instance, in the <code>_entry</code> partial we apply it
before rendering the tag list:
</p>


<div class="listing">

<pre class="src src-html">&lt;<span class="org-function-name">article</span>&gt;
  &lt;<span class="org-function-name">header</span>&gt;
    &lt;<span class="org-function-name">p</span>&gt;&lt;<span class="org-function-name">time</span> <span class="org-variable-name">pubdate</span>=<span class="org-string">"pubdate"</span>&gt;&lt;%= entry.pubdate %&gt;&lt;/<span class="org-function-name">time</span>&gt;&lt;/<span class="org-function-name">p</span>&gt;
    &lt;<span class="org-function-name">h3</span>&gt;&lt;%= entry.title %&gt;&lt;/<span class="org-function-name">h3</span>&gt;
    &lt;<span class="org-function-name">p</span> <span class="org-variable-name">class</span>=<span class="org-string">"entry_tags"</span>&gt;Tags: 
      &lt;<span class="org-function-name">span</span> <span class="org-variable-name">class</span>=<span class="org-string">"tags"</span>&gt;&lt;%= Taggable(entry).tags %&gt;&lt;/<span class="org-function-name">span</span>&gt;
    &lt;/<span class="org-function-name">p</span>&gt;
  &lt;/<span class="org-function-name">header</span>&gt;
  &lt;%= entry.render_body %&gt;
&lt;/<span class="org-function-name">article</span>&gt;

</pre>


<div class="caption">Applying the Taggable role in a template</div>
</div>


<p>
And in the <code>PostsController</code> we apply it to a post which is about to
be saved, so that any <code>tags</code> which were written to the new post are
correctly serialized.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">create</span>
  <span class="org-variable-name">@post</span> = <span class="org-type">Taggable</span>(<span class="org-variable-name">@blog</span>.new_post(params[<span class="org-constant">:post</span>]))
  <span class="org-keyword">if</span> <span class="org-variable-name">@post</span>.publish
    redirect_to root_path, notice: <span class="org-string">"Post added!"</span>
  <span class="org-keyword">else</span>
    render <span class="org-string">"new"</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Appling the Taggable role in the PostsController</div>
</div>


<p>
Note that in wherever we use <code>Taggable()</code>, we use its return value as
the "taggable" entity. We do this even though we know that <code>Taggable()</code>
extends its argument with a module, altering it in place. We could just as
well do this:
</p>



<pre class="src src-ruby"><span class="org-type">Taggable</span>(some_object)
some_object.tags = <span class="org-string">"foo, bar"</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>




<p>
Why use the return value? We do it for consistency and implementation
hiding. We happen to know (because we just wrote it) that <code>Taggable()</code>
actually modifies its argument in place. But in other cases, we wrote
conversion methods which don't modify their argument; instead, they
return a wrapped object or a brand new object.
</p>
<p>
By consistently using the return value of conversion methods
throughout our codebase—whether we need to or not—we free
ourselves from the mental burden of having to remember how a
particular conversion works. Not only that, but we future-proof our
code this way: if, at some point, we decide we <i>do</i> want to use a
decorator instead of a module, we can alter the implementation of
<code>Taggable()</code> and know that it will continue to work wherever we've
used it.
</p>

</div>
</div>

</div>

<div id="outline-container-17_8" class="outline-3">
<h3 id="sec-17_8"><a name="ID-f3312547-511b-4ce5-be7c-19baba2f20a0" id="ID-f3312547-511b-4ce5-be7c-19baba2f20a0"></a>Refactoring to a separate ActiveRecord model </h3>
<div class="outline-text-3" id="text-17_8">

<p>  We don't have to spend much time with our new tagging system to
  realize that our naive implementation is grossly inefficient at
  scale. To search across or list all tags in the blog, we are forced
  to load every single blog entry. If this blog engine is going to
  compete with WordPress it's definitely going to need a faster tags
  implementation.
</p>
<p>
  We decide to give tags some database tables of their own. In order
  to keep tags nice and generic, we'll create a <code>tags</code> table which
  stores the actual tag keyword, and an <code>item_tags</code> table which will
  polymorphically map from tags to taggable items (such as posts).
</p>
<p>
  We write a migration that creates the new tables, migrates the old
  tags data to the new tables, and then removes the <code>tags</code> field from
  the <code>posts</code> table.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">AddTagTables</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Migration</span>
  <span class="org-keyword">class</span> <span class="org-type">Post</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>; <span class="org-keyword">end</span>
  <span class="org-keyword">class</span> <span class="org-type">Tag</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>; <span class="org-keyword">end</span>
  <span class="org-keyword">class</span> <span class="org-type">ItemTag</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>
    belongs_to <span class="org-constant">:tag</span>
    belongs_to <span class="org-constant">:item</span>, polymorphic: <span class="org-variable-name">true</span>
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.up</span>
    create_table <span class="org-constant">:tags</span> <span class="org-keyword">do</span> |t|
      t.string <span class="org-constant">:name</span>
      t.timestamps
    <span class="org-keyword">end</span>
    create_table <span class="org-constant">:item_tags</span> <span class="org-keyword">do</span> |t|
      t.integer <span class="org-constant">:item_id</span>
      t.string  <span class="org-constant">:item_type</span>
      t.integer <span class="org-constant">:tag_id</span>
    <span class="org-keyword">end</span>
    <span class="org-type">Post</span>.find_each <span class="org-keyword">do</span> |post|
      <span class="org-type">Array</span>(post.tags).each <span class="org-keyword">do</span> |tag|
        tag_record = <span class="org-type">Tag</span>.create!(name: tag.to_s)
        <span class="org-type">ItemTag</span>.create!(item: post, tag: tag_record)
      <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>
    remove_column <span class="org-constant">:posts</span>, <span class="org-constant">:tags</span>
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.down</span>
    <span class="org-keyword">raise</span> <span class="org-type">ActiveRecord</span>::<span class="org-type">IrreversibleMigration</span>, <span class="org-string">"Cannot be reversed"</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Migrating tag attributes to a "tags" table</div>
</div>


<p>
Note that we define any ActiveRecord models we need for the data
migration within the context of the migration. This will enable the
migration to continue working even if we change or remove those models
in future revisions.
</p>

</div>

<div id="outline-container-17_8_1" class="outline-4">
<h4 id="sec-17_8_1"><a name="ID-fe167dc1-3e0b-4be7-9768-0c0cd79241a0" id="ID-fe167dc1-3e0b-4be7-9768-0c0cd79241a0"></a>Using ActiveRecord as a Row Data Gateway </h4>
<div class="outline-text-4" id="text-17_8_1">


<p>
Our new tables are strictly implementation details; we still intend to
work with tags in terms of our tried-and-true <code>TagList</code> class. We
define some bare-bones ActiveRecord models for the new tables, with
no business logic and just enough code to set up their
relationships. In order to underscore the fact that these are not
full-fledged business models, we put the files in a new directory
called <code>app/data</code>.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/data/tag.rb</span>
<span class="org-keyword">class</span> <span class="org-type">Tag</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>
  has_many <span class="org-constant">:item_tags</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The Tag class</div>
</div>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/data/tag.rb</span>
<span class="org-keyword">class</span> <span class="org-type">ItemTag</span> &lt; <span class="org-type">ActiveRecord</span>::<span class="org-type">Base</span>
  belongs_to <span class="org-constant">:tag</span>
  belongs_to <span class="org-constant">:item</span>, polymorphic: <span class="org-variable-name">true</span>
  delegate <span class="org-constant">:name</span>, to: <span class="org-constant">:tag</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The ItemTag join model</div>
</div>


<p>
While technically ActiveRecord classes, we'll use these classes more
like <a href="http://martinfowler.com/eaaCatalog/rowDataGateway.html">Row Data Gateways</a> - thin wrappers around a row of data.
</p>
<p>
Before we forget, we remove the one remaining vestige of "tagginess"
from <code>Post</code>:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
serialize <span class="org-constant">:tags</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>




<p>
Now <code>Post</code> contains no tag-related code whatsoever.
</p>
</div>

</div>

<div id="outline-container-17_8_2" class="outline-4">
<h4 id="sec-17_8_2">Constructing a <code>TagStorage</code> repository </h4>
<div class="outline-text-4" id="text-17_8_2">


<p>
Currently, our <code>TaggableRecord</code> role module uses a record's
<code>#[]=/=#[]=</code> methods to write tags into the record. That won't do
anymore. We rewrite <code>TaggableRecord</code> to use a "tag storage" object for
reading and writing tags instead.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">TaggableRecord</span>
  attr_accessor <span class="org-constant">:_tag_storage</span>
  <span class="org-keyword">def</span> <span class="org-function-name">tags</span>
    <span class="org-variable-name">@_tag_list</span> ||= <span class="org-type">TagList</span>.new(_tag_storage.load)
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">tags=</span>(new_tags)
    <span class="org-variable-name">@_tag_list</span> = <span class="org-type">TagList</span>.new(new_tags)
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">save</span>(*, &amp;block)
    <span class="org-keyword">super</span>.tap <span class="org-keyword">do</span> |successful|
      <span class="org-keyword">if</span> successful
        _tag_storage.store(tags.to_a)
      <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Rewriting TaggableRecord to use a tag storage object</div>
</div>



<p>
What's a tag storage object? Defining it is our next job. From our
definition in <code>TaggableRecord</code>, we know it needs to respond to two
methods: <code>#load</code> and <code>#store</code>.
</p>
<p>
First of all, it will keep a reference to the item which it is storing
tags for.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">TagStorage</span>
  attr_reader <span class="org-constant">:item</span>
  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(item)
    <span class="org-variable-name">@item</span> = item
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Beginning the TagStorage class</div>
</div>


<p>
Loading tags will map across an <code>ItemTag</code> collection to get the names
of all the tags applied to the item.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">load</span>
  item_tags.map(&amp;<span class="org-constant">:name</span>)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">TagStorage#load</div>
</div>


<p>
Item tags is simply a memoizing layer on top of <code>#fetch_item_tags</code>:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">item_tags</span>
  <span class="org-variable-name">@item_tags</span> ||= fetch_item_tags
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">TagStorage#item_tags</div>
</div>


<p>
<code>#fetch_item_tags</code> is where the actual tag loading happens. We create
a scope which encompasses all <code>ItemTag</code> records which have a type and
ID corresponding to the item being tagged. We include the <code>tags</code> table
in the query, since we know we'll be needing the tag names.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">fetch_item_tags</span>
  <span class="org-type">ItemTag</span>.where(item_type: item.class, item_id: item.id).includes(<span class="org-constant">:tag</span>)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">TagStorafe#fetch_item_tags</div>
</div>


<p>
That takes care of loading tags. Storing tags is a little more
involved. Our <code>#store</code> method must find the difference between the
tags currently stored for the item, and the tags that have been set using
the item's <code>#tags</code> attribute. Then it must create and delete <code>ItemTag</code>
and <code>Tag</code> records accordingly.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">store</span>(tags)
  current_tags  = item_tags.map(&amp;<span class="org-constant">:name</span>)
  new_tags      = <span class="org-type">Array</span>(tags)
  remove_tags(current_tags, new_tags)
  add_tags(current_tags, new_tags)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">TagStorage#store</div>
</div>


<p>
<code>#add_tags</code> determines which tags have been added, and creates the
needed <code>ItemTag</code> mappings:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">add_tags</span>(current_tags, new_tags)
  new_tags = new_tags - current_tags
  new_tags.each <span class="org-keyword">do</span> |tag|
    item_tags &lt;&lt; <span class="org-type">ItemTag</span>.create!(item_tag_attributes(tag))
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">TagStorage#add_tags</div>
</div>


<p>
It uses a helper method <code>#item_tag_attributes</code> to generate the
attributes for new <code>ItemTag</code> records:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">item_tag_attributes</span>(t)
  tag = <span class="org-type">Tag</span>.find_or_create_by_name(t)
  {item: item, tag: tag}
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">TagStorage#item_tag_attributes</div>
</div>


<p>
Finally, <code>#remove_tags</code> goes through the cached list of item tag
mappings, and removes any that are no longer needed from both the
cached list and the database.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">remove_tags</span>(current_tags, new_tags)
  removed_tags = current_tags - new_tags
  item_tags.each <span class="org-keyword">do</span> |item_tag|
    <span class="org-keyword">if</span> removed_tags.include?(item_tag.name)
      item_tag.delete
      item_tags.delete(item_tag)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">TagStorage#remove_tags</div>
</div>


<p>
Whew! That was a fair amount of code. But now we have a way to store
tags in the database for arbitrary objects: all we need is a type and
an id, and we can store tags against it.
</p>
</div>

</div>

<div id="outline-container-17_8_3" class="outline-4">
<h4 id="sec-17_8_3">Putting on the finishing touches </h4>
<div class="outline-text-4" id="text-17_8_3">


<p>
Since <code>TaggableRecord</code> now needs a <code>TagStorage</code> object, we have to
update our <code>Taggable</code> conversion.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">Taggable</span>(item, tag_storage=::<span class="org-type">TagStorage</span>.new(item))
  <span class="org-keyword">return</span> item <span class="org-keyword">if</span> item.kind_of?(::<span class="org-type">Taggable</span>)
  item.extend(::<span class="org-type">Taggable</span>)
  <span class="org-keyword">case</span> item
  <span class="org-keyword">when</span> ::<span class="org-type">Class</span>, ::<span class="org-type">ActiveRecord</span>::<span class="org-type">Relation</span>
    item.extend(::<span class="org-type">TaggableRelation</span>)
  <span class="org-keyword">else</span> 
    item.extend(::<span class="org-type">TaggableRecord</span>)
    item._tag_storage = tag_storage
  <span class="org-keyword">end</span>
  item
<span class="org-keyword">end</span>

</pre>


<div class="caption">Updating Taggable() to use TagStorage</div>
</div>


<p>
The <code>Taggable()</code> code reminds us: what about wrapping classes and
relations? How does that change now that we are storing tags in the
database?
</p>
<p>
The <code>#all_tags</code> accessor doesn't change much, except now it's
querying <code>ItemTag</code> instead of the current class/relation:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">all_tags</span>
  <span class="org-type">TagList</span>(<span class="org-type">ItemTag</span>.where(item_type: klass).includes(<span class="org-constant">:tag</span>).map(&amp;<span class="org-constant">:name</span>))
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Updating TaggableRelation#all_tags to query ItemTag</div>
</div>


<p>
Now that tagged items are no longer expected to have a <code>tags</code> field,
we need to wrap the underlying <code>#new</code> method in one which understands
and handles the <code>tags</code> parameter. Otherwise if we tried to create
e.g. a new <code>Post</code> with parameters which included <code>tags</code>, it would
complain that no such attribute exists.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">new</span>(attrs={}, &amp;block)
  attrs = attrs.dup
  tags  = attrs.delete(<span class="org-constant">:tags</span>)
  <span class="org-type">Taggable</span>(<span class="org-keyword">super</span>(attrs, &amp;block)).tap <span class="org-keyword">do</span> |item|
    item.tags = tags
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Implementing TaggableRelation#new to handle "tags" attribute</div>
</div>


<p>
The last <code>TaggableRelation</code> method we need to update is the one that
enables us to get a list of all items tagged with a particular
keyword. This method turns out to be a bit of a doozy.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">tagged</span>(tag)
  joins(<span class="org-string">"JOIN item_tags ON item_tags.item_id = </span><span class="org-variable-name">#{table_name}</span><span class="org-string">.id AND "</span> \
        <span class="org-string">"item_tags.item_type = \"</span><span class="org-variable-name">#{klass.name}</span><span class="org-string">\""</span>).
    joins(<span class="org-string">"JOIN tags ON item_tags.tag_id = tags.id"</span>).
    where(<span class="org-string">"tags.name = ?"</span>, tag)
<span class="org-keyword">end</span>

</pre>


<div class="caption">Updating TaggableRelation#tagged</div>
</div>


<p>
I will concede that this is a bit nuts. In trying to avoid putting any
requirements whatsoever on the tagged classes—enabling classes like
<code>Post</code> to be blissfully unaware that tagging even exists—we've been
forced to assemble a pretty gnarly query. Simply requiring classes
which may be tagged to declare a <code>has_many :through</code> relationship to
the <code>tags</code> table would have vastly simplified this.
</p>
<p>
Sometimes going "off the rails" results in pain like this. Is it worth
it? That's a decision only you and your team can make, in the context
of a given project.
</p>
<p>
We've now migrated tag storage from a per-record field to a set of
separate tables. While we wrote a fair amount of new code for this,
it's worth reflecting on what we <b>didn't</b> change:
</p>
<ol>
<li>We didn't change any of the views.
</li>
<li>We didn't change any of the controllers.
</li>
<li>We didn't change any of the helpers.
</li>
<li>We didn't change the Blog model.
</li>
<li>We removed one line from <code>Post</code>.
</li>
</ol>


<p>
By pulling "taggability" into a discrete role, rather than an
inherent attribute of the tagged objects, we've decoupled <i>what</i> is
tagged from <i>how</i> it is tagged. Our tagging implementation can
change independently of other concerns. If tomorrow we decided to
change to using Redis for our tag store, the change might not be
<i>small</i>, but it would be <i>isolated</i>. Most of the app wouldn't know or
care about the change. To quote Kent Beck in <span style="text-decoration:underline;">Smalltalk Best Practice Patterns</span>:
</p>
<blockquote>

<p>When you can extend a system solely by adding new objects without
modifying any existing objects, then you have a system that is
flexible and cheap to maintain.
</p>
</blockquote>


</div>
</div>

</div>

<div id="outline-container-17_9" class="outline-3">
<h3 id="sec-17_9">Reconsidering <code>Taggable</code> </h3>
<div class="outline-text-3" id="text-17_9">

<p>   Implementing the <code>Taggable</code> role has been an instructive
   exercise. I don't know about you, but I learned a lot while writing
   it.
</p>
<p>
   Looking back over the code we wrote for <code>Taggable</code>, some of it is
   undeniably awkward. And for an aspect like taggability, which many
   would consider an intrinsic property of a blog post, it honestly
   feels like overkill. I think if I were to write a blog engine right
   now, based on these experiences, I would keep <code>Taggable</code> as an
   ordinary module and <code>include</code> it into the <code>Post</code> class.
</p>
<p>
   However, I don't think this completely invalidates the
   technique. There are more truly orthogonal concerns which I think
   would lend themselves well to this dynamic role-extension
   approach. As an example, consider adding security to the
   application.  It would be nice if we could write our models without
   thinking about crosscutting concern of security, and then
   dynamically extend them with an <code>AccessControlled</code> role at the
   controller level. Since such a role might well want to intercept
   ActiveRecord methods like <code>#save</code>, the dynamic module extension
   technique would be well-suited to it.
</p>
<p>
   The bottom line is this: your classes don't need to grow linearly
   with your requirements, even if they are your app's "core"
   classes. It is possible to build up your business objects as
   composites of small, orthogonal pieces. Whether through decoration,
   composition, or module extension, you have the power to put a stop
   to unchecked method creep today, and implement your next feature as
   a small, focused unit.
</p>
</div>
</div>

</div>

<div id="outline-container-18" class="outline-2">
<h2 id="sec-18"><a name="ID-dfd84e09-9d1b-4a31-ac9b-c485dd0a1bd1" id="ID-dfd84e09-9d1b-4a31-ac9b-c485dd0a1bd1"></a>Respecting controller privacy </h2>
<div class="outline-text-2" id="text-18">

<p>  There's something that has been bugging me about our views.
</p>
<p>
  Rails tries to make view templates look kind of like fancy
  controller methods, right down to sharing instance variables with
  the controller. In order to maintain this ruse Rails resorts to the
  kludgy expedient of copying instance variables one by one from the
  controller to the view template on render. Many have noted this as a
  particularly egregious violation of encapsulation. Until now, we
  haven't addressed this violation in our blog app.
</p>
<p>
  Let's remedy the situation now. We'll start with the <code>@blog</code>
  variable which is set in <code>ApplicationController</code>. We'll continue to
  set the variable, but instead of setting it in a before filter we'll
  expose it using a method named <code>#blog</code>.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
 private

 <span class="org-keyword">def</span> <span class="org-function-name">blog</span>
   <span class="org-variable-name">@blog</span> ||= <span class="org-type">THE_BLOG</span>
 <span class="org-keyword">end</span>
 <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">A controller accessor for the Blog instance</div>
</div>


<p>
  <code>#blog</code> is private here, so that it won't be exposed as a controller
  action. Unfortunately this means it won't be available to views,
  either. That's easily fixed, however:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
 <span class="org-keyword">def</span> <span class="org-function-name">blog</span>
   <span class="org-variable-name">@blog</span> ||= <span class="org-type">THE_BLOG</span>
 <span class="org-keyword">end</span>
 helper_method <span class="org-constant">:blog</span>
 <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Exposing ApplicationController#blog to views with helper_method</div>
</div>


<p>
  <code>helper_method</code> tells Rails to make the method available to views
  and helpers.
</p>
<p>
  We make a similar change to <code>PostsController</code>:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">show</span>
  <span class="org-variable-name">@post</span> = exhibit(<span class="org-type">Post</span>.find_by_id(params[<span class="org-constant">:id</span>]), <span class="org-variable-name">self</span>)
  respond_with(<span class="org-variable-name">@post</span>)
<span class="org-keyword">end</span>

private
attr_reader <span class="org-constant">:post</span>
helper_method <span class="org-constant">:post</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Exposing the current post as a controller accessor method</div>
</div>


<p>
  We continue to set <code>@post</code> directly in the controller actions, but
  for the purpose of views we expose it using a method <code>#post</code>.
</p>
<p>
  Now we go through our views looking for "@" signs and replacing
  direct instance variable references with method calls. E.g.
</p>



<pre class="src src-html">&lt;<span class="org-function-name">h1</span>&gt;<span class="org-underline"><span class="org-bold">New Post</span></span>&lt;/<span class="org-function-name">h1</span>&gt;
&lt;%= form_for Taggable(@post) do |f| %&gt;
<span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>

</pre>




<p>
  …becomes:
</p>



<pre class="src src-html">&lt;<span class="org-function-name">h1</span>&gt;<span class="org-underline"><span class="org-bold">New Post</span></span>&lt;/<span class="org-function-name">h1</span>&gt;
&lt;%= form_for Taggable(post) do |f| %&gt;
<span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>

</pre>




<p>
This is more than a feel-good change. We gain a couple of pragmatic
benefits from calling methods instead of accessing instance variables:
</p>
<ol>
<li>Easier refactoring to partials. Well-written partials reference
   "@"-less local variables set with the <code>:locals</code>, <code>:object</code>, or
   <code>:collection</code> keys rather than directly accessing instance
   variables. Since the views now use the "@"-free form, they can be
   easily broken up into partials without altering their content.
</li>
<li>More informative error messages. How many times have you struggled
   with mysterious "<code>NoMethodError</code> on <code>NilClass</code>" failures in views?
   A missing or misspelled instance variable will default to <code>nil</code>,
   which isn't very helpful for tracking it down. A missing or
   misspelled method, on the other hand, will raise an exception which
   tells you exactly what method couldn't be found.
</li>
</ol>


<p>
This is the cheapest, most trivial way to begin distancing views from
controllers. If you are interested in exploring more advanced OO
approaches to rendering views, check out the <a href="#sec-23">Further Reading</a> section.
</p>
</div>

</div>

<div id="outline-container-19" class="outline-2">
<h2 id="sec-19"><a name="ID-a626c283-3ae8-4cf3-be6e-7b9a6d8929ef" id="ID-a626c283-3ae8-4cf3-be6e-7b9a6d8929ef"></a>Jealously guarding collections </h2>
<div class="outline-text-2" id="text-19">

<p>  The changes we just made enable us to fix another nagging
  issue. Back in the <a href="#sec-16">Exhibits for REST</a> chapter, we did something we
  said we were going to try to avoid. We accessed a <code>Post</code> object
  directly from the <code>Post</code> model, instead of going through the <code>Blog</code>.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">PostsController</span> &lt; <span class="org-type">ApplicationController</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">show</span>
    <span class="org-variable-name">@post</span> = exhibit(<span class="org-type">Post</span>.find_by_id(params[<span class="org-constant">:id</span>]), <span class="org-variable-name">self</span>)
    respond_with(<span class="org-variable-name">@post</span>)
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Accessing a post via the Post class</div>
</div>


<p>
  Since we added a <code>#blog</code> method to <code>ApplicationController</code>, we now
  have access to that method from all controllers. We now change
  <code>PostsController#show</code> to find the requested post through the
  <code>blog</code>.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">PostsController</span> &lt; <span class="org-type">ApplicationController</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">show</span>
    <span class="org-variable-name">@post</span> = exhibit(blog.post(params[<span class="org-constant">:id</span>]), <span class="org-variable-name">self</span>)
    respond_with(<span class="org-variable-name">@post</span>)
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Accessing a post via the Blog instance</div>
</div>


<p>
  For this to work, we need a <code>Blog#post</code> query method.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Blog</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">post</span>(id)
    entries.find_by_id(id)
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The Blog#post query method</div>
</div>


<p>
  Now the <code>Post</code> object loaded by <code>PostsController#show</code> is no longer
  a <a href="#sec-6-4">Lone Wolf</a>.
</p>

</div>

<div id="outline-container-19_1" class="outline-3">
<h3 id="sec-19_1">Objects as lending libraries </h3>
<div class="outline-text-3" id="text-19_1">


<p>
  Note what we <i>didn't</i> write in the controller:
</p>



<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-variable-name">@post</span> = exhibit(blog.entries.find_by_id(params[<span class="org-constant">:id</span>]), <span class="org-variable-name">self</span>)
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>




<p>
  This version would have satisfied the "tree of objects"
  architectural style we're shooting for. But there a couple of
  problems with it.
</p>
<p>
  For one thing, it taunts the <a href="http://avdi.org/devblog/2011/07/05/demeter-its-not-just-a-good-idea-its-the-law/">Law of Demeter</a>. It sets up structural
  coupling between <code>PostsController</code> and <code>Blog</code>. It duplicates the
  knowledge that <code>Blog</code> has a collection of <code>entries</code> which responds
  to <code>#find_by_id</code> and returns a <code>Post</code>, thus making that structure
  just a little bit harder to change.
</p>
<p>
  But another, and perhaps even bigger problem is that it makes it
  harder for <code>Blog</code> to exercise control over its <code>entries</code>
  collection.
</p>
<p>
  Imagine a lending library. A lending library has various
  collections: books, videos, periodicals. The library will allow
  patrons to use and even borrow the items in its collection; that's
  it's purpose. But the library doesn't allow them to just take items
  willy-nilly.
</p>
<p>
  Instead, the library requires patrons to enter during visiting
  hours. They must register for a library card before borrowing items.
  They must come to the counter and and present their card before
  taking an item out of the library. The books they borrow have
  stickers or perhaps even an RFID tag identifying them as part of the
  library's collection.
</p>
<p>
  Now imagine the the library as an object. Would the library we've
  just described prefer that a book to be withdrawn like this?
</p>



<pre class="src src-ruby">library.books.find_by_isbn(<span class="org-string">'161293031X'</span>)

</pre>




<p>
  That's a bit like putting the bookshelf outside the front door of
  the library and allowing passersby to take books off the shelves as
  they please.
</p>
<p>
  I suspect the electronic librarians working inside our virtual
  library would much rather the patrons used an interface like this:
</p>



<pre class="src src-ruby">library.borrow_book(<span class="org-string">'161293031X'</span>, library_card)

</pre>




<p>
  OK, I admit, this is getting to be a pretty stretched-out
  metaphor. The point is, when client code accesses an object's
  children through a collection object, rather than directly through
  the parent object, the parent is no longer the mediator. Remember
  the advantages we cited earlier of having a parent object mediate
  access to its children:
</p>
<ol>
<li>The ability to control access based on authorization information.
</li>
<li>The opportunity to pre-load child objects with a reference back to their
      parent.
</li>
<li>The opportunity to keep a list of child objects in the parent,
      for autosave or other purposes.
</li>
<li>The ability to decide the concrete type of child object to
      return, or, in this example, what collection(s) to search for
      the child.
</li>
</ol>


<p>
  It's not impossible for a parent object to mediate access to its
  children even with a collection object as a middleman. There are
  schemes involving proxy objects and callbacks which can enable the
  parent object to stay "in the loop" with regard to child access.
</p>
<p>
  It's easier and introduces less structural coupling, however, to
  simply have all child access go through the parent object. That may
  mean, in some cases, that the parent simply delegates finder methods
  directly to an underlying collection, as we did in
  <code>Blog#post(id)</code>. But even that simple act of delegation introduces a
  seam where more involved processing can be introduced later on, with
  no change to the code's clients.
</p>
<p>
  In short, we prefer to let parent objects mediate access to their
  children, rather than having clients pick through their collection
  associations directly.
</p>
</div>
</div>

</div>

<div id="outline-container-20" class="outline-2">
<h2 id="sec-20">Toward self-rendering objects </h2>
<div class="outline-text-2" id="text-20">

<p>  We've taken some small steps towards wrapping our models with the
  "smarts" to render themselves as HTML or JSON, but there's still
  room for improvement. Here is our partial for rendering entries as it
  stands now:
</p>


<div class="listing">

<pre class="src src-html">&lt;% entry = exhibit(entry, self) %&gt;
&lt;<span class="org-function-name">article</span>&gt;
  &lt;<span class="org-function-name">header</span>&gt;
    &lt;<span class="org-function-name">p</span>&gt;&lt;<span class="org-function-name">time</span> <span class="org-variable-name">pubdate</span>=<span class="org-string">"pubdate"</span>&gt;&lt;%= entry.pubdate %&gt;&lt;/<span class="org-function-name">time</span>&gt;&lt;/<span class="org-function-name">p</span>&gt;
    &lt;<span class="org-function-name">h3</span>&gt;&lt;%= entry.title %&gt;&lt;/<span class="org-function-name">h3</span>&gt;
    &lt;<span class="org-function-name">p</span> <span class="org-variable-name">class</span>=<span class="org-string">"entry_tags"</span>&gt;Tags: 
      &lt;<span class="org-function-name">span</span> <span class="org-variable-name">class</span>=<span class="org-string">"tags"</span>&gt;&lt;%= Taggable(entry).tags %&gt;&lt;/<span class="org-function-name">span</span>&gt;
    &lt;/<span class="org-function-name">p</span>&gt;
  &lt;/<span class="org-function-name">header</span>&gt;
  &lt;%= entry.render_body %&gt;
&lt;/<span class="org-function-name">article</span>&gt;

</pre>


<div class="caption">The entry partial</div>
</div>


<p>
  As you'll recall, earlier we avoided putting logic in the view by
  calling <code>entry.render_body</code> and delegating the decision of which
  body partial to render to the Exhibit. While there is no branch
  logic in this partial, there's still more code than we'd like.
</p>
<p>
  Given our preference, we'd rather the template looked something like
  this:
</p>


<div class="listing">

<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/posts/_post.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">article</span>&gt;
  &lt;<span class="org-function-name">header</span>&gt;
    &lt;<span class="org-function-name">p</span>&gt;&lt;<span class="org-function-name">time</span> <span class="org-variable-name">pubdate</span>=<span class="org-string">"pubdate"</span>&gt;&lt;%= post.pubdate %&gt;&lt;/<span class="org-function-name">time</span>&gt;&lt;/<span class="org-function-name">p</span>&gt;
    &lt;<span class="org-function-name">h3</span>&gt;&lt;%= post.title %&gt;&lt;/<span class="org-function-name">h3</span>&gt;
    &lt;<span class="org-function-name">div</span> <span class="org-variable-name">class</span>=<span class="org-string">"entry_tags"</span>&gt;Tags: 
      &lt;%= post.tags.render(self) %&gt;
    &lt;/<span class="org-function-name">div</span>&gt;
  &lt;/<span class="org-function-name">header</span>&gt;
  &lt;%= post.render_body(self) %&gt;
&lt;/<span class="org-function-name">article</span>&gt;

</pre>


<div class="caption">An ideal entry partial</div>
</div>


<p>
  There are a few differences in this version:
</p>
<ol>
<li>No <code>entry = exhibit(entry, self)</code> boilerplate at the beginning.
</li>
<li>Now that we have a more fleshed-out <code>Post</code> model, which this
     partial is specific to, we've replaced the <code>entry</code> terminology
     with <code>post</code>. We've also moved the file to the more canonical
     location <code>app/views/posts/_post.html.erb</code>.
</li>
<li>No more remembering to put <code>Taggable()</code> around the <code>post</code>
     whenever we want to work with tags.
</li>
<li>Speaking of tags, instead of rendering the tag list as a string
     directly, we now tell the list to render itself within the view
     template.
</li>
</ol>


<p>
  Let's see what we need to do in order to make this refactored view
  template work.
</p>

</div>

<div id="outline-container-20_1" class="outline-3">
<h3 id="sec-20_1">Exhibiting from inside the controller </h3>
<div class="outline-text-3" id="text-20_1">

<p>   First of all, having to explicitly <code>exhibit()</code> models inside each
   view is a drag. To avoid this, we start exhibiting our models at
   the controller level.
</p>
<p>
   We're actually already doing this in the action for showing a
   single post:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/controllers/posts_controller.rb</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">show</span>
  <span class="org-variable-name">@post</span> = exhibit(blog.post(params[<span class="org-constant">:id</span>]), <span class="org-variable-name">self</span>)
  respond_with(<span class="org-variable-name">@post</span>)
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Exhibiting a post at the controller level</div>
</div>


<p>
   So that's alright. But now that we are using a controller as
   the <code>context</code> for the exhibited model, instead of a view context,
   we have a problem: <code>render_body</code> no longer works.
</p>
<p>
   Remember that <code>render_body</code> relies on having a reference to a view
   template in order to work:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">PicturePostExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-keyword">def</span> <span class="org-function-name">render_body</span>
    <span class="org-variable-name">@context</span>.render(partial: <span class="org-string">"/posts/picture_body"</span>, locals: {post: <span class="org-variable-name">self</span>})
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Review of PicturePostExhibit#render_body</div>
</div>


<p>
   Yes, <code>ActionController</code> provides a <code>#render</code> method too, but it's a
   very different beast from the <code>#render</code> found in views. It expects
   to be called once per action in order to determine what top-level
   rendering action to take.
</p>
<p>
   So, we change <code>#render_body</code> to accept a <code>template</code> argument:
</p>
   

<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">def</span> <span class="org-function-name">render_body</span>(template)
  template.render(partial: <span class="org-string">"/posts/picture_body"</span>, locals: {post: <span class="org-variable-name">self</span>})
<span class="org-keyword">end</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

</pre>


<div class="caption">Adding a template argument to PicturePostExhibit#render_body</div>
</div>


<p>
   And then we explicitly pass in the current view context object in
   the view:
</p>


<div class="listing">

<pre class="src src-html">&lt;<span class="org-function-name">article</span>&gt;
  <span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
  &lt;%= post.render_body(self) %&gt;
&lt;/<span class="org-function-name">article</span>&gt;

</pre>


<div class="caption">Explicitly passing the view context to #render_body</div>
</div>


<p>
   From now on, we'll use this pattern of explicitly passing in the
   template object which the exhibit should use to render itself.
</p>
<p>
   Incidentally, this is a classic example of <i>Double    Dispatch</i>. Quoting <span style="text-decoration:underline;">Smalltalk Best Practice Patterns</span>:
</p>
<blockquote>

<p>How can you code a computation that has many cases, the cross product
of two families of classes? […] The solution is adding a layer of
messages that get both objects involved in the computation.
</p>
</blockquote>


<p>
   In our case, the two families of cases are:
</p>
<ol>
<li>The specific <code>Exhibit</code> which might be wrapped around a given
      model object; and
</li>
<li>The template object within which the model may be presented.
</li>
</ol>


<p>
   The first dispatch, the call to <code>#render_body</code>, enables the post
   body partial to be determined polymorphically. The second
   dispatch, the call to <code>template.render</code>, farms the specific details
   of finding and rendering the chosen partial back out to the
   template object.
</p>
</div>

</div>

<div id="outline-container-20_2" class="outline-3">
<h3 id="sec-20_2">Exhibiting the blog object </h3>
<div class="outline-text-3" id="text-20_2">

<p>   It was easy enough to exhibit a single <code>Post</code> object at the
   controller level. It gets more complicated when we look at
   rendering multiple blog posts in the context of the front page.
</p>
<p>
   In that context, we can't directly exhibit entries at the
   controller level, because the controller only supplies a <code>blog</code>
   object to the view. Then, consistent with our <a href="#sec-6-4">object tree</a>, we
   access the blog entries via the <code>blog</code> object using the <code>#entries</code>
   accessor.
</p>
<p>
   We'll have to start at the root of the tree by first exhibiting the
   <code>blog</code> object itself at the controller level. We alter
   <code>ApplicationController</code> to always decorate the <code>blog</code> before
   returning it:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">ApplicationController</span> &lt; <span class="org-type">ActionController</span>::<span class="org-type">Base</span>
  include <span class="org-type">ExhibitsHelper</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">blog</span>
    <span class="org-variable-name">@blog</span> ||= exhibit(<span class="org-type">THE_BLOG</span>)
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Exhibiting the Blog instance at the controller level</div>
</div>


<p>
   This alone, however, is not quite enough to ensure the <code>blog</code>
   object is always exhibited. Recall that earlier we made it possible
   to present only a subset of posts on the blog home page by
   filtering by tag:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">BlogController</span> &lt; <span class="org-type">ApplicationController</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">blog</span>
    <span class="org-keyword">if</span> params[<span class="org-constant">:tag</span>].present?
      <span class="org-keyword">super</span>.filter_by_tag(params[<span class="org-constant">:tag</span>])
    <span class="org-keyword">else</span>
      <span class="org-keyword">super</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Filtering the blog by tag</div>
</div>


<p>
   If there's no filter, we get the exhibited <code>blog</code> from
   <code>ApplicationController#blog</code>, and all is well. If there is a
   filter, however, we get a raw <code>Blog::FilteredBlog</code> instance - with
   no exhibit wrapped around it!
</p>
<p>
   The naive solution is to keep calling <code>exhibit()</code> every time we have
   a new non-exhibited object to deal with:
</p>



<pre class="src src-ruby">exhibit(<span class="org-keyword">super</span>.filter_by_tag(params[<span class="org-constant">:tag</span>]))

</pre>




<p>
   This solution is ugly, verbose, and unsustainable. The more code we
   write, the more often we'll wind up accidentally leaving out an
   <code>exhibit()</code> call and introducing a bug.
</p>
<p>
   We need a way to <i>recursively</i> exhibit objects, such that the
   exhibited object's "children" are automatically exhibited as well..
</p>
</div>

</div>

<div id="outline-container-20_3" class="outline-3">
<h3 id="sec-20_3">The <code>exhibit_query</code> macro </h3>
<div class="outline-text-3" id="text-20_3">


<p>
   Our first cut at this problem is to write an explicit wrapper for
   <code>Blog#filter_by_tag</code> in a brand-new <code>BlogExhibit</code> class:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">BlogExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">filter_by_tag</span>(*)
    exhibit(<span class="org-keyword">super</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Exhibiting the result of BlogExhibit#filter_by_tag</div>
</div>


<p>
   This method simply calls the underlying model's <code>#filter_by_tag</code>
   method and then wraps the result in a call to <code>exhibit()</code> before
   returning it.
</p>
<p>
   We know we're going to need this for more than
   <code>Blog#filter_by_tag</code>. So once we are confident this works, we
   extract it to a "macro" method:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Exhibit</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.exhibit_query</span>(*method_names)
    method_names.each <span class="org-keyword">do</span> |name|
      define_method(name) <span class="org-keyword">do</span> |*args, &amp;block|
        exhibit(<span class="org-keyword">super</span>(*args, &amp;block))
      <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
  private_class_method <span class="org-constant">:exhibit_query</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">A generic exhibit_query macro</div>
</div>

<p>
   We call the macro <code>exhibit_query</code>. "Query", in this case, is used
   in the sense of "<a href="http://martinfowler.com/bliki/CommandQuerySeparation.html">command/query separation</a>". It refers to a method
   whose purpose is to return an object, rather than to effect some
   change in the system state. <code>exhibit_query</code> advises such methods
   such that their return value will be wrapped in the appropriate
   exhibit(s) (if any).
</p>
<p>
   We then replace our explicit version in <code>BlogExhibit</code> with a call
   to the new macro:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">BlogExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  exhibit_query <span class="org-constant">:filter_by_tag</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Using the exhibit_query macro</div>
</div>

</div>

</div>

<div id="outline-container-20_4" class="outline-3">
<h3 id="sec-20_4">Finishing the <code>BlogExhibit</code> </h3>
<div class="outline-text-3" id="text-20_4">


<p>
   We finish out our new <code>BlogExhibit</code> with a predicate to determine
   if it is applicable.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">BlogExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.applicable_to?</span>(object)
    object_is_any_of?(object, <span class="org-string">'Blog'</span>, <span class="org-string">'Blog::FilteredBlog'</span>)
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">BlogExhibit applicability</div>
</div>


<p>
   This definition makes use of a new <code>Exhibit.object_is_any_of?</code>
   helper to match on any of a list of class names. Here's the the
   definition of <code>Exhibit.object_is_any_of?</code>:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">def</span> <span class="org-function-name">self.object_is_any_of?</span>(object, *classes)
  <span class="org-comment-delimiter"># </span><span class="org-comment">What with Rails development mode reloading making class matching</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">unreliable, plus wanting to avoid adding dependencies to</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">external class definitions if we can avoid it, we just match</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">against class/module name strings rather than the actual class</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">objects.</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">Note that '&amp;' is the set intersection operator for Arrays. </span>
  (classes.map(&amp;<span class="org-constant">:to_s</span>) &amp; object.class.ancestors.map(&amp;<span class="org-constant">:name</span>)).any?
<span class="org-keyword">end</span>
private_class_method <span class="org-constant">:object_is_any_of?</span>

</pre>


<div class="caption">The Exhibit.object_is_any_of? helper predicate</div>
</div>


<p>   
   Note that we made both this method and the <code>exhibit_query</code> "macro"
   private with <code>private_class_method</code>. Since they are both intended
   exclusively for use <i>inside</i> exhibit class definitions, there is no
   reason to clutter up the class' external interface with them.
</p>
</div>

</div>

<div id="outline-container-20_5" class="outline-3">
<h3 id="sec-20_5">Rendering the list of posts </h3>
<div class="outline-text-3" id="text-20_5">

<p>   Let's circle back and remind ourselves what we're trying to
   accomplish right now.  Inside the template for the <code>Blog#index</code>
   action we'd like to be able to write something like this:
</p>



<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
&lt;%= render partial: <span class="org-string">"/posts/post"</span>, collection: blog.entries %&gt;
<span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>

</pre>




<p>
   So far, we've been trying to find a way for the exhibited <code>blog</code>
   object to recursively confer <code>exhibited</code> status on its children,
   the blog entries.
</p>
<p>
   We have the first part of the puzzle now. In order for
   <code>blog.entries</code> to also be exhibited, we need to make it an
   "exhibited query" just as we did with <code>Blog#filter_by_tag</code>.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">BlogExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  exhibit_query <span class="org-constant">:filter_by_tag</span>, <span class="org-constant">:entries</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Exhibiting the entry list</div>
</div>


<p>
   Is this all we need to do? Alas, no. The return value of
   <code>Blog#entries</code> is a collection (an <code>ActiveRecord::Relation</code>
   instance, if you really want to know). We've made sure that the
   collection itself will go through the exhibiting process; but the
   individual elements of the collection will still come back as
   bare, unadorned <code>Post</code> objects. Objects which have no idea what to
   do when someone sends them the <code>#render_body</code> message.
</p>
</div>

</div>

<div id="outline-container-20_6" class="outline-3">
<h3 id="sec-20_6">An exhibit for collections </h3>
<div class="outline-text-3" id="text-20_6">

<p>   What we need is a type of <code>Exhibit</code> which will wrap a collection,
   and ensure that any elements accessed from within the collection
   will <i>also</i> be exhibited.
</p>
<p>
   We begin to spec out an <code>EnumerableExhibit</code> class, using Ruby's
   <code>Enumerable</code>, <code>Array</code>, and <code>Hash</code> classes as a guideline for what
   methods a collection exhibit should be expected to handle.
</p>
<p>
   Here's a sample of the spec:
</p>


<div class="listing">

<pre class="src src-ruby">describe <span class="org-type">EnumerableExhibit</span> <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  subject { <span class="org-type">EnumerableExhibit</span>.new(model, context) }
  let(<span class="org-constant">:model</span>) { [<span class="org-string">"e1"</span>, <span class="org-string">"e2"</span>, <span class="org-string">"e3"</span>] }
  let(<span class="org-constant">:context</span>) { <span class="org-type">Object</span>.new }

  before <span class="org-keyword">do</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">#exhibit is part of the superclass interface, not this class'</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">interface, so it is fair game for stubbing</span>
    stub(subject).exhibit {|model|
      <span class="org-variable-name">@last_exhibited</span> = model
      <span class="org-string">"exhibit(</span><span class="org-variable-name">#{model}</span><span class="org-string">)"</span>
    }
  <span class="org-keyword">end</span>

  describe <span class="org-string">"#each"</span> <span class="org-keyword">do</span>
    it <span class="org-string">"exhibits each element"</span> <span class="org-keyword">do</span>
      results = []
      subject.each <span class="org-keyword">do</span> |e| results &lt;&lt; e <span class="org-keyword">end</span>
      results.must_equal([<span class="org-string">"exhibit(e1)"</span>, <span class="org-string">"exhibit(e2)"</span>, <span class="org-string">"exhibit(e3)"</span>])
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  describe <span class="org-string">"#grep"</span> <span class="org-keyword">do</span>
    it <span class="org-string">"exhibits the result set"</span> <span class="org-keyword">do</span>
      subject.grep(<span class="org-string">/[12]/</span>).must_equal(<span class="org-string">'exhibit(["e1", "e2"])'</span>)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  describe <span class="org-string">"#select"</span> <span class="org-keyword">do</span>
    it <span class="org-string">"exhibits each result"</span> <span class="org-keyword">do</span>
      subject.select{|e| /[23]/ === e}.must_equal(<span class="org-string">'exhibit(["e2", "e3"])'</span>)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  describe <span class="org-string">"#[]"</span> <span class="org-keyword">do</span>
    it <span class="org-string">"exhibits the result"</span> <span class="org-keyword">do</span>
      subject[1].must_equal(<span class="org-string">"exhibit(e2)"</span>)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  describe <span class="org-string">"#group_by"</span> <span class="org-keyword">do</span>
    it <span class="org-string">"exhibits the result"</span> <span class="org-keyword">do</span>
      subject.group_by{|e| e == <span class="org-string">"e2"</span>}.
        must_equal({ <span class="org-variable-name">true</span>  =&gt; <span class="org-string">'exhibit(["e2"])'</span>,
                     <span class="org-variable-name">false</span> =&gt; <span class="org-string">'exhibit(["e1", "e3"])'</span>})
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>


</pre>


<div class="caption">Sample of the EnumerableExhibit spec</div>
</div>


<p>
   This is just a small subset of the full spec; we want to be very
   careful to avoid surprises with this class, so we carefully spec
   out the behavior of every common, and some not-so-common,
   <code>Enumerable</code> and <code>Array</code> method, as well as one or two methods from
   <code>ActiveRecord::Relation</code>.
</p>
<p>
   For some of the methods, getting the desired behavior is as simple
   as making the <code>EnumerableExhibit</code> <code>Enumerable</code> itself, and defining
   <code>#each</code>.
</p>
   

<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">EnumerableExhibit</span> &lt; <span class="org-type">Exhibit</span>
  include <span class="org-type">Enumerable</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">each</span>(*)
    <span class="org-keyword">super</span> <span class="org-keyword">do</span> |e|
      <span class="org-keyword">yield</span> exhibit(e)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Making EnumerableExhibit Enumerable</div>
</div>


<p>
   We implement <code>#each</code> to wrap each element in <code>exhibit()</code> before
   yielding. Because they are implemented in terms of #each, methods
   like <code>#map</code> and <code>#inject</code> will now work exactly as expected, also
   wrapping each element in <code>exhibit()</code> before returning them.
</p>
<p>
   Other accessor methods which return single elements, such as <code>#[]</code>
   and <code>#fetch</code>, we are able to quickly add using our handy
   <code>exhibit_query</code> macro.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">EnumerableExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  exhibit_query <span class="org-constant">:[]</span>, <span class="org-constant">:fetch</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Using exhibit_query in the EnumerableExhibit implementation</div>
</div>


<p>
   However, there is another set of methods which are not so
   straightforward.  As an example, consider <code>Enumerable#select</code>, aka
   <code>Enumerable#find_all</code>. This method takes a one-argument block and
   returns all elements for which the block evaluates to true.
</p>
<p>
   At first, it seems like we could just rely on the free
   implementation of <code>#select</code> that we get from <code>Enumerable</code>. And
   indeed, there's nothing <i>broken</i> about this version. Each matching
   element (if any) will be wrapped in appropriate exhibits.
</p>
<p>
   The problem is that "filter" methods like <code>select</code> are often used
   as part of chains of calls, each link in the chain winnowing down
   and/or transforming the elements until the desired result set is
   reached. And it really doesn't make sense to be wrapping exhibits
   around every single element at intermediate points in the chain.
   In addition, for some types of filter chains, having the individual
   elements wrapped in exhibits may mess up the filter logic in
   non-obvious ways. What we really want is to leave the individual
   elements yielded to the <code>#select</code>'s block to be "pristine", and for
   the method to return a new <code>EnumerableExhibit</code> which is wrapped
   around the result set.
</p>
<p>
   In order to achieve this behavior, we write another macro along the
   lines of <code>exhibit_query</code>, this time called <code>exhibit_enum</code>. The job
   of <code>exhibit_enum</code> is to wrap an underlying collection method such that:
</p>
<ol>
<li>It has "stock" block behavior - no wrapping elements in
      <code>exhibit()</code> before yielding them to the block.
</li>
<li>The return value is run through the exhibiting process in order
      to wrap the result set in a new <code>EnumerableExhibit</code> result set.
</li>
<li>Optionally, the return value is post-processed with a custom
      block to account for more complex result formats.
</li>
</ol>


<p>
   Here's the macro:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">EnumerableExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.exhibit_enum</span>(*method_names, &amp;post_process)
    post_process ||= -&gt;(result){exhibit(result)}
    method_names.each <span class="org-keyword">do</span> |method_name|
      define_method(method_name) <span class="org-keyword">do</span> |*args, &amp;block|
        result = __getobj__.public_send(method_name, *args, &amp;block)
        instance_exec(result, &amp;post_process)
      <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
  private_class_method <span class="org-constant">:exhibit_enum</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The exhibit_enum macro</div>
</div>


<p>
   We then list out the methods to be wrapped in this fashion.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">EnumerableExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  exhibit_enum <span class="org-constant">:select</span>, <span class="org-constant">:grep</span>, <span class="org-constant">:reject</span>, <span class="org-constant">:to_enum</span>, <span class="org-constant">:sort</span>, <span class="org-constant">:sort_by</span>, <span class="org-constant">:reverse</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Using exhibit_enum in EnumerableExhibit</div>
</div>


<p>
   As noted above, a few methods require special post-processing for
   the return value. For example, <code>Enumerable#partition</code> returns an
   array of arrays instead of a simple array. We handle these cases
   separately:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">EnumerableExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  exhibit_enum <span class="org-constant">:partition</span> <span class="org-keyword">do</span> |result|
    result.map{|group| exhibit(group)}
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Post-processing the results of EnumerableExhibit#partition</div>
</div>


<p>
   Here's the source of the complete <code>EnumerableExhibit</code> class.
</p>


<div class="listing">

<pre class="src src-ruby">require_relative <span class="org-string">'exhibit'</span>

<span class="org-keyword">class</span> <span class="org-type">EnumerableExhibit</span> &lt; <span class="org-type">Exhibit</span>
  include <span class="org-type">Enumerable</span>

  <span class="org-keyword">def</span> <span class="org-function-name">self.applicable_to?</span>(object)
    <span class="org-comment-delimiter"># </span><span class="org-comment">ActiveRecord::Relation, surprisingly, is not Enumerable. But it</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">behaves sufficiently similarly for our purposes.</span>
    object_is_any_of?(object, <span class="org-string">'Enumerable'</span>, <span class="org-string">'ActiveRecord::Relation'</span>)
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">Wrap an Enumerable method which returns another collection</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.exhibit_enum</span>(*method_names, &amp;post_process)
    post_process ||= -&gt;(result){exhibit(result)}
    method_names.each <span class="org-keyword">do</span> |method_name|
      define_method(method_name) <span class="org-keyword">do</span> |*args, &amp;block|
        result = __getobj__.public_send(method_name, *args, &amp;block)
        instance_exec(result, &amp;post_process)
      <span class="org-keyword">end</span>
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
  private_class_method <span class="org-constant">:exhibit_enum</span>

  exhibit_query <span class="org-constant">:[]</span>, <span class="org-constant">:fetch</span>, <span class="org-constant">:slice</span>, <span class="org-constant">:values_at</span>, <span class="org-constant">:last</span>
  exhibit_enum <span class="org-constant">:select</span>, <span class="org-constant">:grep</span>, <span class="org-constant">:reject</span>, <span class="org-constant">:to_enum</span>, <span class="org-constant">:sort</span>, <span class="org-constant">:sort_by</span>, <span class="org-constant">:reverse</span>
  exhibit_enum <span class="org-constant">:partition</span> <span class="org-keyword">do</span> |result|
    result.map{|group| exhibit(group)}
  <span class="org-keyword">end</span>
  exhibit_enum <span class="org-constant">:group_by</span> <span class="org-keyword">do</span> |result|
    result.inject({}) { |h,(k,v)|
      h.merge!(k =&gt; exhibit(v))
    }
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">each</span>(*)
    <span class="org-keyword">super</span> <span class="org-keyword">do</span> |e|
      <span class="org-keyword">yield</span> exhibit(e)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">`render '...', :collection =&gt; self` will call #to_ary on this</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">before rendering, so we need to be prepared.</span>
  <span class="org-keyword">def</span> <span class="org-function-name">to_ary</span>
    <span class="org-variable-name">self</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">The complete EnumerableExhibit implementation</div>
</div>

</div>

</div>

<div id="outline-container-20_7" class="outline-3">
<h3 id="sec-20_7">Transitive exhibited-ness </h3>
<div class="outline-text-3" id="text-20_7">

<p>   It's taken some effort, but we've got some pretty nifty
   functionality on our hands now. Given a line of code like the
   following:
</p>



<pre class="src src-ruby">entry = exhibit(blog).entries.first

</pre>




<p>
   The "exhibited" nature of <code>blog</code> will be conferred upon <code>entries</code>,
   and then upon the chosen entry. Each object in the chain will be
   transparently wrapped in the appropriate <code>Exhibit</code> objects (if
   any). In effect, we've made the "exhibited" property transitive
   from parent objects to children.
</p>
<p>
   This template code now works:
</p>



<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
&lt;%= render partial: <span class="org-string">"/posts/post"</span>, collection: blog.entries %&gt;
<span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>

</pre>




<p>
   What this means is that we can now be confident that no matter
   where the <code>/posts/post</code> partial is rendered, either on a
   single-post page or as part of the front-page index, its <code>post</code>
   local will refer to an exhibited object. We can safely call
   <code>post.render_body(self)</code> and know that the right body partial will
   be rendered.
</p>
</div>

</div>

<div id="outline-container-20_8" class="outline-3">
<h3 id="sec-20_8">Telling the post to render itself </h3>
<div class="outline-text-3" id="text-20_8">

<p>   When we look at the code to render a post body:
</p>


<div class="listing">

<pre class="src src-html">&lt;<span class="org-function-name">article</span>&gt;
  <span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
  &lt;%= post.render_body(self) %&gt;
&lt;/<span class="org-function-name">article</span>&gt;

</pre>


<div class="caption">Rendering a post body</div>
</div>


<p>
   …a question naturally springs to mind. If we can tell an exhibited
   <code>Post</code> to render its body… why not tell it to render the whole
   post the same way? Making this work will be our next task.
</p>
<p>
   It turns out to be fairly straightforward. First, we add a a method
   <code>#to_partial_path</code> to <code>Exhibit</code>. This method's job is to return an
   appropriate partial path (as in <code>render partial: path</code>) for the
   exhibited model.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Exhibit</span> &lt; <span class="org-type">SimpleDelegator</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">to_partial_path</span>
    <span class="org-keyword">if</span> __getobj__.respond_to?(<span class="org-constant">:to_partial_path</span>)
      __getobj__.to_partial_path
    <span class="org-keyword">else</span>
      partialize_name(__getobj__.class.name)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Implementing Exhibit#to_partial_path</div>
</div>


<p>
   We first check to see if the underlying model has its own idea of
   what partial should be used. We do this because as of Rails 3.2,
   <code>#to_partial_path</code> <a href="http://blog.plataformatec.com.br/2012/01/my-five-favorite-hidden-features-in-rails-3-2/">is a part of the <code>ActiveModel</code> API</a>. If a model
   implements the method, we want to defer to it by default.
</p>
<p>
   Otherwise, we munge the model's class name into a partial path
   using a helper method <code>#partialize_name</code>. That method is defined as
   follows:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Exhibit</span> &lt; <span class="org-type">SimpleDelegator</span>
  private
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">partialize_name</span>(name)
    <span class="org-string">"/</span><span class="org-variable-name">#{name.underscore.pluralize}</span><span class="org-string">/</span><span class="org-variable-name">#{name.demodulize.underscore}</span><span class="org-string">"</span>
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Generating a default partial path</div>
</div>


<p>
   Given the class name "Post", this will return
   "/posts/post", which is exactly what we want.
</p>
<p>
   Now that we know the name of the partial to render, the <code>#render</code>
   method itself is trivial.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Exhibit</span> &lt; <span class="org-type">SimpleDelegator</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">render</span>(template)
    template.render(<span class="org-constant">:partial</span> =&gt; to_partial_path, <span class="org-constant">:object</span> =&gt; <span class="org-variable-name">self</span>)
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Exhibit#render</div>
</div>


<p>
   We can now use this in <code>app/views/posts/show.html.erb</code> to render
   the <code>post</code> object:
</p>



<pre class="src src-html">&lt;%= post.render(self) %&gt;

</pre>




</div>

</div>

<div id="outline-container-20_9" class="outline-3">
<h3 id="sec-20_9">Entry collection, render thyself </h3>
<div class="outline-text-3" id="text-20_9">

<p>   OK, that's cool, but can we use the same thing for rendering a list
   of posts? Like, say, on the blog front page?
</p>
<p>
   Not quite yet. Here's what we'd <i>like</i> to write:
</p>



<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
&lt;%= blog.entries.render(self) %&gt;

</pre>




<p>
   We know we can tell an exhibited <code>Post</code> to render itself, but here
   we're rendering a collection of posts.
</p>
<p>
   Hm, "collection"… didn't we just finish writing an exhibit class
   for collections? And doesn't it now inherit <code>#render</code> from
   <code>Exhibit</code>?
</p>
<p>
   It does indeed, but if we try the code above right now, it tries to
   render the collection of posts with a partial named
   <code>/active_record/relation</code>, and fails when it can't find that
   partial. Let's customize <code>EnumerableExhibit</code> to do something
   a little smarter.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">EnumerableExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">render</span>(template)
    inject(<span class="org-type">ActiveSupport</span>::<span class="org-type">SafeBuffer</span>.new) { |output,element|
      output &lt;&lt; element.render(template)
    }
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Implementing EnumerableExhibit#render to render each element</div>
</div>


<p>
   Instead of rendering a partial, this version of <code>#render</code> iterates
   over the elements of the underlying collection, rendering each one
   and appending the results to a buffer. Remember that <code>#inject</code> is
   implemented in terms of our <code>#each</code> method, which exhibits the
   elements before yielding them. We use an
   <code>ActiveSupport::SafeBuffer</code> instead of a <code>String</code> so that Rails
   will render the resulting string as raw HTML instead of escaping
   it.
</p>
<p>
   Once we upgrade to Rails 3.2 we'll probably be able to switch this
   to use a simple <code>render self</code> and rely on Rails to ask each item
   for a partial path using <code>#to_partial_path</code>. But for right now this
   works well enough.
</p>
<p>
   Now we can write this:
</p>



<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
&lt;%= blog.entries.render(self) %&gt;

</pre>




<p>
   And it renders blog posts to the front page.
</p>
</div>

</div>

<div id="outline-container-20_10" class="outline-3">
<h3 id="sec-20_10">Rendering a <code>TagList</code> </h3>
<div class="outline-text-3" id="text-20_10">

<p>   Back at the beginning of this chapter, we said we'd like to be able
   to write the following code as part of our
   <code>app/views/posts/_post.html.erb</code> partial:
</p>


<div class="listing">

<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">div</span> <span class="org-variable-name">class</span>=<span class="org-string">"entry_tags"</span>&gt;Tags: 
  &lt;%= post.tags.render(self) %&gt;
&lt;/<span class="org-function-name">div</span>&gt;
<span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">... </span><span class="org-comment-delimiter">--&gt;</span>

</pre>


<div class="caption">Telling a TagList to render itself</div>
</div>


<p>
   The first step to making this work the way we want is to make sure
   the <code>tags</code> collection gets exhibited. Which means we first need to
   make the <code>tags</code> collection accessible in the first place. Remember,
   <code>#tags</code> is added by the <code>Taggable</code> wrapper, it's not an intrinsic
   feature of <code>Post</code>.
</p>
<p>
   We'll kill to birds with one stone:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">PostExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">def</span> <span class="org-function-name">tags</span>
    exhibit(<span class="org-type">Taggable</span>(to_model).tags)
  <span class="org-keyword">end</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Exposiong tags in PostExhibit</div>
</div>


<p>
   Calling <code>#tags</code> on an exhibited <code>Post</code> now gets us the exhibited
   <code>TagList</code> associated with that post.
</p>
<p>
   <code>TagList</code> is <code>Enumerable</code>, so it will have <code>EnumerableExhibit</code>
   added to it. Unfortunately, this doesn't give us quite what we
   need. <code>EnumerableExhibit</code> works well for rendering collections of
   render-able objects. But the tags in <code>TagList</code> are just strings,
   and we don't have a <code>StringExhibit</code>. Nor are we sure we want one.
</p>
<p>
   Instead, we'll create a dirt-simple <code>TagListExhibit</code>.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-comment-delimiter"># </span><span class="org-comment">app/exhibits/tag_list_exhibit.rb</span>
<span class="org-keyword">class</span> <span class="org-type">TagListExhibit</span> &lt; <span class="org-type">Exhibit</span>
  <span class="org-keyword">def</span> <span class="org-function-name">self.applicable_to?</span>(object)
    object_is_any_of?(object, <span class="org-string">'TagList'</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">TagListExhibit</div>
</div>


<p>
   Wait a sec… that doesn't actually <i>do</i> anything, does it? In
   fact, we don't need it to do much. So long as it comes after
   <code>EnumerableExhibit</code> in the list of exhibits, it will override that
   exhibit's <code>#render</code> by dint of being the "outermost" exhibit. Which
   means it will use the default <code>Exhibit#render</code>, which means it will
   look for a partial named <code>/tag_lists/tag_list</code>. Which we then
   dutifully provide:
</p>


<div class="listing">

<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/tag_lists/_tag_list.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">ul</span> <span class="org-variable-name">class</span>=<span class="org-string">"tags"</span>&gt;
  &lt;%= render partial: <span class="org-string">"/tags/tag_item"</span>, collection: tag_list %&gt;
&lt;/<span class="org-function-name">ul</span>&gt;

</pre>


<div class="caption">A partial for tag lists</div>
</div>


<p>
   The <code>/tags/tag_item</code>, as you may recall from earlier, renders <code>/tags/tag</code>
   inside an <code>&lt;LI&gt;</code> tag, and <code>/tags/tag</code> renders the tag as a link to
   all tagged posts.
</p>



<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/tags/_tag_item.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">li</span>&gt;&lt;%= render partial: <span class="org-string">"/tags/tag"</span>, object: tag_item %&gt;&lt;/<span class="org-function-name">li</span>&gt;

</pre>





<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/tags/_tag.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;%= link_to tag.to_s, root_path(tag: tag.to_s) %&gt;

</pre>




<p>
Now anywhere we exhibit a <code>TagList</code>, we can tell it to <code>#render</code>
itself and it will generate an unordered list. With a little CSS (not
shown) we can make this work anywhere we show a list of tags.
</p>
</div>

</div>

<div id="outline-container-20_11" class="outline-3">
<h3 id="sec-20_11">Bringing it all back home </h3>
<div class="outline-text-3" id="text-20_11">


<p>
   We opened this chapter with some code showing how we would <i>like</i>
   to write the <code>/posts/post</code> template. Let's take a look at it again,
   alongside the original template, now that we've done the work to
   make the new version render successfully.
</p>


<div class="listing">

<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">old </span><span class="org-comment-delimiter">--&gt;</span>
&lt;% entry = exhibit(entry, self) %&gt;
&lt;<span class="org-function-name">article</span>&gt;
  &lt;<span class="org-function-name">header</span>&gt;
    &lt;<span class="org-function-name">p</span>&gt;&lt;<span class="org-function-name">time</span> <span class="org-variable-name">pubdate</span>=<span class="org-string">"pubdate"</span>&gt;&lt;%= entry.pubdate %&gt;&lt;/<span class="org-function-name">time</span>&gt;&lt;/<span class="org-function-name">p</span>&gt;
    &lt;<span class="org-function-name">h3</span>&gt;&lt;%= entry.title %&gt;&lt;/<span class="org-function-name">h3</span>&gt;
    &lt;<span class="org-function-name">p</span> <span class="org-variable-name">class</span>=<span class="org-string">"entry_tags"</span>&gt;Tags: 
      &lt;<span class="org-function-name">span</span> <span class="org-variable-name">class</span>=<span class="org-string">"tags"</span>&gt;&lt;%= Taggable(entry).tags %&gt;&lt;/<span class="org-function-name">span</span>&gt;
    &lt;/<span class="org-function-name">p</span>&gt;
  &lt;/<span class="org-function-name">header</span>&gt;
  &lt;%= entry.render_body %&gt;
&lt;/<span class="org-function-name">article</span>&gt;

</pre>


<div class="caption">The old post template</div>
</div>


<div class="listing">

<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">new </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">article</span>&gt;
  &lt;<span class="org-function-name">header</span>&gt;
    &lt;<span class="org-function-name">p</span>&gt;&lt;<span class="org-function-name">time</span> <span class="org-variable-name">pubdate</span>=<span class="org-string">"pubdate"</span>&gt;&lt;%= post.pubdate %&gt;&lt;/<span class="org-function-name">time</span>&gt;&lt;/<span class="org-function-name">p</span>&gt;
    &lt;<span class="org-function-name">h3</span>&gt;&lt;%= post.title %&gt;&lt;/<span class="org-function-name">h3</span>&gt;
    &lt;<span class="org-function-name">div</span> <span class="org-variable-name">class</span>=<span class="org-string">"entry_tags"</span>&gt;Tags: 
      &lt;%= post.tags.render(self) %&gt;
    &lt;/<span class="org-function-name">div</span>&gt;
  &lt;/<span class="org-function-name">header</span>&gt;
  &lt;%= post.render_body(self) %&gt;
&lt;/<span class="org-function-name">article</span>&gt;

</pre>


<div class="caption">The new post template</div>
</div>


<p>
Let's also take a look at the revised <code>/blog/index</code> template within
which this template is rendered.
</p>


<div class="listing">

<pre class="src src-html"><span class="org-comment-delimiter">&lt;!-- </span><span class="org-comment">app/views/blog/index.html.erb </span><span class="org-comment-delimiter">--&gt;</span>
&lt;<span class="org-function-name">h1</span>&gt;&lt;%= blog.title %&gt;&lt;/<span class="org-function-name">h1</span>&gt;
&lt;<span class="org-function-name">h2</span> <span class="org-variable-name">class</span>=<span class="org-string">"tagline"</span>&gt;&lt;%= blog.subtitle %&gt;&lt;/<span class="org-function-name">h2</span>&gt;
&lt;%= blog.entries.render(self) %&gt;

</pre>


<div class="caption">The new blog/index template</div>
</div>


<p>
   Let's recap what we did:
</p>
<ol>
<li>We moved exhibiting of the <code>post</code> and <code>blog</code> object into their
      respective controllers. No more cluttering up templates with
      calls to <code>exhibit()</code>.
</li>
<li>By making "exhibited-ness" transitive, and making collections
      such as <code>ActiveRecord::Relation</code> exhibit-able, we made it
      possible to render the collection of blog entries with a
      straightforward:



<pre class="src src-ruby">blog.entries.render(<span class="org-variable-name">self</span>)

</pre>



</li>
<li>We extracted the wrapping of the <code>post</code> object with <code>Taggable()</code>
      into the post exhibit object.
</li>
<li>We made <code>TagList</code> exhibit-able, making the rendering of a list of
      tags have the exact same form as the rendering of the list of
      blog entries: <code>post.tags.render(self)</code>.
</li>
</ol>


<p>
   With these changes, we've taken a big step towards a "component",
   or "widget" style of page rendering. By enabling objects in the
   template to render themselves to the page, we've engaged the full
   power of polymorphism. We've introduced a significantly greater
   degree of flexibility to vary <i>what</i> is shown, <i>how</i> it is shown,
   and <i>where</i> it is shown independently.
</p>
<p>
   But we've still respected many Rails conventions. We still look for
   view templates in the conventional places. We still use the plain
   vanilla Rails RHTML views, along with the standard tag helpers, to
   take care of the actual rendering of HTML tags to the browser. We
   still follow the standard Rails workflow of: set up an object in
   the controller, then render its attributes in a template.
</p>
<p>
   In short, as with the other parts of this text we've tried to find
   a middle way. A little more decoupled and flexible than vanilla
   Rails style, but still close enough that someone new to the project
   could learn their way around within a few days.
</p>
</div>
</div>

</div>

<div id="outline-container-21" class="outline-2">
<h2 id="sec-21">Summary </h2>
<div class="outline-text-2" id="text-21">

<p>  Rather than a recap, this section is structured as a list of
  scenarios, with pointers back to the relevant sections.
</p>

</div>

<div id="outline-container-21_1" class="outline-3">
<h3 id="sec-21_1">Scenarios </h3>
<div class="outline-text-3" id="text-21_1">



</div>

<div id="outline-container-21_1_1" class="outline-4">
<h4 id="sec-21_1_1">You are beginning a new application </h4>
<div class="outline-text-4" id="text-21_1_1">

<p>    <a href="#sec-4">Work from the outside in</a>. Define what your screens should look
    like, and let that drive out your business objects.
</p>
</div>

</div>

<div id="outline-container-21_1_2" class="outline-4">
<h4 id="sec-21_1_2">Your need business objects that don't exist yet in order to flesh out views </h4>
<div class="outline-text-4" id="text-21_1_2">

<p>    Use <a href="#sec-5-1">placeholder objects</a> until the real objects exist.
</p>
</div>

</div>

<div id="outline-container-21_1_3" class="outline-4">
<h4 id="sec-21_1_3">You are writing view templates </h4>
<div class="outline-text-4" id="text-21_1_3">

<p>    <a href="#sec-18">Respect controller privacy</a> by accessing instance variables using
    accessor methods.
</p>
</div>

</div>

<div id="outline-container-21_1_4" class="outline-4">
<h4 id="sec-21_1_4">A view requires an ActiveRecord-style object in order to function correctly </h4>
<div class="outline-text-4" id="text-21_1_4">

<p>    <a href="#sec-6-1">Use ActiveModel</a> to make non-ActiveRecord models compatible with
    Rails helpers.
</p>
</div>

</div>

<div id="outline-container-21_1_5" class="outline-4">
<h4 id="sec-21_1_5">You are writing business models </h4>
<div class="outline-text-4" id="text-21_1_5">

<p>    Start with <a href="#sec-5-4">plain objects.</a> Leave persistence for later on. Listen
    to the <a href="#sec-5-5">language of the domain</a>. Organize objects into a <a href="#sec-6-4">roughly tree-like structure</a> with a single root. Empower models to <a href="#sec-19">mediate access to their children</a>.
</p>
</div>

</div>

<div id="outline-container-21_1_6" class="outline-4">
<h4 id="sec-21_1_6">An object needs a way to make new instances of model </h4>
<div class="outline-text-4" id="text-21_1_6">

<p>    Don't hard-code the dependency on another class. Instead, <a href="#sec-5-2">inject a callable factory</a> that the object can use to manufacture
    objects. Use <a href="#sec-8-1">sensible defaults</a> to keep client code from having to
    always supply the dependency.
</p>
</div>

</div>

<div id="outline-container-21_1_7" class="outline-4">
<h4 id="sec-21_1_7">A model collaborates with another model or a collection of other models </h4>
<div class="outline-text-4" id="text-21_1_7">

<p>    <a href="#sec-5-3">Don't hard-code assumptions</a> about the class of a collaborator.
</p>
</div>

</div>

<div id="outline-container-21_1_8" class="outline-4">
<h4 id="sec-21_1_8">A set of model methods are only needed in certain contexts </h4>
<div class="outline-text-4" id="text-21_1_8">

<p>    Consider factoring those methods out into a discrete <a href="#sec-17-7">role</a>.
</p>
</div>

</div>

<div id="outline-container-21_1_9" class="outline-4">
<h4 id="sec-21_1_9">You are writing unit tests. You want them to be fast and to enforce good encapsulation </h4>
<div class="outline-text-4" id="text-21_1_9">

<p>    <a href="#sec-5">Keep your tests isolated</a> from Rails and from classes other than the
    one under test. <a href="#sec-7-1">Stub out modules and classes</a> that the objects under
    test reference but don't actually use in the context of the
    test. Use <a href="#sec-9">dependency injection</a> to preserve encapsulation. Inject
    only the <a href="#sec-9-1">minimum required interface</a>.
</p>
</div>

</div>

<div id="outline-container-21_1_10" class="outline-4">
<h4 id="sec-21_1_10">A non-ActiveRecord model needs to perform validations </h4>
<div class="outline-text-4" id="text-21_1_10">

<p>    Use <a href="#sec-11">ActiveModel::Validations</a> to add validations to arbitrary
    models.
</p>
</div>

</div>

<div id="outline-container-21_1_11" class="outline-4">
<h4 id="sec-21_1_11">A model must be displayed using different HTML depending on its state </h4>
<div class="outline-text-4" id="text-21_1_11">

<p>    Instead of introducing logic to the view, <a href="#sec-12">make an Exhibit object</a>
    for each different state of the model.
</p>
</div>

</div>

<div id="outline-container-21_1_12" class="outline-4">
<h4 id="sec-21_1_12">You are developing a complex view with many models </h4>
<div class="outline-text-4" id="text-21_1_12">

<p>    Consider using the <a href="#sec-12-2">Presenter pattern</a> to aggregate the needed models
    into a single object representing the whole view.
</p>
</div>

</div>

<div id="outline-container-21_1_13" class="outline-4">
<h4 id="sec-21_1_13">The logic matching Exhibits to models is getting complicated </h4>
<div class="outline-text-4" id="text-21_1_13">

<p>    Enable Exhibit classes <a href="#sec-12-5">to self-determine what models they are applicable to</a>.
</p>
</div>

</div>

<div id="outline-container-21_1_14" class="outline-4">
<h4 id="sec-21_1_14">You need to output similar chunks of HTML in more than one view </h4>
<div class="outline-text-4" id="text-21_1_14">

<p>    If the HTML is not related to a specific model, <a href="#sec-12-7">use a helper</a>.
</p>
</div>

</div>

<div id="outline-container-21_1_15" class="outline-4">
<h4 id="sec-21_1_15">You need an object to persist between requests </h4>
<div class="outline-text-4" id="text-21_1_15">

<p>    Turn the object <a href="#sec-6-3">into an app-wide Singleton</a> initialized at start-up.
</p>
</div>

</div>

<div id="outline-container-21_1_16" class="outline-4">
<h4 id="sec-21_1_16">You need to persist a model to the database </h4>
<div class="outline-text-4" id="text-21_1_16">

<p>    <a href="#sec-13-1">Treat ActiveRecord as a private model dependency</a>. Use <a href="#sec-14"><code>FigLeaf</code></a> to
    enforce the encapsulation. Write unit tests by <a href="#sec-13-7">mocking out the ActiveRecord parts</a> of your model and by <a href="#sec-13-8">stubbing out the Database with NullDB</a>.
</p>
</div>

</div>

<div id="outline-container-21_1_17" class="outline-4">
<h4 id="sec-21_1_17">You need to test that a database query functions correctly </h4>
<div class="outline-text-4" id="text-21_1_17">

<p>    Use an <a href="#sec-13-4">integration test</a> separate from your isolated unit tests.
</p>
</div>

</div>

<div id="outline-container-21_1_18" class="outline-4">
<h4 id="sec-21_1_18">A model needs to hook into various persistence lifecycle events </h4>
<div class="outline-text-4" id="text-21_1_18">

<p>    Prefer to <a href="#sec-15">override ActiveRecord methods</a> rather than using
    callbacks, if possible.
</p>
</div>

</div>

<div id="outline-container-21_1_19" class="outline-4">
<h4 id="sec-21_1_19">You want to more fully separate your business models from ActiveRecord </h4>
<div class="outline-text-4" id="text-21_1_19">

<p>    <a href="#sec-17-8-1">Use ActiveRecord objects as Row Data Gateways</a>. Consider using <a href="#sec-14-1">the Data Mapper pattern</a>.
</p>
</div>

</div>

<div id="outline-container-21_1_20" class="outline-4">
<h4 id="sec-21_1_20">You want to add a child collection without adding a new table </h4>
<div class="outline-text-4" id="text-21_1_20">

<p>    Use <a href="#sec-17-3">composition and object serialization</a>. <a href="#sec-17-8">Refactor to a separate model and table</a> once performance demands it.
</p>
</div>

</div>

<div id="outline-container-21_1_21" class="outline-4">
<h4 id="sec-21_1_21">You have replaced custom code with framework features, breaking the unit tests </h4>
<div class="outline-text-4" id="text-21_1_21">

<p>    <a href="#sec-13-6">Throw away your tests</a>. They have served their purpose.
</p>
</div>

</div>

<div id="outline-container-21_1_22" class="outline-4">
<h4 id="sec-21_1_22">You want to display the same view with various different scopes applied to the model </h4>
<div class="outline-text-4" id="text-21_1_22">

<p>    Use <a href="#sec-17-6">decorators to layer filters on a model</a>.
</p>
</div>

</div>

<div id="outline-container-21_1_23" class="outline-4">
<h4 id="sec-21_1_23">You want to expose a rich hypermedia RESTful API </h4>
<div class="outline-text-4" id="text-21_1_23">

<p>    Use <a href="#sec-16">Exhibits to combine business models with routing knowledge</a>.
</p>

</div>
</div>
</div>

</div>

<div id="outline-container-22" class="outline-2">
<h2 id="sec-22">Conclusion </h2>
<div class="outline-text-2" id="text-22">


<p>
  Well, that brings us to the end of our Object-Oriented Rails
  walkthrough. There's a lot more ground I could cover, but this is
  already a lot longer than I expected it to be.
</p>
<p>
  I've tried to cram a number of ideas for how to build web
  applications using Object-Oriented methods and Test-Driven Design
  into this text. Some of them are techniques I use daily; some I use
  occasionally; and a few I came up with as I was writing this. My
  hope is that your imagination has been sparked by one or two of
  these techniques, and you'll be inspired to try them out, or try
  variations, on your own projects.
</p>

</div>

<div id="outline-container-22_1" class="outline-3">
<h3 id="sec-22_1">Feelin' the burn </h3>
<div class="outline-text-3" id="text-22_1">

<blockquote>

<p>Pain don't hurt.
</p>
<p>
—Dalton, in "Roadhouse"
</p>
</blockquote>


<p>
A lot of the patterns we've looked at have been significantly more
work than following the traditional Rails development process. For
instance, we went to an awful lot of effort to avoid exposing common
ActiveRecord methods on the <code>Post</code> class.
</p>
<p>
Is all this extra effort worth it? Well, that really depends on the
application. In some ways a blog app was a terrible choice for
demonstrating these techniques, since if there's one type of app the
rails "golden path" is well suited for, it's a blog. I chose a blog
application as the demo because I wanted to go with a problem domain
anyone would be familiar with, so as to put the focus on the coding
strategies rather than the problem domain. As a result, a lot of those
strategies felt like overkill in this context.
</p>
<p>
But in my experience there are a lot of more complex Rails projects
out there which could have benefited from a little more "pain" in the
form of careful design decisions. Many of these pain points are really
canaries in a coal mine, letting us know that our code is becoming
overly coupled, our interfaces too large, our objects saddled with too
many responsibilities. Like muscles which have sat too long in one
position, we don't realize how knotted-up they've become until we
stand up and stretch. Disciplines like isolated tests, or <code>FigLeaf</code>,
keep us on our toes and keep those muscles from knotting up in the
first place.
</p>
</div>

</div>

<div id="outline-container-22_2" class="outline-3">
<h3 id="sec-22_2">TMTOWTDI </h3>
<div class="outline-text-3" id="text-22_2">


<p>
  I want to be clear that the techniques I've demonstrated here aren't
  "the Right Way" to do Rails; or even necessarily "the Avdi Grimm
  Way".  More than showing you a set of patterns and practices, what I
  hope you'll take away from this is that Rails is not a set of rigid
  walls confining your project. Your project is not a Rails project;
  it is a software project, which uses Rails to satisfy the need of
  projecting your business objects onto the web. Rails is not <i>the</i>
  framework; it is a part of your overall project architecture.
</p>
<p>
  As a project scales, its architecture must evolve and grow to
  support it. That may mean building new abstractions upon the
  foundation Rails gives you. This should not be a cause for
  consternation and fear, but a cause for excitement! One, because
  your project is successful enough to need new abstractions to
  support its continued evolution. Two, because you're working in Ruby
  and Rails, and it's all just objects, all the way down.
</p>
<p>
  So don't be afraid to build up your project's architecture. And in
  the process, don't be shy about lifting idioms and patterns from the
  Object-Oriented literature. There is very little new under the sun;
  whatever the problem you are facing, chances are Kent Beck already
  solved it in Smalltalk. Ruby didn't invent OO, it just made it ten
  times more fun. Likewise Rails didn't invent web programming
  patterns, it just stripped away all the ceremony and boilerplate.
</p>
</div>

</div>

<div id="outline-container-22_3" class="outline-3">
<h3 id="sec-22_3"><code>at_exit</code> </h3>
<div class="outline-text-3" id="text-22_3">

<p>  It's been a ton of work but a lot of fun writing this; I hope you
  get some value from it. If you have questions, corrections,
  suggestions, or objections, please don't hesitate to <a href="http://avdi.org">get in touch</a>. I'm always interested in seeing how other developers tackle
  the problems of sustainably growing and evolving a codebase.
</p>
<p>
  Thanks for reading, and happy hacking!
</p>
</div>
</div>

</div>

<div id="outline-container-23" class="outline-2">
<h2 id="sec-23">Appendix A: Further reading </h2>
<div class="outline-text-2" id="text-23">


<p>
  There has been a surge of interest in applying classic Object
  Oriented principles to Rails development lately. Here are some
  starting points for further reading.
</p>

</div>

<div id="outline-container-23_1" class="outline-3">
<h3 id="sec-23_1">General </h3>
<div class="outline-text-3" id="text-23_1">


<ul>
<li>The definitive compilation of web application patterns, and the
  source of many of the patterns found in Rails, is <a href="http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/">Patterns of Enterprise Application Architecture</a>, by Martin Fowler. Every web
  application developer should have a copy of this book within easy
  reach.
</li>
<li>No object-oriented programming book list is complete without Kent
  Beck's <a href="http://www.amazon.com/Smalltalk-Best-Practice-Patterns-Kent/dp/013476904X/"><span style="text-decoration:underline;">Smalltalk Best Practice Patterns</span></a>. Cleverly disguised as a
  book about Smalltalk, this book is really a comprehensive manual for
  constructing elegant, expressive code in any OO language.
</li>
<li>Steven Baker is writing an eBook on applying SOLID principles to
  Rails code, called <a href="http://solidrailsbook.com">Solid Rails</a>.
</li>
<li>Steve Klabnick wrote an article called "<a href="http://blog.steveklabnik.com/2011/09/06/the-secret-to-rails-oo-design.html">The Secret to Rails OO Design</a>"

</li>
<li>In September 2011 The Ruby Rogues podcast (of which I am a member)
  interviewed Jim Weirich on the topic of "<a href="http://rubyrogues.com/object-oriented-programming-in-rails-with-jim-weirich/">Object Oriented Programming with Rails</a>".
</li>
<li>My fellow <a href="http://codebenders.com">CodeBender</a> Piotr Solnica has written on the topic of
  "<a href="http://solnic.eu/2011/08/01/making-activerecord-models-thin.html">Making ActiveRecord Models Thin</a>".
</li>
<li>Gary Bernhardt has been offering up a wealth of information on clean
  OO design and writing fast, isolated tests in his <a href="https://www.destroyallsoftware.com/screencasts">Destroy All Software</a> video series.
</li>
<li>Greg Brown has been writing some great stuff on this topic; for
  instance, here's an article on applying <a href="http://blog.rubybestpractices.com/posts/gregory/055-issue-23-solid-design.html">SOLID Design Principles</a> to
  Ruby code based on his experience writing the Prawn PDF library.
</li>
<li>Nicholas Henry: "<a href="http://blog.firsthand.ca/2011/10/rails-is-not-your-application.html">Rails is Not Your Application</a>".
</li>
<li>Dan Croak wrote a <a href="http://robots.thoughtbot.com/post/14825364877/evaluating-alternative-decorator-implementations-in">comprehensive overview of Decorator implementations</a> in Ruby
</li>
<li>Nick Gauthier gave a <a href="http://ngauthier.com/2012/02/ruby-and-the-web.html">presentation on "Ruby and the Web"</a> in February
  2012 at <a href="http://bmoreonrails.org/">B'More on Rails</a>. In it, he talks about how Rails is actually
  closer to a <a href="http://en.wikipedia.org/wiki/Model_2">Model 2</a> architecture than to Model-View-Controller. He
  also explores what a more deliberately Object-Oriented web framework
  in Ruby might look like.
</li>
<li>Gary Bernhard has an alternative take on a Ruby web framework called
  <a href="https://github.com/garybernhardt/raptor">Raptor</a>. Quoting the README: "Raptor is an experimental web framework
  that encourages simple, decoupled objects. There are no base classes
  and as little 'DSL' as possible."
</li>
</ul>


</div>

</div>

<div id="outline-container-23_2" class="outline-3">
<h3 id="sec-23_2">Fast Tests and Mock Objects </h3>
<div class="outline-text-3" id="text-23_2">

<ul>
<li>Greg Moeck explains why <a href="http://gmoeck.github.com/2011/10/26/stubbing-is-not-enough.html">stubs are not enough</a>. I also really
     enjoyed his RubyConf 2011 presentation <a href="http://confreaks.net/videos/659-rubyconf2011-why-you-don-t-get-mock-objects">"Why You Don't Get Mock Objects"</a>.
</li>
<li>Corey Haines has been giving talks on <a href="http://confreaks.net/videos/641-gogaruco2011-fast-rails-tests">fast Rails tests</a>.
</li>
</ul>


</div>

</div>

<div id="outline-container-23_3" class="outline-3">
<h3 id="sec-23_3">Data-Context-Interaction </h3>
<div class="outline-text-3" id="text-23_3">

<p>   A number of Rails practitioners have begun exploring the
   application of the Data-Context-Interaction (DCI) pattern to Rails
   apps. DCI is the brainchild of the same people who came up with
   MVC, and offers some novel techniques for breaking down
   functionality along use-case boundaries. Here are some reading
   suggestions to get you started learning about DCI.
</p>
<ul>
<li>An <a href="http://www.artima.com/articles/dci_vision.html">article by the inventors of DCI</a> laying out the foundations of
    the pattern.
</li>
<li>Jim Gay is writing a <a href="http://www.clean-ruby.com/">book on using DCI in Ruby and Rails</a>. I've
    seen Jim present on this topic and he's at the forefront of
    applying this approach to Rails projects. I'm eagerly looking
    forward to reading his book.
</li>
<li>Andrzej Krzywda has a great <a href="http://andrzejonsoftware.blogspot.com/2011/02/dci-and-rails.html">intro post on DCI and Rails</a>.
</li>
<li>Mike Pack: <a href="http://mikepackdev.com/blog_posts/24-the-right-way-to-code-dci-in-ruby">The right way to code DCI in Ruby</a>.
</li>
</ul>


</div>

</div>

<div id="outline-container-23_4" class="outline-3">
<h3 id="sec-23_4">Presenters, decorators, and view models </h3>
<div class="outline-text-3" id="text-23_4">

<ul>
<li>Jay Fields:
<ul>
<li><a href="http://blog.jayfields.com/2006/09/rails-model-view-controller-presenter.html">Model View Controller + Presenter?</a> - the post that first
       introduced the Presenter concept.
</li>
<li><a href="http://blog.jayfields.com/2007/01/another-rails-presenter-example.html">Another Presenter Example</a>
</li>
<li><a href="http://blog.jayfields.com/2007/02/rails-presenters-additional-layer.html">Presenters - An Additional layer example</a>.
</li>
<li><a href="http://blog.jayfields.com/2007/03/rails-presenter-pattern.html">Presenter Pattern</a> - a formalization of the pattern.
</li>
<li><a href="http://blog.jayfields.com/2007/10/rails-rise-fall-and-potential-rebirth.html">Rise, Fall, and Potential Rebirth of the Presenter Pattern</a>. A
       retrospective look at the experiences Jay and others had
       applying Presenters to various projects.
</li>
</ul>

</li>
<li>Courtenay Gasking: <a href="http://web.archive.org/web/20100523060851/http://blog.caboo.se/articles/2007/8/23/simple-presenters">Simple Presenters</a>.
</li>
<li>Zach Dennis: <a href="http://spin.atomicobject.com/2008/01/27/the-exceptional-presenter/">The Exceptional Presenter</a>.
</li>
<li>Dmytro Shteflyuk: <a href="http://kpumuk.info/ruby-on-rails/simplifying-your-ruby-on-rails-code/">Simplifying your Ruby on Rails code: Presenter pattern, cells plugin</a>.
</li>
<li>Steve Klabnick: <a href="http://blog.steveklabnik.com/posts/2011-09-09-better-ruby-presenters">Better Ruby Presenters</a>. A follow-up to <a href="http://blog.steveklabnik.com/2011/09/06/the-secret-to-rails-oo-design.html">The Secret to Rails OO Design</a>, referenced earlier.
</li>
<li>Jeff Casimir: <a href="http://jumpstartlab.com/news/archives/2011/12/01/blow-up-your-views/">Blow Up Your Views</a>. Jeff encoded the concepts
     introduced in this presentation in his <a href="https://github.com/jcasimir/draper">Draper</a> gem.
</li>
<li>Martin Fowler <a href="http://www.martinfowler.com/eaaDev/uiArchs.html">summarizes GUI patterns</a>. Note: this article is more
     concerned with rich client-side GUI patterns than web GUIs.
</li>
<li><a href="http://en.wikipedia.org/wiki/Model_View_ViewModel">Model View ViewModel</a>. A pattern from the .NET/Silverlight world.
</li>
</ul>

</div>

</div>

<div id="outline-container-23_5" class="outline-3">
<h3 id="sec-23_5">Views </h3>
<div class="outline-text-3" id="text-23_5">

<ul>
<li><a href="https://github.com/jferris/effigy">Effigy</a> replaces your view templates with honest-to-goodness
     objects. Among other interesting implications, this means that
     instead of layouts you simply have a base class which defines
     boilerplate HTML, and then individual view subclasses override
     the parts of the base which they wish to customize.
</li>
<li><a href="https://github.com/voxdolo/decent_exposure">decent<sub>exposure</sub></a> enables you to decoratively set up your
     controller interfaces, and enforces the use of those interfaces.
</li>
<li><a href="http://apotomo.de/">Apotomo</a> is a view component framework for Rails.
</li>
<li>The <a href="http://martinfowler.com/eaaCatalog/twoStepView.html">Two-Step View</a> pattern from Patterns of Enterprise Application
     Architecture is a robust pattern for decoupling models from
     views.
</li>
</ul>

</div>

</div>

<div id="outline-container-23_6" class="outline-3">
<h3 id="sec-23_6">Rails </h3>
<div class="outline-text-3" id="text-23_6">

<ul>
<li>Rails 3 took massive strides towards being a modular framework
     which allows you to mix and match pieces, or swap in your own
     pieces when the stock ones aren't sufficient for your app. For
     understanding how the Rails puzzle fits together, and how to hook
     your own code into it, there is no better guide than <a href="http://www.amazon.com/Crafting-Rails-Applications-Development-Programmers/dp/1934356735/">Crafting Rails Applications</a>, by José Valim.
</li>
</ul>

</div>
</div>

</div>

<div id="outline-container-24" class="outline-2">
<h2 id="sec-24">Appendix B: Acceptance Tests </h2>
<div class="outline-text-2" id="text-24">


<p>
  Here is the acceptance test suite for the demo application. Step
  implementations and supporting files can all be found in the demo
  application source code.
</p>


<div class="listing">

<pre class="src src-feature"><span class="org-keyword">Feature:</span><span class="org-type"> Basic Blog</span>
  As a drying paint enthusiast
  I want to publish blog entries
  So that my friends can enjoy my fascinating hobby

<span class="org-keyword">  Scenario:</span><span class="org-function-name"> Visit home page</span>
<span class="org-keyword">    When</span> I go to the home page
<span class="org-keyword">    Then</span> I should see the blog title

<span class="org-keyword">  Scenario:</span><span class="org-function-name"> Post a text entry</span>
<span class="org-keyword">    When</span> I go to the home page
<span class="org-keyword">     And</span> I start a new post
<span class="org-keyword">     And</span> I fill in the title <span class="org-string">"First Post!"</span>
<span class="org-keyword">     And</span> I fill in the body <span class="org-string">"I just painted a fence!"</span>
<span class="org-keyword">     And</span> I submit the entry
<span class="org-keyword">     And</span> I return to the home page
<span class="org-keyword">    Then</span> I should see a post with title <span class="org-string">"First Post!"</span>
<span class="org-keyword">     And</span> the post body should be:
     <span class="org-string">"""</span>
<span class="org-string">     I just painted a fence!</span>
<span class="org-string">     """</span>

<span class="org-keyword">  Scenario:</span><span class="org-function-name"> Post a photo</span>
<span class="org-keyword">    When</span> I post an entry with these values:
<span class="org-org-table">    | name      | value                            |</span>
<span class="org-org-table">    | title     | Check it out, I painted the cat! |</span>
<span class="org-org-table">    | image_url | http://example.com/madcat.jpg    | </span>
<span class="org-keyword">    Then</span> I should see a post with title <span class="org-string">"Check it out, I painted the cat!"</span>
<span class="org-keyword">     And</span> the post should show image with URL <span class="org-string">"http://example.com/madcat.jpg"</span>

<span class="org-keyword">  Scenario:</span><span class="org-function-name"> Post many entries</span>
<span class="org-keyword">    When</span> I post the following entries in order:
<span class="org-org-table">    | title  | body           | tags |</span>
<span class="org-org-table">    | Post A | This is post A | a,z  |</span>
<span class="org-org-table">    | Post B | This is post B | b,z  |</span>
<span class="org-org-table">    | Post C | This is post C | c,x  |</span>
<span class="org-keyword">    Then</span> I should see the following entries in order:
<span class="org-org-table">    | title  | body           |</span>
<span class="org-org-table">    | Post C | This is post C |</span>
<span class="org-org-table">    | Post B | This is post B |</span>
<span class="org-org-table">    | Post A | This is post A |</span>
<span class="org-keyword">    And</span> I should see tags: a,b,c,x,z
<span class="org-keyword">    When</span> I look at posts tagged <span class="org-string">"z"</span>
<span class="org-keyword">    Then</span> I should see the following entries in order:
<span class="org-org-table">    | title  | body           |</span>
<span class="org-org-table">    | Post B | This is post B |</span>
<span class="org-org-table">    | Post A | This is post A |</span>

</pre>


<div class="caption">The acceptance suite</div>
</div>

</div>

</div>

<div id="outline-container-25" class="outline-2">
<h2 id="sec-25">Appendix C: Decoration vs. Dynamic Module Extension </h2>
<div class="outline-text-2" id="text-25">

<p>  /This section adapted from a <a href="http://avdi.org/devblog/2012/01/31/decoration-is-best-except-when-it-isnt/">blog post</a> originally published January   31, 2012./
</p>
<p>  
  Having trouble choosing between Decorators and dynamically adding
  modules to objects? Let's examine the pros and cons.
</p>

</div>

<div id="outline-container-25_1" class="outline-3">
<h3 id="sec-25_1">Composing an adventure </h3>
<div class="outline-text-3" id="text-25_1">


<p>
Consider an adventure game, with objects representing player characters.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Character</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Character class</div>
</div>




<p>
A <code>Character</code> can be described:
</p>




<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Character</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Character#describe</div>
</div>


<p>
A <code>Character</code> can look, listen, and smell his environment:
</p>




<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Character</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Character sense methods</div>
</div>





<pre class="src src-ruby"><span class="org-string">&lt;&lt;definitions</span>&gt;&gt;
cohen = <span class="org-type">Character</span>.new
cohen.describe
cohen.look
cohen.listen

</pre>




: You are a dashing, rugged adventurer.
: You can see a lightning bug.
: You can see a guttering candle.
: You hear a distant waterfall.

<p>
The character can also consult all of his senses at once:
</p>




<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">Character</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Character#observe</div>
</div>



<pre class="src src-ruby"><span class="org-string">&lt;&lt;definitions</span>&gt;&gt;
cohen = <span class="org-type">Character</span>.new
cohen.observe

</pre>




: You can see a lightning bug.
: You can see a guttering candle.
: You hear a distant waterfall.
: You smell egg salad.

<p>
Characters can have various effects conferred upon them by items,
potions, etc. A simple example is a hat:
</p>


<div class="listing">

<pre class="src src-ruby">require <span class="org-string">'delegate'</span>
<span class="org-keyword">class</span> <span class="org-type">BowlerHatDecorator</span> &lt; <span class="org-type">SimpleDelegator</span>
  <span class="org-keyword">def</span> <span class="org-function-name">describe</span>
    <span class="org-keyword">super</span>
    puts <span class="org-string">"A jaunty bowler cap sits atop your head."</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">BowlerHatDecorator</div>
</div>


<p>
At each turn of the game, the <code>Character</code> object will be decorated
with whatever effects are currently active, and then a user command
will be performed:
</p>



<pre class="src src-ruby"><span class="org-string">&lt;&lt;definitions</span>&gt;&gt;
cohen = <span class="org-type">BowlerHatDecorator</span>.new(<span class="org-type">Character</span>.new)
cohen.describe

</pre>




<pre class="example">You are a dashing, rugged adventurer.
A jaunty bowler cap sits atop your head.
</pre>


</div>

</div>

<div id="outline-container-25_2" class="outline-3">
<h3 id="sec-25_2">Seeing in the dark </h3>
<div class="outline-text-3" id="text-25_2">


<p>
A more interesting effect is conferred by an infravision potion. It
enables your character to see in the dark.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">InfravisionPotionDecorator</span> &lt; <span class="org-type">SimpleDelegator</span>
  <span class="org-keyword">def</span> <span class="org-function-name">describe</span>
    <span class="org-keyword">super</span>
    puts <span class="org-string">"Your eyes glow dull red."</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">look</span>
    <span class="org-keyword">super</span>
    look_infrared
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">look_infrared</span>
    list(<span class="org-string">"You can see"</span>, [<span class="org-string">"the ravenous bugblatter beast of traal"</span>])
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">InfravisionPotionDecorator</div>
</div>


<p>
While the character is experiencing the effects of an <a href="http://nethack.wikia.com/wiki/Infravision">infravision</a>
potion, his powers of observation increase:
</p>





<pre class="src src-ruby"><span class="org-string">&lt;&lt;definitions</span>&gt;&gt;
cohen = <span class="org-type">InfravisionPotionDecorator</span>.new(<span class="org-type">Character</span>.new)
cohen.describe
cohen.look

</pre>




<pre class="example">You are a dashing, rugged adventurer.
Your eyes glow dull red.
You can see a lightning bug.
You can see a guttering candle.
You can see the ravenous bugblatter beast of traal.
</pre>


<p>
There's just one little problem that crops up when the <code>#observe</code>
method is called.
</p>



<pre class="src src-ruby"><span class="org-string">&lt;&lt;definitions</span>&gt;&gt;
cohen = <span class="org-type">InfravisionPotionDecorator</span>.new(<span class="org-type">Character</span>.new)
cohen.observe

</pre>




<pre class="example">You can see a lightning bug.
You can see a guttering candle.
You hear a distant waterfall.
You smell egg salad.
</pre>


<p>
Hey, where'd that bugblatter beast go?
</p>
<p>
The <code>Character#observe</code> method calls <code>#look</code>—but since the wrapped
object has no knowledge whatsoever of the
<code>InfravisionPotionDecorator</code>, it calls the original definition of
<code>#look</code>, not the one which also calls <code>#look_infrared</code>.
</p>
<p>
Now, granted, this flaw actually works out in our intrepid
adventurer's favor, since the ravenous bugblatter beast of Traal is so
stupid it thinks that if you can't see it, it can't see you. But never
mind that: it's still a bug, and bugs must be blattered.
</p>
</div>

</div>

<div id="outline-container-25_3" class="outline-3">
<h3 id="sec-25_3">A solution that's all wet </h3>
<div class="outline-text-3" id="text-25_3">


<p>
We could patch this flaw by overriding <code>#observe</code> as well in the
decorator:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">InfravisionPotionDecorator</span> &lt; <span class="org-type">SimpleDelegator</span>
  <span class="org-keyword">def</span> <span class="org-function-name">observe</span>
    look
    listen
    smell
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Overriding #observe in the InfravisionPotionDecorator</div>
</div>


<p>
Yuck! This is the exact same implementation as in <code>Character</code>, just
copied and pasted so that the correct implementation of <code>#look</code> will
be called. Clearly this is non-DRY. But even worse, we've introduced a
nasty variety of <a href="http://blog.rubybestpractices.com/posts/gregory/056-issue-24-connascence.html">connascence</a>. Every time we introduces a new
<code>Character</code> method which calls <code>#look</code>, we'll have to cull through
every single effect decorator which overrides <code>#look</code>, adding
copy-and-pasted versions of the new method so that it doesn't
accidentally ignore the effect-wrapped version. Double yuck!
</p>
</div>

</div>

<div id="outline-container-25_4" class="outline-3">
<h3 id="sec-25_4">Modules to the rescue </h3>
<div class="outline-text-3" id="text-25_4">


<p>
In Ruby, there is an easy solution: extend the character with a module
instead of a decorator.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">module</span> <span class="org-type">InfravisionPotionModule</span>
  <span class="org-keyword">def</span> <span class="org-function-name">describe</span>
    <span class="org-keyword">super</span>
    puts <span class="org-string">"Your eyes glow dull red."</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">look</span>
    <span class="org-keyword">super</span>
    look_infrared
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">look_infrared</span>
    list(<span class="org-string">"You can see"</span>, [<span class="org-string">"the ravenous bugblatter beast of traal"</span>])
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">InfravisionPotionModule</div>
</div>





<pre class="src src-ruby"><span class="org-string">&lt;&lt;definitions</span>&gt;&gt;
cohen = <span class="org-type">Character</span>.new.extend(<span class="org-type">InfravisionPotionModule</span>)
cohen.observe

</pre>




: You can see a lightning bug.
: You can see a guttering candle.
: You can see the ravenous bugblatter beast of traal.
: You hear a distant waterfall.
: You smell egg salad.

<p>
This time the overridden method is added directly to the object via
its singleton class. So even the object's own unmodified methods get
the new infravision version of <code>#look</code>.
</p>
<p>
Sadly, by enabling him to see the monster we have sealed our
protagonist's fate. But at least we fixed the bug!
</p>
</div>

</div>

<div id="outline-container-25_5" class="outline-3">
<h3 id="sec-25_5">Other solutions </h3>
<div class="outline-text-3" id="text-25_5">


<p>
That's not the only way to fix the problem. We might, for instance,
decompose our <code>Character</code> into individual body parts, with separate
attributes for <code>eyes</code>, <code>nose</code>, and <code>ears</code>. The <code>Character</code> could then
delegate the individual senses to their respective organs:
</p>


<div class="listing">

<pre class="src src-ruby">require <span class="org-string">'forwardable'</span>
<span class="org-keyword">class</span> <span class="org-type">Character</span>
  extend <span class="org-type">Forwardable</span>

  attr_accessor <span class="org-constant">:eyes</span>
  attr_accessor <span class="org-constant">:ears</span>
  attr_accessor <span class="org-constant">:nose</span>

  <span class="org-keyword">def</span>_delegator <span class="org-constant">:eyes</span>, <span class="org-constant">:look</span>
  <span class="org-keyword">def</span>_delegator <span class="org-constant">:ears</span>, <span class="org-constant">:listen</span>
  <span class="org-keyword">def</span>_delegator <span class="org-constant">:nose</span>, <span class="org-constant">:smell</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Decomposing Character into body parts</div>
</div>


<p>
A potion of infravision might then replace the character's eyes with
infrared-enhanced ones:
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-keyword">class</span> <span class="org-type">InfravisionPotionDecorator</span> &lt; <span class="org-type">SimpleDelegator</span>
  <span class="org-keyword">class</span> <span class="org-type">EyesDecorator</span> &lt; <span class="org-type">SimpleDelegator</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">end</span>

  <span class="org-keyword">def</span> <span class="org-function-name">initialize</span>(character)
    <span class="org-keyword">super</span>(character)
    character.eyes = <span class="org-type">EyesDecorator</span>.new(character.eyes)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">Decomposing the InfravisionPotionDecorator</div>
</div>


<p>
…but this is an awful lot of code and ceremony. It might make sense
someday, but right now it feels like massive overkill. The module
extension approach, by contrast, is only a small change from our
original version.
</p>
</div>

</div>

<div id="outline-container-25_6" class="outline-3">
<h3 id="sec-25_6">Are decorators overrated? </h3>
<div class="outline-text-3" id="text-25_6">


<p>
So what can we learn from this? When composing objects, Is it always
better to use module extension than decoration?
</p>
<p>
In a word, no. For one thing, decoration is a simpler structure to
understand. Given object <code>A</code> wrapped in object <code>B</code> wrapped in object
<code>C</code>, it's easy to reason about how method calls will be
handled. They'll always go one-way: a method in object <code>A</code> will never
reference a method in <code>B</code> or <code>C</code>.By contrast, method calls in a
module-extended object can bounce around the inheritance hierarchy in
unexpected ways.
</p>
<p>
A second consideration is that once you've extended an object with a
module, its behavior is changed for <b>all</b> clients, including
itself. You can't interact with the "unadorned" object anymore. You
might extend an object for your own purposes, then pass it to a
third-party method which doesn't understand the modified behavior of
the object and barfs as a result.
</p>
<p>
Finally, there's a performance penalty. While it varies from
implementation to implementation, dynamically extending objects can
slow down your code as a result of the method cache being
invalidated. Of course, as with all performance-related guidelines, be
sure to profile before making any code changes based on this point.
</p>
</div>

</div>

<div id="outline-container-25_7" class="outline-3">
<h3 id="sec-25_7">Conclusion </h3>
<div class="outline-text-3" id="text-25_7">


<p>
Decoration and module extension are both viable ways to compose
objects in Ruby. Which to use is not a simple black-or-white choice;
it depends on the purpose of the composition. 
</p>
<p>
For applications where you want to adorn an object with some extra
functionality, or modify how it presents itself, a decorator is
probably the best bet. Decorators are great for creating Presenters,
where we just want to change an object's "face" in a specific
context. 
</p>
<p>
On the other hand, when building up a composite object at runtime
object out of individual "aspects" or "facets", module extension may
make more sense. Judicious use of module extension can lead to a kind
of "emergent behavior" which is hard to replicate with decoration or
delegation.
</p></div>
</div>

</div>

<div id="outline-container-26" class="outline-2">
<h2 id="sec-26">Appendix D: Test Helper Organization </h2>
<div class="outline-text-2" id="text-26">

<p>  In the course of this text we introduced a variation on the
  traditional Rails <code>spec/spec_helper.rb</code> scheme for common
  specs/tests setup code. Instead of a single helper file, we broke up
  the helpers based on the type of test, so that fast, isolated tests
  wouldn't be slowed down by unneeded setup when run by themselves.
</p>
<p>
  We introduced this code in a glancing, piecemeal fashion as we
  constructed the tests, and you might have been left a little unclear
  as to exactly what goes where. In this section I'll lay out the test
  helper files and explain the purpose of each.
</p>
<p>
  I've also reorganized and tweaked the test helpers in my demo
  codebase since completing the main text. This section reflects the
  more recent version of the helpers.
</p>

</div>

<div id="outline-container-26_1" class="outline-3">
<h3 id="sec-26_1"><code>spec/spec_helper_lite.rb</code> </h3>
<div class="outline-text-3" id="text-26_1">


<p>
   The purpose of this file is to supply the prerequisites for purely
   isolated model tests, without burdening the tests with excessive
   startup time. Notably, it eschews both the Rails environment and
   Bundler setup, which means that any needed gems must be explicitly
   required. It also means the tests must be run in an environment
   where the correct gem versions are available, e.g. in the context
   of an RVM gemset which has been initialized using <code>bundle install</code>.
</p>
<p>
   Minitest is explicitly specified with <code>gem</code>, in order to get the
   newer gem version of Minitest instead of the one that comes with
   Ruby.
</p>
<p>
   RR ("Double Ruby") is also required, for mocking and stubbing.
</p>
<p>
   Finally, this is the file which defines <code>stub_module</code> and
   <code>stub_class</code>, which enable us to stub out references to other
   classes and modules without actually loading the code for them.
</p>


<div class="listing">

<pre class="src src-ruby"><span class="org-type">ENV</span>[<span class="org-string">'RAILS_ENV'</span>] ||= <span class="org-string">'test'</span>
gem <span class="org-string">'minitest'</span> <span class="org-comment-delimiter"># </span><span class="org-comment">demand gem version</span>
require <span class="org-string">'minitest/autorun'</span>
require <span class="org-string">'rr'</span>
require <span class="org-string">'ostruct'</span>
<span class="org-variable-name">$:</span> &lt;&lt; <span class="org-type">File</span>.expand_path(<span class="org-string">'../lib'</span>, <span class="org-type">File</span>.dirname(__FILE__))
<span class="org-keyword">class</span> <span class="org-type">MiniTest</span>::<span class="org-type">Unit</span>::<span class="org-type">TestCase</span>
  include <span class="org-type">RR</span>::<span class="org-type">Adapters</span>::<span class="org-type">MiniTest</span>
<span class="org-keyword">end</span>
<span class="org-keyword">def</span> <span class="org-function-name">stub_module</span>(full_name, &amp;block)
  stub_class_or_module(full_name, <span class="org-type">Module</span>)
<span class="org-keyword">end</span>
<span class="org-keyword">def</span> <span class="org-function-name">stub_class</span>(full_name, &amp;block)
  stub_class_or_module(full_name, <span class="org-type">Class</span>)
<span class="org-keyword">end</span>
<span class="org-keyword">def</span> <span class="org-function-name">stub_class_or_module</span>(full_name, kind, &amp;block)
  full_name.to_s.split(<span class="org-string">/::/</span>).inject(<span class="org-type">Object</span>) <span class="org-keyword">do</span> |context, name|
    <span class="org-keyword">begin</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">Give autoloading an opportunity to work</span>
      context.const_get(name)
    <span class="org-keyword">rescue</span> <span class="org-type">NameError</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">Defer substitution of a stub module/class to the last possible</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">moment by overloading const_missing. We use a module here so</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">we can "stack" const_missing definitions for various</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">constants.</span>
      mod = <span class="org-type">Module</span>.new <span class="org-keyword">do</span>
        define_method(<span class="org-constant">:const_missing</span>) <span class="org-keyword">do</span> |missing_const_name|
          <span class="org-keyword">if</span> missing_const_name.to_s == name.to_s
            value = kind.new
            const_set(name, value)
            value
          <span class="org-keyword">else</span>
            <span class="org-keyword">super</span>(missing_const_name)
          <span class="org-keyword">end</span>
        <span class="org-keyword">end</span>
      <span class="org-keyword">end</span>
      context.extend(mod)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">spec_helper_lite.rb</div>
</div>


</div>

</div>

<div id="outline-container-26_2" class="outline-3">
<h3 id="sec-26_2"><code>spec/spec_helper_nulldb.rb</code> </h3>
<div class="outline-text-3" id="text-26_2">


<p>
   This file builds on <code>spec_helper_lite.rb</code> and adds NullDB helpers
   for stubbing out database interactions. It was originally part of
   <code>spec_helper_lite.rb</code>, but I separated it out to its own file when
   I removed Bundler setup from <code>spec_helper_lite.rb</code>.
</p>


<div class="listing">

<pre class="src src-ruby">require <span class="org-string">"bundler/setup"</span>
require_relative <span class="org-string">'spec_helper_lite'</span>
<span class="org-keyword">module</span> <span class="org-type">SpecHelpers</span>
  <span class="org-keyword">def</span> <span class="org-function-name">setup_nulldb</span>
    require <span class="org-string">'nulldb'</span>
    schema_path = <span class="org-type">File</span>.expand_path(<span class="org-string">'../db/schema.rb'</span>, <span class="org-type">File</span>.dirname(__FILE__))
    <span class="org-type">NullDB</span>.nullify(<span class="org-constant">:schema</span> =&gt; schema_path)
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">teardown_nulldb</span>
    <span class="org-type">NullDB</span>.restore
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">spec_helper_nulldb.rb</div>
</div>


</div>

</div>

<div id="outline-container-26_3" class="outline-3">
<h3 id="sec-26_3"><code>spec/spec_helper_full.rb</code> </h3>
<div class="outline-text-3" id="text-26_3">


<p>
   This file adds the full Rails environment to the setup already done
   in <code>spec_helper_lite.rb</code>. It also sets up <code>DatabaseCleaner</code> for
   integration tests.
</p>


<div class="listing">

<pre class="src src-ruby">require_relative <span class="org-string">'spec_helper_lite'</span>
require_relative <span class="org-string">'../config/environment.rb'</span>
<span class="org-keyword">module</span> <span class="org-type">SpecHelpers</span>
  <span class="org-keyword">def</span> <span class="org-function-name">setup_database</span>
    <span class="org-type">DatabaseCleaner</span>.strategy = <span class="org-constant">:transaction</span>
    <span class="org-type">DatabaseCleaner</span>.clean_with(<span class="org-constant">:truncation</span>)
    <span class="org-type">DatabaseCleaner</span>.start
  <span class="org-keyword">end</span>
  <span class="org-keyword">def</span> <span class="org-function-name">teardown_database</span>
    <span class="org-type">DatabaseCleaner</span>.clean
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

</pre>


<div class="caption">spec_helper_full.rb</div>
</div>

</div>
</div>

</div>

<div id="outline-container-27" class="outline-2">
<h2 id="sec-27">Credits </h2>
<div class="outline-text-2" id="text-27">

<ul>
<li>"Wet Paint" photo by <a href="http://www.flickr.com/photos/bixentro/2828929186/">"bixentro" on Flickr</a>, licensed under a
    <a href="http://creativecommons.org/licenses/by/2.0/">Creative Commons Attribution 2.0 Generic License</a>.
</li>
<li>Some versions of this book may embed the "Inconsolata" font by
    Raph Levien, which is licensed under the SIL Open Font License. A
    copy of this license is included in the book's download package.
</li>
</ul>








</div>
</div>
<div id="postamble">
<p class="keyboard-hints">
  Keyboard shortcuts: <span class="key">n</span> for next page, <span class="key">p</span> for previous, <span class="key">?</span> for help.
</p>
<div class="cta">
  <a href="http://devblog.avdi.org/store/">
    <img class="cover-thumb" src="http://objectsonrails.com/images/oor-paperback-small.png">
  </a>
  
  <p>
    Enjoying <cite>Objects on Rails</cite>? Why not take it with you!
    For $5, you can download <strong>DRM-free PDF, EPUB, and Kindle
    versions</strong> of this book, along with the <strong>full source
    code</strong>. Click on the big button below to buy now!
    Or, <a href="http://devblog.avdi.org/store/">click here</a> to
    shop for the <a href="http://devblog.avdi.org/store/">Objects on
    Rails "Sponsor Edition"</a> and other products.
  </p>

  <div class="dpd">
    <a target="_top" class="dpdcart iframe" href="https://getdpd.com/v2/cart/add/6855/27062/26612"><img border="0" alt="Add to Cart" src="https://getdpd.com/images/buy_buttons/atc/solid3/buy-now_1-6_orange.png"></a>
  </div>
</div>

<nav class="postamble-nav">
  <ul>
    <li><a href="http://objectsonrails.com" rel="top">Home</a></li>
    <li><a href="https://groups.google.com/d/forum/objects-on-rails">Discussion Group</a></li>
    <li><a href="http://devblog.avdi.org">Virtuous Code Blog</a></li>
    <li><iframe id="twitter-widget-0" scrolling="no" frameborder="0" allowtransparency="true" class="twitter-share-button twitter-share-button-rendered twitter-tweet-button" style="position: static; visibility: visible; width: 61px; height: 20px;" title="Twitter Tweet Button" src="https://platform.twitter.com/widgets/tweet_button.8f9047c344e062fa7c7ada2fa8332f75.en.html#dnt=false&amp;id=twitter-widget-0&amp;lang=en&amp;original_referer=http%3A%2F%2Fwebcache.googleusercontent.com%2Fsearch%3Fq%3Dcache%3Aij0anEYo75YJ%3Aobjectsonrails.com%2F%2B%26cd%3D1%26hl%3Den%26ct%3Dclnk%26gl%3Dvn&amp;size=m&amp;text=Objects%20on%20Rails&amp;time=1547008048430&amp;type=share&amp;url=http%3A%2F%2Fwebcache.googleusercontent.com%2Fsearch%3Fq%3Dcache%3Aij0anEYo75YJ%3Aobjectsonrails.com%2F%2B%26cd%3D1%26hl%3Den%26ct%3Dclnk%26gl%3Dvn&amp;via=avdi"></iframe>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></li>
    <li><div id="___plusone_0" style="text-indent: 0px; margin: 0px; padding: 0px; background: transparent; border-style: none; float: none; line-height: normal; font-size: 1px; vertical-align: baseline; display: inline-block; width: 32px; height: 20px;"><iframe ng-non-bindable="" frameborder="0" hspace="0" marginheight="0" marginwidth="0" scrolling="no" style="position: static; top: 0px; width: 32px; margin: 0px; border-style: none; left: 0px; visibility: visible; height: 20px;" tabindex="0" vspace="0" width="100%" id="I0_1547008047904" name="I0_1547008047904" src="https://apis.google.com/u/0/se/0/_/+1/fastbutton?usegapi=1&amp;size=medium&amp;annotation=none&amp;origin=http%3A%2F%2Fwebcache.googleusercontent.com&amp;url=http%3A%2F%2Fobjectsonrails.com%2F&amp;gsrc=3p&amp;ic=1&amp;jsh=m%3B%2F_%2Fscs%2Fapps-static%2F_%2Fjs%2Fk%3Doz.gapi.en.COaYzTRXlXk.O%2Fam%3DQQ%2Frt%3Dj%2Fd%3D1%2Frs%3DAGLTcCMWUg7n4WrJDPw_obRv3Lg7jd5-FA%2Fm%3D__features__#_methods=onPlusOne%2C_ready%2C_close%2C_open%2C_resizeMe%2C_renderstart%2Concircled%2Cdrefresh%2Cerefresh%2Conload&amp;id=I0_1547008047904&amp;_gfid=I0_1547008047904&amp;parent=http%3A%2F%2Fwebcache.googleusercontent.com&amp;pfname=&amp;rpctoken=18303090" data-gapiattached="true" title="G+"></iframe></div></li>
  </ul>
</nav>

<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>

<script src="//static.getclicky.com/js" type="text/javascript"></script>
<script type="text/javascript">try{ clicky.init(66552939); }catch(e){}</script>
<noscript><p><img alt="Clicky" width="1" height="1" src="//in.getclicky.com/66552939ns.gif" /></p></noscript>
</div>
</div>
</body>
</html>